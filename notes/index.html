<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/ba2ac58ab1b61886.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-eccdf31a1c08998d.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-098b09d98c40a7be.js" async="" crossorigin=""></script><script src="/_next/static/chunks/938-ab30e0988b87a1e5.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-6fe0b32b410fd13f.js" async="" crossorigin=""></script><script src="/_next/static/chunks/102-53c00f3c219cee5b.js" async=""></script><script src="/_next/static/chunks/531-91565e0f279205d9.js" async=""></script><script src="/_next/static/chunks/131-2ce19c52dc066886.js" async=""></script><script src="/_next/static/chunks/app/notes/page-b381320519e05c08.js" async=""></script><script src="/_next/static/chunks/250-61453098be97c510.js" async=""></script><script src="/_next/static/chunks/app/layout-b6fb640cf1bf2fb2.js" async=""></script><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"/><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#111827"/><title>Learning Notes | Ding Yunliang</title><meta name="description" content="Personal learning notes on JavaScript, CSS, React, Cloudflare, and other web development topics."/><link rel="author" href="https://dingyunliang.github.io"/><meta name="author" content="Ding Yunliang"/><link rel="manifest" href="/site.webmanifest"/><meta name="keywords" content="Full-Stack Developer,Web Developer,React Developer,Next.js,TypeScript,Node.js,Portfolio,Ding Yunliang"/><meta name="creator" content="Ding Yunliang"/><meta name="publisher" content="Ding Yunliang"/><meta name="robots" content="index, follow"/><meta name="googlebot" content="index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"/><meta name="category" content="technology"/><link rel="canonical" href="https://dingyunliang.github.io"/><meta property="og:title" content="Ding Yunliang | Full-Stack Developer &amp; Creative Problem Solver"/><meta property="og:description" content="Explore the portfolio of Ding Yunliang - a Full-Stack Developer crafting beautiful, performant web applications with React, Next.js, and modern technologies."/><meta property="og:url" content="https://dingyunliang.github.io"/><meta property="og:site_name" content="Ding Yunliang Portfolio"/><meta property="og:locale" content="en_US"/><meta property="og:image" content="http://localhost:3000/og-image.jpg"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:alt" content="Ding Yunliang - Full-Stack Developer Portfolio"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:creator" content="@dingyunliang"/><meta name="twitter:title" content="Ding Yunliang | Full-Stack Developer"/><meta name="twitter:description" content="Full-Stack Developer specializing in React, Next.js, and Node.js. View my portfolio and let&#x27;s build something amazing together."/><meta name="twitter:image" content="http://localhost:3000/og-image.jpg"/><link rel="shortcut icon" href="/favicon-16x16.png"/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Person","name":"Ding Yunliang","url":"https://dingyunliang.github.io","jobTitle":"Full-Stack Developer","description":"Full-Stack Developer specializing in React, Next.js, TypeScript, and Node.js","sameAs":["https://github.com/dingyunliang","https://www.linkedin.com/in/yunliang-ding","https://twitter.com/dingyunliang"],"knowsAbout":["Web Development","React","Next.js","TypeScript","Node.js","JavaScript","Tailwind CSS"]}</script><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300"><script src="/_next/static/chunks/webpack-eccdf31a1c08998d.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/ba2ac58ab1b61886.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[47690,[],\"\"]\n5:I[33343,[\"102\",\"static/chunks/102-53c00f3c219cee5b.js\",\"531\",\"static/chunks/531-91565e0f279205d9.js\",\"131\",\"static/chunks/131-2ce19c52dc066886.js\",\"151\",\"static/chunks/app/notes/page-b381320519e05c08.js\"],\"\"]\n1d:I[5613,[],\"\"]\n1e:I[31778,[],\"\"]\n1f:I[26713,[\"250\",\"static/chunks/250-61453098be97c510.js\",\"185\",\"static/chunks/app/layout-b6fb640cf1bf2fb2.js\"],\"ThemeProvider\"]\n20:I[8718,[\"250\",\"static/chunks/250-61453098be97c510.js\",\"185\",\"static/chunks/app/layout-b6fb640cf1bf2fb2.js\"],\"\"]\n21:I["])</script><script>self.__next_f.push([1,"25250,[\"250\",\"static/chunks/250-61453098be97c510.js\",\"185\",\"static/chunks/app/layout-b6fb640cf1bf2fb2.js\"],\"\"]\n23:I[48955,[],\"\"]\n6:T1add,"])</script><script>self.__next_f.push([1,"\n# GIC (Generic Interrupt Controller)\n\n## GIC Architecture\n\n```\n┌────────────────────────────────────────────────────────────┐\n│                        GIC-600                              │\n│  ┌────────────────────────────────────────────────────┐   │\n│  │                   Distributor                       │   │\n│  │          (Interrupt routing \u0026 prioritization)       │   │\n│  └────────────────────────┬───────────────────────────┘   │\n│                           │                                │\n│  ┌──────────────┬─────────┴──────────┬──────────────┐    │\n│  │              │                    │              │    │\n│  │ Redistributor│   Redistributor   │Redistributor │    │\n│  │   (CPU0)     │     (CPU1)        │   (CPU2)     │    │\n│  └──────┬───────┴────────┬──────────┴──────┬───────┘    │\n│         │                │                  │            │\n│  ┌──────▼───────┐ ┌──────▼───────┐ ┌───────▼──────┐    │\n│  │ CPU Interface│ │CPU Interface │ │CPU Interface │    │\n│  │    (CPU0)    │ │   (CPU1)     │ │   (CPU2)     │    │\n│  └──────────────┘ └──────────────┘ └──────────────┘    │\n└────────────────────────────────────────────────────────────┘\n         │                │                  │\n         ▼                ▼                  ▼\n      Core 0           Core 1            Core 2\n```\n\n## Interrupt Types\n\n| Type | Range | Description |\n|------|-------|-------------|\n| SGI | 0-15 | Software Generated Interrupts (IPI) |\n| PPI | 16-31 | Private Peripheral Interrupts |\n| SPI | 32-1019 | Shared Peripheral Interrupts |\n| LPI | 8192+ | Locality-specific Peripheral Interrupts |\n\n## GIC Driver (Linux)\n\n### Device Tree Configuration\n```dts\ngic: interrupt-controller@fee00000 {\n    compatible = \"arm,gic-v3\";\n    #interrupt-cells = \u003c3\u003e;\n    #address-cells = \u003c2\u003e;\n    #size-cells = \u003c2\u003e;\n    ranges;\n    interrupt-controller;\n\n    reg = \u003c0x0 0xfee00000 0 0x10000\u003e,   /* GICD */\n          \u003c0x0 0xfef00000 0 0xc0000\u003e,   /* GICR */\n          \u003c0x0 0xfff00000 0 0x10000\u003e,   /* GICC */\n          \u003c0x0 0xfff10000 0 0x10000\u003e,   /* GICH */\n          \u003c0x0 0xfff20000 0 0x10000\u003e;   /* GICV */\n\n    interrupts = \u003cGIC_PPI 9 IRQ_TYPE_LEVEL_HIGH\u003e;\n\n    its: msi-controller@fee20000 {\n        compatible = \"arm,gic-v3-its\";\n        reg = \u003c0x0 0xfee20000 0x0 0x20000\u003e;\n        msi-controller;\n        #msi-cells = \u003c1\u003e;\n    };\n};\n```\n\n### Using GIC in Device Driver\n```c\n#include \u003clinux/interrupt.h\u003e\n#include \u003clinux/of_irq.h\u003e\n\nstatic int my_driver_probe(struct platform_device *pdev) {\n    int irq, ret;\n    struct device *dev = \u0026pdev-\u003edev;\n\n    // Get IRQ from device tree\n    irq = platform_get_irq(pdev, 0);\n    if (irq \u003c 0)\n        return irq;\n\n    // Request threaded IRQ\n    ret = devm_request_threaded_irq(dev, irq,\n                                     my_hard_isr,\n                                     my_thread_handler,\n                                     IRQF_SHARED,\n                                     \"my-device\",\n                                     priv);\n\n    return ret;\n}\n```\n\n### IRQ Domain and Mapping\n```c\n#include \u003clinux/irqdomain.h\u003e\n\nstruct my_irq_chip_data {\n    void __iomem *base;\n    struct irq_domain *domain;\n    spinlock_t lock;\n};\n\nstatic void my_irq_mask(struct irq_data *d) {\n    struct my_irq_chip_data *data = irq_data_get_irq_chip_data(d);\n    u32 reg;\n\n    spin_lock(\u0026data-\u003elock);\n    reg = readl(data-\u003ebase + IRQ_ENABLE);\n    reg \u0026= ~BIT(d-\u003ehwirq);\n    writel(reg, data-\u003ebase + IRQ_ENABLE);\n    spin_unlock(\u0026data-\u003elock);\n}\n\nstatic void my_irq_unmask(struct irq_data *d) {\n    struct my_irq_chip_data *data = irq_data_get_irq_chip_data(d);\n    u32 reg;\n\n    spin_lock(\u0026data-\u003elock);\n    reg = readl(data-\u003ebase + IRQ_ENABLE);\n    reg |= BIT(d-\u003ehwirq);\n    writel(reg, data-\u003ebase + IRQ_ENABLE);\n    spin_unlock(\u0026data-\u003elock);\n}\n\nstatic struct irq_chip my_irq_chip = {\n    .name = \"my-irq\",\n    .irq_mask = my_irq_mask,\n    .irq_unmask = my_irq_unmask,\n    .irq_ack = my_irq_ack,\n    .irq_set_type = my_irq_set_type,\n};\n\nstatic int my_irq_domain_map(struct irq_domain *domain,\n                              unsigned int virq,\n                              irq_hw_number_t hwirq) {\n    struct my_irq_chip_data *data = domain-\u003ehost_data;\n\n    irq_set_chip_and_handler(virq, \u0026my_irq_chip, handle_level_irq);\n    irq_set_chip_data(virq, data);\n    irq_set_noprobe(virq);\n\n    return 0;\n}\n\nstatic const struct irq_domain_ops my_irq_domain_ops = {\n    .map = my_irq_domain_map,\n    .xlate = irq_domain_xlate_twocell,\n};\n```\n\n## IPI (Inter-Processor Interrupt)\n\n```c\n// Send IPI to specific CPU\n#include \u003clinux/smp.h\u003e\n\n// Using arch-specific call\nvoid send_ipi_to_cpu(int cpu) {\n    smp_call_function_single(cpu, my_ipi_handler, data, wait);\n}\n\n// Send to all CPUs\nsmp_call_function(my_handler, data, wait);\n\n// Low-level GIC IPI (SGI)\n// For custom bare-metal or hypervisor use\nstatic inline void gic_send_sgi(u8 sgi_id, u64 target_list) {\n    u64 val = ((target_list \u0026 0xFFFF) \u003c\u003c 0) |\n              ((u64)sgi_id \u003c\u003c 24);\n\n    // Write to ICC_SGI1R_EL1\n    write_sysreg_s(val, SYS_ICC_SGI1R_EL1);\n    isb();\n}\n```\n\n## Affinity and CPU Binding\n\n```c\n// Set IRQ affinity\n#include \u003clinux/interrupt.h\u003e\n#include \u003clinux/cpumask.h\u003e\n\nint set_irq_affinity(int irq, int cpu) {\n    cpumask_t mask;\n\n    cpumask_clear(\u0026mask);\n    cpumask_set_cpu(cpu, \u0026mask);\n\n    return irq_set_affinity(irq, \u0026mask);\n}\n\n// Set affinity hint (for performance)\nirq_set_affinity_hint(irq, cpumask_of(cpu));\n\n// Read current affinity\nconst struct cpumask *mask = irq_get_affinity_mask(irq);\n```\n\n## Debug and Status\n\n```bash\n# View interrupt statistics\ncat /proc/interrupts\n\n# View IRQ affinity\ncat /proc/irq/\u003cirq\u003e/smp_affinity\n\n# Set affinity (hex mask)\necho 4 \u003e /proc/irq/\u003cirq\u003e/smp_affinity  # CPU 2 only\n\n# View effective affinity\ncat /proc/irq/\u003cirq\u003e/effective_affinity\n\n# IRQ debug info\ncat /sys/kernel/debug/irq/\u003cirq\u003e/chip_name\ncat /sys/kernel/debug/irq/\u003cirq\u003e/actions\n```\n"])</script><script>self.__next_f.push([1,"7:T13c6,"])</script><script>self.__next_f.push([1,"\n# I2C Protocol and Drivers\n\n## I2C Protocol Overview\n\n```\nMaster                           Slave (0x50)\n  │                                  │\n  │◄──────── SDA (bidirectional) ────►│\n  │◄──────── SCL (clock) ────────────►│\n  │                                  │\n\nStart → Address (7/10-bit) → R/W → ACK → Data → ACK → Stop\n```\n\n### Timing Diagram\n```\nSCL:  ▔▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔▔\nSDA:  ▔▔╲_____A6____A5____A4____A3____A2____A1____A0____R/W__╱▔\n          │                                              │\n        Start                                          Stop\n```\n\n## Linux I2C Subsystem\n\n### I2C Adapter Driver\n```c\n#include \u003clinux/i2c.h\u003e\n#include \u003clinux/platform_device.h\u003e\n\nstruct my_i2c {\n    void __iomem *base;\n    struct i2c_adapter adapter;\n    struct clk *clk;\n    int irq;\n    struct completion xfer_done;\n};\n\nstatic int my_i2c_xfer(struct i2c_adapter *adap,\n                       struct i2c_msg *msgs, int num) {\n    struct my_i2c *i2c = i2c_get_adapdata(adap);\n    int i, ret;\n\n    for (i = 0; i \u003c num; i++) {\n        reinit_completion(\u0026i2c-\u003exfer_done);\n\n        // Set slave address\n        writel(msgs[i].addr, i2c-\u003ebase + I2C_ADDR);\n\n        // Set transfer direction\n        if (msgs[i].flags \u0026 I2C_M_RD)\n            writel(I2C_READ, i2c-\u003ebase + I2C_CTRL);\n        else\n            writel(I2C_WRITE, i2c-\u003ebase + I2C_CTRL);\n\n        // Set data length\n        writel(msgs[i].len, i2c-\u003ebase + I2C_LEN);\n\n        // Start transfer\n        writel(I2C_START, i2c-\u003ebase + I2C_CMD);\n\n        // Wait for completion\n        ret = wait_for_completion_timeout(\u0026i2c-\u003exfer_done,\n                                          msecs_to_jiffies(1000));\n        if (!ret)\n            return -ETIMEDOUT;\n    }\n\n    return num;\n}\n\nstatic u32 my_i2c_func(struct i2c_adapter *adap) {\n    return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm my_i2c_algo = {\n    .master_xfer = my_i2c_xfer,\n    .functionality = my_i2c_func,\n};\n\nstatic irqreturn_t my_i2c_isr(int irq, void *dev_id) {\n    struct my_i2c *i2c = dev_id;\n    u32 status = readl(i2c-\u003ebase + I2C_STATUS);\n\n    if (status \u0026 I2C_COMPLETE) {\n        writel(I2C_COMPLETE, i2c-\u003ebase + I2C_STATUS);\n        complete(\u0026i2c-\u003exfer_done);\n    }\n\n    return IRQ_HANDLED;\n}\n\nstatic int my_i2c_probe(struct platform_device *pdev) {\n    struct my_i2c *i2c;\n    struct resource *res;\n\n    i2c = devm_kzalloc(\u0026pdev-\u003edev, sizeof(*i2c), GFP_KERNEL);\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    i2c-\u003ebase = devm_ioremap_resource(\u0026pdev-\u003edev, res);\n\n    i2c-\u003eclk = devm_clk_get(\u0026pdev-\u003edev, NULL);\n    clk_prepare_enable(i2c-\u003eclk);\n\n    i2c-\u003eirq = platform_get_irq(pdev, 0);\n    devm_request_irq(\u0026pdev-\u003edev, i2c-\u003eirq, my_i2c_isr, 0,\n                     \"my-i2c\", i2c);\n\n    init_completion(\u0026i2c-\u003exfer_done);\n\n    i2c-\u003eadapter.owner = THIS_MODULE;\n    i2c-\u003eadapter.algo = \u0026my_i2c_algo;\n    i2c-\u003eadapter.dev.parent = \u0026pdev-\u003edev;\n    i2c-\u003eadapter.dev.of_node = pdev-\u003edev.of_node;\n    i2c_set_adapdata(\u0026i2c-\u003eadapter, i2c);\n\n    return i2c_add_adapter(\u0026i2c-\u003eadapter);\n}\n```\n\n### I2C Client Driver (Sensor)\n```c\n#include \u003clinux/i2c.h\u003e\n#include \u003clinux/regmap.h\u003e\n\nstruct my_sensor {\n    struct i2c_client *client;\n    struct regmap *regmap;\n};\n\nstatic const struct regmap_config my_regmap_config = {\n    .reg_bits = 8,\n    .val_bits = 8,\n    .max_register = 0xFF,\n    .cache_type = REGCACHE_RBTREE,\n};\n\nstatic int my_sensor_read_temp(struct my_sensor *sensor, int *temp) {\n    unsigned int val;\n    int ret;\n\n    ret = regmap_read(sensor-\u003eregmap, TEMP_REG, \u0026val);\n    if (ret)\n        return ret;\n\n    *temp = (int)(val * 1000) / 256;  // Convert to milli-degrees\n    return 0;\n}\n\nstatic int my_sensor_probe(struct i2c_client *client) {\n    struct my_sensor *sensor;\n\n    sensor = devm_kzalloc(\u0026client-\u003edev, sizeof(*sensor), GFP_KERNEL);\n    sensor-\u003eclient = client;\n\n    sensor-\u003eregmap = devm_regmap_init_i2c(client, \u0026my_regmap_config);\n    if (IS_ERR(sensor-\u003eregmap))\n        return PTR_ERR(sensor-\u003eregmap);\n\n    i2c_set_clientdata(client, sensor);\n\n    return 0;\n}\n\nstatic const struct i2c_device_id my_sensor_id[] = {\n    { \"my-sensor\", 0 },\n    { }\n};\nMODULE_DEVICE_TABLE(i2c, my_sensor_id);\n\nstatic const struct of_device_id my_sensor_of_match[] = {\n    { .compatible = \"vendor,my-sensor\" },\n    { }\n};\nMODULE_DEVICE_TABLE(of, my_sensor_of_match);\n\nstatic struct i2c_driver my_sensor_driver = {\n    .driver = {\n        .name = \"my-sensor\",\n        .of_match_table = my_sensor_of_match,\n    },\n    .probe = my_sensor_probe,\n    .id_table = my_sensor_id,\n};\nmodule_i2c_driver(my_sensor_driver);\n```\n\n## I2C Debug Commands\n\n```bash\n# List I2C buses\ni2cdetect -l\n\n# Scan bus for devices\ni2cdetect -y 0\n\n# Read register\ni2cget -y 0 0x50 0x00\n\n# Write register\ni2cset -y 0 0x50 0x00 0xFF\n\n# Dump all registers\ni2cdump -y 0 0x50\n\n# Transfer with multiple messages\ni2ctransfer -y 0 w2@0x50 0x00 0x10 r4\n```\n"])</script><script>self.__next_f.push([1,"8:T1ce9,"])</script><script>self.__next_f.push([1,"\n# MIPI CSI-2 Camera Interface\n\n## CSI-2 Architecture\n\n```\n┌─────────────────┐         ┌─────────────────┐\n│  Image Sensor   │         │  SoC CSI-2 RX   │\n│                 │         │                 │\n│  ┌───────────┐  │   D-PHY │  ┌───────────┐  │\n│  │   ISP     │  │◄────────┤  │   D-PHY   │  │\n│  └───────────┘  │  Clock  │  │   RX      │  │\n│       │        │  Lane    │  └───────────┘  │\n│  ┌───────────┐  │         │       │        │\n│  │   CSI-2   │──┼─────────┼──►┌───────────┐  │\n│  │   TX      │  │  Data   │  │   CSI-2   │  │\n│  └───────────┘  │  Lanes  │  │   Parser  │  │\n│       │        │  (1-4)   │  └───────────┘  │\n│  ┌───────────┐  │         │       │        │\n│  │   D-PHY   │──┼─────────┼──►┌───────────┐  │\n│  │   TX      │  │         │  │   DMA     │  │\n│  └───────────┘  │         │  └───────────┘  │\n└─────────────────┘         └─────────────────┘\n```\n\n## CSI-2 Packet Format\n\n### Short Packet (Frame/Line Sync)\n```\n┌────────┬────────┬────────────┬────────┐\n│ SoT    │ Data ID│ Data Field │ ECC    │\n│ (D-PHY)│ (8-bit)│  (16-bit)  │ (8-bit)│\n└────────┴────────┴────────────┴────────┘\n```\n\n### Long Packet (Pixel Data)\n```\n┌────────┬────────┬───────────┬─────────────────┬──────────┐\n│ SoT    │ Data ID│ Word Count│    Payload      │ Checksum │\n│ (D-PHY)│ (8-bit)│  (16-bit) │   (Variable)    │  (16-bit)│\n└────────┴────────┴───────────┴─────────────────┴──────────┘\n```\n\n### Data Types\n| Code | Description |\n|------|-------------|\n| 0x00 | Frame Start |\n| 0x01 | Frame End |\n| 0x02 | Line Start |\n| 0x03 | Line End |\n| 0x2A | RAW8 |\n| 0x2B | RAW10 |\n| 0x2C | RAW12 |\n| 0x1E | YUV422 8-bit |\n| 0x24 | RGB888 |\n\n## CSI-2 Receiver Driver\n\n```c\n#include \u003cmedia/v4l2-subdev.h\u003e\n#include \u003cmedia/v4l2-fwnode.h\u003e\n\nstruct csi2_dev {\n    struct device *dev;\n    void __iomem *base;\n    struct v4l2_subdev sd;\n    struct media_pad pads[2];  // sink and source\n    struct v4l2_async_notifier notifier;\n    struct v4l2_mbus_framefmt format;\n    u8 num_lanes;\n    u8 data_lanes[4];\n};\n\n#define CSI2_CTRL           0x00\n#define CSI2_N_LANES        0x04\n#define CSI2_DATA_TYPE      0x08\n#define CSI2_ERR_STATUS     0x10\n#define CSI2_IRQ_ENABLE     0x14\n\nstatic int csi2_s_stream(struct v4l2_subdev *sd, int enable) {\n    struct csi2_dev *csi2 = container_of(sd, struct csi2_dev, sd);\n    u32 val;\n\n    if (enable) {\n        // Configure number of data lanes\n        writel(csi2-\u003enum_lanes - 1, csi2-\u003ebase + CSI2_N_LANES);\n\n        // Configure expected data type based on format\n        val = mbus_code_to_dt(csi2-\u003eformat.code);\n        writel(val, csi2-\u003ebase + CSI2_DATA_TYPE);\n\n        // Enable error interrupts\n        writel(CSI2_ERR_ALL, csi2-\u003ebase + CSI2_IRQ_ENABLE);\n\n        // Enable CSI-2 receiver\n        val = readl(csi2-\u003ebase + CSI2_CTRL);\n        val |= CSI2_CTRL_ENABLE;\n        writel(val, csi2-\u003ebase + CSI2_CTRL);\n    } else {\n        val = readl(csi2-\u003ebase + CSI2_CTRL);\n        val \u0026= ~CSI2_CTRL_ENABLE;\n        writel(val, csi2-\u003ebase + CSI2_CTRL);\n    }\n\n    return 0;\n}\n\nstatic u8 mbus_code_to_dt(u32 code) {\n    switch (code) {\n    case MEDIA_BUS_FMT_SBGGR10_1X10:\n    case MEDIA_BUS_FMT_SGBRG10_1X10:\n    case MEDIA_BUS_FMT_SGRBG10_1X10:\n    case MEDIA_BUS_FMT_SRGGB10_1X10:\n        return 0x2B;  // RAW10\n    case MEDIA_BUS_FMT_UYVY8_1X16:\n        return 0x1E;  // YUV422-8\n    default:\n        return 0x2A;  // RAW8\n    }\n}\n```\n\n## D-PHY Configuration\n\n```c\n#define DPHY_CTRL           0x00\n#define DPHY_PLL_CTRL       0x04\n#define DPHY_TIMING         0x08\n#define DPHY_LANE_ENABLE    0x0C\n\nstruct dphy_timing {\n    u32 clk_prepare;\n    u32 clk_zero;\n    u32 clk_trail;\n    u32 hs_prepare;\n    u32 hs_zero;\n    u32 hs_trail;\n    u32 hs_exit;\n};\n\nstatic int dphy_configure(struct csi2_dev *csi2, u64 link_freq) {\n    struct dphy_timing timing;\n    u32 val;\n\n    // Calculate timing parameters based on link frequency\n    // Values in nanoseconds, convert to PHY clock cycles\n    timing.clk_prepare = DIV_ROUND_UP(38 * link_freq, 1000000000);\n    timing.clk_zero = DIV_ROUND_UP(300 * link_freq, 1000000000);\n    timing.clk_trail = DIV_ROUND_UP(60 * link_freq, 1000000000);\n    timing.hs_prepare = DIV_ROUND_UP(55 * link_freq, 1000000000);\n    timing.hs_zero = DIV_ROUND_UP(145 * link_freq, 1000000000);\n    timing.hs_trail = DIV_ROUND_UP(60 * link_freq, 1000000000);\n    timing.hs_exit = DIV_ROUND_UP(100 * link_freq, 1000000000);\n\n    // Program timing registers\n    val = (timing.clk_prepare \u003c\u003c 24) | (timing.clk_zero \u003c\u003c 16) |\n          (timing.clk_trail \u003c\u003c 8);\n    writel(val, csi2-\u003ebase + DPHY_TIMING);\n\n    // Enable lanes\n    val = 0;\n    for (int i = 0; i \u003c csi2-\u003enum_lanes; i++)\n        val |= BIT(csi2-\u003edata_lanes[i]);\n    val |= BIT(4);  // Clock lane\n    writel(val, csi2-\u003ebase + DPHY_LANE_ENABLE);\n\n    // Enable D-PHY\n    writel(DPHY_ENABLE, csi2-\u003ebase + DPHY_CTRL);\n\n    return 0;\n}\n```\n\n## Error Handling\n\n```c\nstatic irqreturn_t csi2_isr(int irq, void *dev_id) {\n    struct csi2_dev *csi2 = dev_id;\n    u32 status = readl(csi2-\u003ebase + CSI2_ERR_STATUS);\n\n    if (status \u0026 CSI2_ERR_ECC_CORRECTED)\n        dev_dbg(csi2-\u003edev, \"ECC error corrected\\n\");\n\n    if (status \u0026 CSI2_ERR_ECC_UNCORRECTED)\n        dev_err(csi2-\u003edev, \"Uncorrectable ECC error\\n\");\n\n    if (status \u0026 CSI2_ERR_CRC)\n        dev_err(csi2-\u003edev, \"CRC error\\n\");\n\n    if (status \u0026 CSI2_ERR_FIFO_OVERFLOW)\n        dev_err(csi2-\u003edev, \"FIFO overflow\\n\");\n\n    if (status \u0026 CSI2_ERR_SOT_SYNC)\n        dev_warn(csi2-\u003edev, \"SOT sync error\\n\");\n\n    // Clear errors\n    writel(status, csi2-\u003ebase + CSI2_ERR_STATUS);\n\n    return IRQ_HANDLED;\n}\n```\n\n## Device Tree Binding\n\n```dts\ncsi2: csi@ff100000 {\n    compatible = \"vendor,csi2-receiver\";\n    reg = \u003c0x0 0xff100000 0x0 0x1000\u003e;\n    interrupts = \u003cGIC_SPI 50 IRQ_TYPE_LEVEL_HIGH\u003e;\n    clocks = \u003c\u0026cru CLK_CSI\u003e;\n    clock-names = \"csi_clk\";\n\n    ports {\n        #address-cells = \u003c1\u003e;\n        #size-cells = \u003c0\u003e;\n\n        port@0 {\n            reg = \u003c0\u003e;\n            csi2_in: endpoint {\n                remote-endpoint = \u003c\u0026sensor_out\u003e;\n                data-lanes = \u003c1 2 3 4\u003e;\n                clock-noncontinuous;\n            };\n        };\n\n        port@1 {\n            reg = \u003c1\u003e;\n            csi2_out: endpoint {\n                remote-endpoint = \u003c\u0026isp_in\u003e;\n            };\n        };\n    };\n};\n```\n"])</script><script>self.__next_f.push([1,"9:T1f48,"])</script><script>self.__next_f.push([1,"\n# MMU and SMMU/IOMMU\n\n## Memory Management Unit (MMU)\n\n### Address Translation\n```\n┌──────────────┐    ┌─────────────┐    ┌──────────────┐\n│   Virtual    │    │    MMU      │    │   Physical   │\n│   Address    │───►│  (TLB +     │───►│   Address    │\n│              │    │ Page Table) │    │              │\n└──────────────┘    └─────────────┘    └──────────────┘\n\nVA: 0xFFFF_0000_1234_5678\n    │       │        │\n    ├───────┘        │\n    │ L0 Index       │\n    │ L1 Index       │\n    │ L2 Index       │\n    │ L3 Index       │\n    └── Page Offset  ┘\n\n4KB pages: 12-bit offset\n64KB pages: 16-bit offset\n```\n\n### Page Table Entry (ARM64)\n```c\n/* PTE bits */\n#define PTE_VALID       (1UL \u003c\u003c 0)\n#define PTE_TABLE       (1UL \u003c\u003c 1)  /* Points to next level table */\n#define PTE_PAGE        (1UL \u003c\u003c 1)  /* Valid page */\n#define PTE_AF          (1UL \u003c\u003c 10) /* Access Flag */\n#define PTE_SH_INNER    (3UL \u003c\u003c 8)  /* Inner shareable */\n#define PTE_AP_RO       (1UL \u003c\u003c 7)  /* Read-only */\n#define PTE_AP_USER     (1UL \u003c\u003c 6)  /* User accessible */\n#define PTE_UXN         (1UL \u003c\u003c 54) /* User execute never */\n#define PTE_PXN         (1UL \u003c\u003c 53) /* Privileged execute never */\n\n/* Memory attributes (MAIR index) */\n#define PTE_ATTRINDX(n) ((n) \u003c\u003c 2)\n#define MT_DEVICE_nGnRnE 0  /* Device memory */\n#define MT_NORMAL        4  /* Normal cacheable */\n```\n\n## System MMU (SMMU/IOMMU)\n\n### SMMU Architecture\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         SMMU                                 │\n│  ┌────────────────────────────────────────────────────┐    │\n│  │              Stream Table Entry (STE)               │    │\n│  │    (Maps StreamID to Context Descriptor)            │    │\n│  └────────────────────────┬───────────────────────────┘    │\n│                           │                                 │\n│  ┌────────────────────────▼───────────────────────────┐    │\n│  │            Context Descriptor (CD)                  │    │\n│  │      (Contains page table base address)             │    │\n│  └────────────────────────┬───────────────────────────┘    │\n│                           │                                 │\n│  ┌────────────────────────▼───────────────────────────┐    │\n│  │              Translation Tables                     │    │\n│  │         (Same format as CPU page tables)            │    │\n│  └─────────────────────────────────────────────────────┘    │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Linux IOMMU API\n\n```c\n#include \u003clinux/iommu.h\u003e\n#include \u003clinux/dma-mapping.h\u003e\n\nstatic int my_driver_probe(struct platform_device *pdev) {\n    struct device *dev = \u0026pdev-\u003edev;\n    struct iommu_domain *domain;\n    phys_addr_t phys;\n    dma_addr_t iova;\n\n    // Check if IOMMU is available\n    if (!device_iommu_mapped(dev)) {\n        dev_info(dev, \"No IOMMU, using direct DMA\\n\");\n        goto use_dma_api;\n    }\n\n    // Allocate custom IOMMU domain (optional)\n    domain = iommu_domain_alloc(dev-\u003ebus);\n    if (!domain)\n        return -ENOMEM;\n\n    // Attach device to domain\n    iommu_attach_device(domain, dev);\n\n    // Map physical memory to IOVA\n    phys = virt_to_phys(buffer);\n    iova = 0x10000000;  // Desired IOVA\n\n    iommu_map(domain, iova, phys, size,\n              IOMMU_READ | IOMMU_WRITE | IOMMU_CACHE);\n\n    return 0;\n\nuse_dma_api:\n    // Standard DMA API (IOMMU-aware)\n    iova = dma_map_single(dev, buffer, size, DMA_BIDIRECTIONAL);\n    if (dma_mapping_error(dev, iova))\n        return -ENOMEM;\n\n    return 0;\n}\n```\n\n### Device Tree IOMMU Binding\n```dts\nsmmu: iommu@fd800000 {\n    compatible = \"arm,smmu-v3\";\n    reg = \u003c0x0 0xfd800000 0x0 0x100000\u003e;\n    interrupts = \u003cGIC_SPI 200 IRQ_TYPE_EDGE_RISING\u003e,\n                 \u003cGIC_SPI 201 IRQ_TYPE_EDGE_RISING\u003e;\n    interrupt-names = \"eventq\", \"gerror\";\n    #iommu-cells = \u003c1\u003e;\n    dma-coherent;\n};\n\ngpu: gpu@ff100000 {\n    compatible = \"vendor,gpu\";\n    reg = \u003c0x0 0xff100000 0x0 0x10000\u003e;\n    iommus = \u003c\u0026smmu 0x100\u003e;  /* StreamID = 0x100 */\n};\n\nipu: ipu@ff200000 {\n    compatible = \"vendor,ipu\";\n    reg = \u003c0x0 0xff200000 0x0 0x20000\u003e;\n    iommus = \u003c\u0026smmu 0x101\u003e;  /* StreamID = 0x101 */\n};\n```\n\n### Custom IOMMU Operations\n\n```c\n#include \u003clinux/iommu.h\u003e\n\nstatic struct iommu_domain *my_iommu_domain_alloc(unsigned type) {\n    struct my_domain *domain;\n\n    if (type != IOMMU_DOMAIN_DMA \u0026\u0026 type != IOMMU_DOMAIN_UNMANAGED)\n        return NULL;\n\n    domain = kzalloc(sizeof(*domain), GFP_KERNEL);\n    if (!domain)\n        return NULL;\n\n    // Allocate page tables\n    domain-\u003epgd = (pgd_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);\n\n    return \u0026domain-\u003edomain;\n}\n\nstatic int my_iommu_map(struct iommu_domain *domain,\n                        unsigned long iova, phys_addr_t paddr,\n                        size_t size, int prot, gfp_t gfp) {\n    struct my_domain *my = to_my_domain(domain);\n    unsigned long flags = 0;\n\n    if (prot \u0026 IOMMU_READ)\n        flags |= PTE_VALID;\n    if (prot \u0026 IOMMU_WRITE)\n        flags |= PTE_WRITE;\n    if (prot \u0026 IOMMU_CACHE)\n        flags |= PTE_ATTRINDX(MT_NORMAL);\n\n    return my_create_mapping(my, iova, paddr, size, flags);\n}\n\nstatic const struct iommu_ops my_iommu_ops = {\n    .domain_alloc = my_iommu_domain_alloc,\n    .probe_device = my_iommu_probe_device,\n    .device_group = generic_device_group,\n    .default_domain_ops = \u0026(const struct iommu_domain_ops) {\n        .attach_dev = my_iommu_attach_device,\n        .map = my_iommu_map,\n        .unmap = my_iommu_unmap,\n        .iova_to_phys = my_iommu_iova_to_phys,\n        .free = my_iommu_domain_free,\n    },\n};\n```\n\n## TLB Management\n\n```c\n// Invalidate TLB in SMMU\nstatic void my_smmu_tlb_inv_context(void *cookie) {\n    struct my_smmu_domain *domain = cookie;\n    struct my_smmu *smmu = domain-\u003esmmu;\n\n    // Issue TLBI command\n    writel(CMDQ_OP_TLBI_NH_ASID | domain-\u003easid,\n           smmu-\u003ebase + SMMU_CMDQ_PROD);\n\n    // Wait for completion\n    my_smmu_cmdq_sync(smmu);\n}\n\nstatic void my_smmu_tlb_inv_range(unsigned long iova, size_t size,\n                                   size_t granule, bool leaf,\n                                   void *cookie) {\n    struct my_smmu_domain *domain = cookie;\n    unsigned long end = iova + size;\n\n    while (iova \u003c end) {\n        // Issue TLBI by VA\n        my_smmu_issue_tlbi_va(domain, iova, granule, leaf);\n        iova += granule;\n    }\n}\n\nstatic const struct iommu_flush_ops my_smmu_flush_ops = {\n    .tlb_flush_all = my_smmu_tlb_inv_context,\n    .tlb_flush_walk = my_smmu_tlb_inv_range,\n    .tlb_add_page = my_smmu_tlb_inv_range,\n};\n```\n\n## Debug\n\n```bash\n# Check IOMMU groups\nls /sys/kernel/iommu_groups/\n\n# View devices in group\nls /sys/kernel/iommu_groups/0/devices/\n\n# IOMMU debug\ncat /sys/kernel/debug/iommu/domain_*/mappings\n```\n"])</script><script>self.__next_f.push([1,"a:T22c1,"])</script><script>self.__next_f.push([1,"\n# PCIe Driver Development\n\n## PCIe Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                       Root Complex                           │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │              Root Port (RP)                          │    │\n│  └────────────────────────┬────────────────────────────┘    │\n└───────────────────────────┼─────────────────────────────────┘\n                            │ PCIe Link (x1, x4, x8, x16)\n                            │\n┌───────────────────────────┴─────────────────────────────────┐\n│                      Endpoint (EP)                           │\n│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │\n│  │   BAR0     │  │   BAR1     │  │   BAR2     │            │\n│  │  (MMIO)    │  │  (MMIO)    │  │   (DMA)    │            │\n│  └────────────┘  └────────────┘  └────────────┘            │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## PCIe Device Driver\n\n```c\n#include \u003clinux/pci.h\u003e\n#include \u003clinux/module.h\u003e\n#include \u003clinux/interrupt.h\u003e\n\n#define VENDOR_ID       0x8086\n#define DEVICE_ID       0x1234\n\nstruct my_pcie_dev {\n    struct pci_dev *pdev;\n    void __iomem *bar0;\n    void __iomem *bar1;\n    int irq;\n    spinlock_t lock;\n};\n\nstatic int my_pcie_probe(struct pci_dev *pdev,\n                         const struct pci_device_id *id) {\n    struct my_pcie_dev *dev;\n    int ret;\n\n    dev = devm_kzalloc(\u0026pdev-\u003edev, sizeof(*dev), GFP_KERNEL);\n    if (!dev)\n        return -ENOMEM;\n\n    dev-\u003epdev = pdev;\n    pci_set_drvdata(pdev, dev);\n\n    // Enable device\n    ret = pcim_enable_device(pdev);\n    if (ret)\n        return ret;\n\n    // Request regions\n    ret = pcim_iomap_regions(pdev, BIT(0) | BIT(1), \"my-pcie\");\n    if (ret)\n        return ret;\n\n    // Map BARs\n    dev-\u003ebar0 = pcim_iomap_table(pdev)[0];\n    dev-\u003ebar1 = pcim_iomap_table(pdev)[1];\n\n    // Enable bus mastering for DMA\n    pci_set_master(pdev);\n\n    // Set DMA mask\n    ret = dma_set_mask_and_coherent(\u0026pdev-\u003edev, DMA_BIT_MASK(64));\n    if (ret) {\n        ret = dma_set_mask_and_coherent(\u0026pdev-\u003edev, DMA_BIT_MASK(32));\n        if (ret)\n            return ret;\n    }\n\n    // Request MSI-X or MSI interrupts\n    ret = pci_alloc_irq_vectors(pdev, 1, 4, PCI_IRQ_MSIX | PCI_IRQ_MSI);\n    if (ret \u003c 0)\n        return ret;\n\n    dev-\u003eirq = pci_irq_vector(pdev, 0);\n    ret = devm_request_irq(\u0026pdev-\u003edev, dev-\u003eirq, my_pcie_isr,\n                           0, \"my-pcie\", dev);\n    if (ret)\n        return ret;\n\n    spin_lock_init(\u0026dev-\u003elock);\n\n    // Initialize hardware\n    writel(CTRL_RESET, dev-\u003ebar0 + REG_CTRL);\n    udelay(100);\n    writel(CTRL_ENABLE, dev-\u003ebar0 + REG_CTRL);\n\n    dev_info(\u0026pdev-\u003edev, \"Device initialized\\n\");\n\n    return 0;\n}\n\nstatic void my_pcie_remove(struct pci_dev *pdev) {\n    struct my_pcie_dev *dev = pci_get_drvdata(pdev);\n\n    // Disable hardware\n    writel(0, dev-\u003ebar0 + REG_CTRL);\n\n    pci_free_irq_vectors(pdev);\n}\n\nstatic const struct pci_device_id my_pcie_ids[] = {\n    { PCI_DEVICE(VENDOR_ID, DEVICE_ID) },\n    { }\n};\nMODULE_DEVICE_TABLE(pci, my_pcie_ids);\n\nstatic struct pci_driver my_pcie_driver = {\n    .name = \"my-pcie\",\n    .id_table = my_pcie_ids,\n    .probe = my_pcie_probe,\n    .remove = my_pcie_remove,\n};\nmodule_pci_driver(my_pcie_driver);\n```\n\n## DMA Operations\n\n```c\nstruct my_dma_desc {\n    dma_addr_t src;\n    dma_addr_t dst;\n    u32 len;\n    u32 flags;\n} __packed;\n\nstatic int my_pcie_dma_transfer(struct my_pcie_dev *dev,\n                                 void *buf, size_t len,\n                                 enum dma_data_direction dir) {\n    dma_addr_t dma_addr;\n    struct my_dma_desc *desc;\n    dma_addr_t desc_dma;\n\n    // Allocate descriptor\n    desc = dma_alloc_coherent(\u0026dev-\u003epdev-\u003edev, sizeof(*desc),\n                              \u0026desc_dma, GFP_KERNEL);\n    if (!desc)\n        return -ENOMEM;\n\n    // Map buffer\n    dma_addr = dma_map_single(\u0026dev-\u003epdev-\u003edev, buf, len, dir);\n    if (dma_mapping_error(\u0026dev-\u003epdev-\u003edev, dma_addr)) {\n        dma_free_coherent(\u0026dev-\u003epdev-\u003edev, sizeof(*desc), desc, desc_dma);\n        return -ENOMEM;\n    }\n\n    // Setup descriptor\n    if (dir == DMA_TO_DEVICE) {\n        desc-\u003esrc = dma_addr;\n        desc-\u003edst = 0;  // Device internal address\n        desc-\u003eflags = DMA_DESC_TO_DEVICE;\n    } else {\n        desc-\u003esrc = 0;\n        desc-\u003edst = dma_addr;\n        desc-\u003eflags = DMA_DESC_FROM_DEVICE;\n    }\n    desc-\u003elen = len;\n\n    // Write descriptor address to hardware\n    writeq(desc_dma, dev-\u003ebar0 + REG_DMA_DESC);\n\n    // Start DMA\n    writel(DMA_START, dev-\u003ebar0 + REG_DMA_CTRL);\n\n    // Wait for completion (in real driver, use interrupt)\n    while (!(readl(dev-\u003ebar0 + REG_DMA_STATUS) \u0026 DMA_COMPLETE))\n        cpu_relax();\n\n    // Cleanup\n    dma_unmap_single(\u0026dev-\u003epdev-\u003edev, dma_addr, len, dir);\n    dma_free_coherent(\u0026dev-\u003epdev-\u003edev, sizeof(*desc), desc, desc_dma);\n\n    return 0;\n}\n```\n\n## MSI-X Interrupt Handling\n\n```c\n#define NUM_MSIX_VECTORS 4\n\nstruct my_pcie_dev {\n    struct pci_dev *pdev;\n    void __iomem *bar0;\n    int num_vectors;\n    struct {\n        int irq;\n        char name[32];\n    } vectors[NUM_MSIX_VECTORS];\n};\n\nstatic irqreturn_t my_msix_handler(int irq, void *data) {\n    struct my_pcie_dev *dev = data;\n    u32 status = readl(dev-\u003ebar0 + REG_INT_STATUS);\n\n    // Handle interrupt based on status\n    if (status \u0026 INT_DMA_COMPLETE)\n        complete(\u0026dev-\u003edma_done);\n\n    if (status \u0026 INT_ERROR)\n        dev_err(\u0026dev-\u003epdev-\u003edev, \"Error interrupt\\n\");\n\n    // Clear interrupt\n    writel(status, dev-\u003ebar0 + REG_INT_STATUS);\n\n    return IRQ_HANDLED;\n}\n\nstatic int setup_msix(struct my_pcie_dev *dev) {\n    int ret, i;\n\n    ret = pci_alloc_irq_vectors(dev-\u003epdev, 1, NUM_MSIX_VECTORS,\n                                PCI_IRQ_MSIX);\n    if (ret \u003c 0)\n        return ret;\n\n    dev-\u003enum_vectors = ret;\n\n    for (i = 0; i \u003c dev-\u003enum_vectors; i++) {\n        dev-\u003evectors[i].irq = pci_irq_vector(dev-\u003epdev, i);\n        snprintf(dev-\u003evectors[i].name, sizeof(dev-\u003evectors[i].name),\n                 \"my-pcie-%d\", i);\n\n        ret = request_irq(dev-\u003evectors[i].irq, my_msix_handler,\n                          0, dev-\u003evectors[i].name, dev);\n        if (ret)\n            goto err_free_irq;\n    }\n\n    return 0;\n\nerr_free_irq:\n    while (--i \u003e= 0)\n        free_irq(dev-\u003evectors[i].irq, dev);\n    pci_free_irq_vectors(dev-\u003epdev);\n    return ret;\n}\n```\n\n## Configuration Space Access\n\n```c\n// Read configuration space\nu16 vendor, device;\nu8 revision;\n\npci_read_config_word(pdev, PCI_VENDOR_ID, \u0026vendor);\npci_read_config_word(pdev, PCI_DEVICE_ID, \u0026device);\npci_read_config_byte(pdev, PCI_REVISION_ID, \u0026revision);\n\n// Write configuration space\npci_write_config_word(pdev, PCI_COMMAND,\n                      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\n\n// Read capability\nint pos = pci_find_capability(pdev, PCI_CAP_ID_MSI);\nif (pos) {\n    u16 ctrl;\n    pci_read_config_word(pdev, pos + PCI_MSI_FLAGS, \u0026ctrl);\n}\n\n// Extended capability (PCIe)\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\n```\n\n## Power Management\n\n```c\nstatic int my_pcie_suspend(struct device *dev) {\n    struct pci_dev *pdev = to_pci_dev(dev);\n    struct my_pcie_dev *priv = pci_get_drvdata(pdev);\n\n    // Save device state\n    pci_save_state(pdev);\n\n    // Disable interrupts\n    writel(0, priv-\u003ebar0 + REG_INT_ENABLE);\n\n    // Enter D3\n    pci_set_power_state(pdev, PCI_D3hot);\n\n    return 0;\n}\n\nstatic int my_pcie_resume(struct device *dev) {\n    struct pci_dev *pdev = to_pci_dev(dev);\n    struct my_pcie_dev *priv = pci_get_drvdata(pdev);\n\n    // Return to D0\n    pci_set_power_state(pdev, PCI_D0);\n\n    // Restore state\n    pci_restore_state(pdev);\n\n    // Re-enable device\n    writel(CTRL_ENABLE, priv-\u003ebar0 + REG_CTRL);\n    writel(INT_ALL, priv-\u003ebar0 + REG_INT_ENABLE);\n\n    return 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(my_pcie_pm_ops,\n                                 my_pcie_suspend,\n                                 my_pcie_resume);\n```\n"])</script><script>self.__next_f.push([1,"b:T1808,"])</script><script>self.__next_f.push([1,"\n# SPI Protocol and Drivers\n\n## SPI Protocol Overview\n\n```\nMaster                              Slave\n  │                                   │\n  ├──────── SCLK (Clock) ────────────►│\n  ├──────── MOSI (Master Out) ───────►│\n  │◄──────── MISO (Master In) ────────┤\n  ├──────── CS (Chip Select) ────────►│\n  │                                   │\n```\n\n### SPI Modes\n| Mode | CPOL | CPHA | Description |\n|------|------|------|-------------|\n| 0    | 0    | 0    | Clock idle low, sample on rising edge |\n| 1    | 0    | 1    | Clock idle low, sample on falling edge |\n| 2    | 1    | 0    | Clock idle high, sample on falling edge |\n| 3    | 1    | 1    | Clock idle high, sample on rising edge |\n\n## Linux SPI Controller Driver\n\n```c\n#include \u003clinux/spi/spi.h\u003e\n#include \u003clinux/platform_device.h\u003e\n\nstruct my_spi {\n    void __iomem *base;\n    struct spi_controller *ctlr;\n    struct clk *clk;\n    struct completion done;\n    const u8 *tx_buf;\n    u8 *rx_buf;\n    int len;\n};\n\nstatic int my_spi_transfer_one(struct spi_controller *ctlr,\n                                struct spi_device *spi,\n                                struct spi_transfer *xfer) {\n    struct my_spi *spi_dev = spi_controller_get_devdata(ctlr);\n    u32 ctrl = 0;\n\n    reinit_completion(\u0026spi_dev-\u003edone);\n\n    spi_dev-\u003etx_buf = xfer-\u003etx_buf;\n    spi_dev-\u003erx_buf = xfer-\u003erx_buf;\n    spi_dev-\u003elen = xfer-\u003elen;\n\n    // Configure SPI mode\n    if (spi-\u003emode \u0026 SPI_CPOL)\n        ctrl |= SPI_CTRL_CPOL;\n    if (spi-\u003emode \u0026 SPI_CPHA)\n        ctrl |= SPI_CTRL_CPHA;\n\n    // Set clock divider\n    ctrl |= SPI_CTRL_DIV(clk_get_rate(spi_dev-\u003eclk) / xfer-\u003espeed_hz);\n\n    // Set bits per word\n    ctrl |= SPI_CTRL_BPW(xfer-\u003ebits_per_word);\n\n    writel(ctrl, spi_dev-\u003ebase + SPI_CTRL);\n    writel(xfer-\u003elen, spi_dev-\u003ebase + SPI_LEN);\n\n    // Enable TX interrupt and start\n    writel(SPI_INT_TX | SPI_INT_RX, spi_dev-\u003ebase + SPI_INT_EN);\n    writel(SPI_START, spi_dev-\u003ebase + SPI_CMD);\n\n    wait_for_completion(\u0026spi_dev-\u003edone);\n\n    return 0;\n}\n\nstatic void my_spi_set_cs(struct spi_device *spi, bool enable) {\n    struct my_spi *spi_dev = spi_controller_get_devdata(spi-\u003econtroller);\n\n    if (enable)\n        writel(BIT(spi-\u003echip_select), spi_dev-\u003ebase + SPI_CS);\n    else\n        writel(0, spi_dev-\u003ebase + SPI_CS);\n}\n\nstatic irqreturn_t my_spi_isr(int irq, void *dev_id) {\n    struct my_spi *spi_dev = dev_id;\n    u32 status = readl(spi_dev-\u003ebase + SPI_STATUS);\n\n    if (status \u0026 SPI_STATUS_DONE) {\n        // Read received data\n        if (spi_dev-\u003erx_buf) {\n            for (int i = 0; i \u003c spi_dev-\u003elen; i++)\n                spi_dev-\u003erx_buf[i] = readl(spi_dev-\u003ebase + SPI_RX_FIFO);\n        }\n\n        writel(SPI_STATUS_DONE, spi_dev-\u003ebase + SPI_STATUS);\n        complete(\u0026spi_dev-\u003edone);\n    }\n\n    return IRQ_HANDLED;\n}\n\nstatic int my_spi_probe(struct platform_device *pdev) {\n    struct spi_controller *ctlr;\n    struct my_spi *spi_dev;\n\n    ctlr = devm_spi_alloc_master(\u0026pdev-\u003edev, sizeof(*spi_dev));\n    spi_dev = spi_controller_get_devdata(ctlr);\n\n    spi_dev-\u003ebase = devm_platform_ioremap_resource(pdev, 0);\n    spi_dev-\u003eclk = devm_clk_get(\u0026pdev-\u003edev, NULL);\n    clk_prepare_enable(spi_dev-\u003eclk);\n\n    init_completion(\u0026spi_dev-\u003edone);\n\n    ctlr-\u003ebus_num = pdev-\u003eid;\n    ctlr-\u003enum_chipselect = 4;\n    ctlr-\u003emode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\n    ctlr-\u003ebits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\n    ctlr-\u003etransfer_one = my_spi_transfer_one;\n    ctlr-\u003eset_cs = my_spi_set_cs;\n\n    spi_dev-\u003ectlr = ctlr;\n\n    return devm_spi_register_controller(\u0026pdev-\u003edev, ctlr);\n}\n```\n\n## SPI Device Driver\n\n```c\n#include \u003clinux/spi/spi.h\u003e\n\nstruct my_spi_device {\n    struct spi_device *spi;\n    struct mutex lock;\n    u8 tx_buf[64];\n    u8 rx_buf[64];\n};\n\nstatic int my_spi_read_reg(struct my_spi_device *dev, u8 reg, u8 *val) {\n    struct spi_transfer xfer[2];\n    struct spi_message msg;\n\n    memset(xfer, 0, sizeof(xfer));\n    spi_message_init(\u0026msg);\n\n    // Write register address\n    dev-\u003etx_buf[0] = reg | 0x80;  // Read bit\n    xfer[0].tx_buf = dev-\u003etx_buf;\n    xfer[0].len = 1;\n    spi_message_add_tail(\u0026xfer[0], \u0026msg);\n\n    // Read value\n    xfer[1].rx_buf = dev-\u003erx_buf;\n    xfer[1].len = 1;\n    spi_message_add_tail(\u0026xfer[1], \u0026msg);\n\n    if (spi_sync(dev-\u003espi, \u0026msg))\n        return -EIO;\n\n    *val = dev-\u003erx_buf[0];\n    return 0;\n}\n\nstatic int my_spi_write_reg(struct my_spi_device *dev, u8 reg, u8 val) {\n    u8 buf[2] = { reg \u0026 0x7F, val };  // Clear read bit\n\n    return spi_write(dev-\u003espi, buf, 2);\n}\n\n// Using spi_write_then_read for simple transactions\nstatic int my_spi_simple_read(struct spi_device *spi, u8 reg, u8 *val) {\n    u8 cmd = reg | 0x80;\n    return spi_write_then_read(spi, \u0026cmd, 1, val, 1);\n}\n```\n\n## DMA SPI Transfer\n\n```c\nstatic int my_spi_dma_transfer(struct my_spi *spi_dev,\n                                struct spi_transfer *xfer) {\n    struct dma_async_tx_descriptor *tx_desc, *rx_desc;\n    dma_addr_t tx_dma, rx_dma;\n\n    // Map buffers for DMA\n    tx_dma = dma_map_single(spi_dev-\u003edev, (void *)xfer-\u003etx_buf,\n                            xfer-\u003elen, DMA_TO_DEVICE);\n    rx_dma = dma_map_single(spi_dev-\u003edev, xfer-\u003erx_buf,\n                            xfer-\u003elen, DMA_FROM_DEVICE);\n\n    // Prepare DMA descriptors\n    tx_desc = dmaengine_prep_slave_single(spi_dev-\u003etx_chan,\n                                          tx_dma, xfer-\u003elen,\n                                          DMA_MEM_TO_DEV,\n                                          DMA_PREP_INTERRUPT);\n    rx_desc = dmaengine_prep_slave_single(spi_dev-\u003erx_chan,\n                                          rx_dma, xfer-\u003elen,\n                                          DMA_DEV_TO_MEM,\n                                          DMA_PREP_INTERRUPT);\n\n    rx_desc-\u003ecallback = my_spi_dma_callback;\n    rx_desc-\u003ecallback_param = spi_dev;\n\n    // Submit and start\n    dmaengine_submit(tx_desc);\n    dmaengine_submit(rx_desc);\n    dma_async_issue_pending(spi_dev-\u003etx_chan);\n    dma_async_issue_pending(spi_dev-\u003erx_chan);\n\n    return 0;\n}\n```\n"])</script><script>self.__next_f.push([1,"c:Tda1,"])</script><script>self.__next_f.push([1,"\n# Linux Device Driver Development\n\n## Driver Types\n\n### Character Drivers\n```c\n#include \u003clinux/module.h\u003e\n#include \u003clinux/fs.h\u003e\n#include \u003clinux/cdev.h\u003e\n\nstatic struct cdev my_cdev;\nstatic dev_t dev_num;\n\nstatic int my_open(struct inode *inode, struct file *file) {\n    pr_info(\"Device opened\\n\");\n    return 0;\n}\n\nstatic ssize_t my_read(struct file *file, char __user *buf,\n                       size_t count, loff_t *ppos) {\n    // Copy data to user space\n    return copy_to_user(buf, kernel_buf, count) ? -EFAULT : count;\n}\n\nstatic const struct file_operations my_fops = {\n    .owner = THIS_MODULE,\n    .open = my_open,\n    .read = my_read,\n    .write = my_write,\n    .release = my_release,\n};\n```\n\n### Platform Drivers\n```c\nstatic int my_probe(struct platform_device *pdev) {\n    struct resource *res;\n    void __iomem *base;\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    base = devm_ioremap_resource(\u0026pdev-\u003edev, res);\n    if (IS_ERR(base))\n        return PTR_ERR(base);\n\n    return 0;\n}\n\nstatic const struct of_device_id my_of_match[] = {\n    { .compatible = \"vendor,my-device\" },\n    { }\n};\n\nstatic struct platform_driver my_driver = {\n    .probe = my_probe,\n    .remove = my_remove,\n    .driver = {\n        .name = \"my-driver\",\n        .of_match_table = my_of_match,\n    },\n};\nmodule_platform_driver(my_driver);\n```\n\n## Memory Management\n\n### DMA Operations\n```c\n#include \u003clinux/dma-mapping.h\u003e\n\n// Coherent DMA allocation\nvoid *vaddr = dma_alloc_coherent(dev, size, \u0026dma_handle, GFP_KERNEL);\n\n// Streaming DMA mapping\ndma_addr_t dma = dma_map_single(dev, buf, size, DMA_TO_DEVICE);\ndma_sync_single_for_device(dev, dma, size, DMA_TO_DEVICE);\n// After transfer\ndma_unmap_single(dev, dma, size, DMA_TO_DEVICE);\n```\n\n### IOMMU/SMMU Integration\n```c\n// Enable IOMMU for device\nstruct iommu_domain *domain = iommu_domain_alloc(dev-\u003ebus);\niommu_attach_device(domain, dev);\n\n// Map IOVA to physical address\niommu_map(domain, iova, phys, size, IOMMU_READ | IOMMU_WRITE);\n```\n\n## Interrupt Handling\n\n### Threaded IRQs\n```c\nstatic irqreturn_t my_isr(int irq, void *dev_id) {\n    // Quick hardware acknowledgment\n    writel(IRQ_ACK, base + IRQ_STATUS);\n    return IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t my_thread_fn(int irq, void *dev_id) {\n    // Heavy processing in thread context\n    process_data();\n    return IRQ_HANDLED;\n}\n\ndevm_request_threaded_irq(dev, irq, my_isr, my_thread_fn,\n                          IRQF_SHARED, \"my-irq\", priv);\n```\n\n## Power Management\n\n### Runtime PM\n```c\n#include \u003clinux/pm_runtime.h\u003e\n\nstatic int my_runtime_suspend(struct device *dev) {\n    // Disable clocks, power down\n    clk_disable_unprepare(priv-\u003eclk);\n    return 0;\n}\n\nstatic int my_runtime_resume(struct device *dev) {\n    // Enable clocks, power up\n    return clk_prepare_enable(priv-\u003eclk);\n}\n\nstatic const struct dev_pm_ops my_pm_ops = {\n    SET_RUNTIME_PM_OPS(my_runtime_suspend, my_runtime_resume, NULL)\n    SET_SYSTEM_SLEEP_PM_OPS(my_suspend, my_resume)\n};\n\n// In probe\npm_runtime_enable(dev);\npm_runtime_get_sync(dev);\n```\n\n## Debug Techniques\n\n### Dynamic Debug\n```bash\n# Enable debug messages\necho 'module my_driver +p' \u003e /sys/kernel/debug/dynamic_debug/control\n\n# Enable function tracing\necho 'func my_probe +p' \u003e /sys/kernel/debug/dynamic_debug/control\n```\n\n### Ftrace\n```bash\n# Trace specific function\necho my_function \u003e /sys/kernel/debug/tracing/set_ftrace_filter\necho function \u003e /sys/kernel/debug/tracing/current_tracer\necho 1 \u003e /sys/kernel/debug/tracing/tracing_on\n```\n"])</script><script>self.__next_f.push([1,"d:T1296,"])</script><script>self.__next_f.push([1,"\n# Device Tree and ACPI\n\n## Device Tree Basics\n\n### DTS Structure\n```dts\n/ {\n    compatible = \"vendor,board-name\";\n    #address-cells = \u003c2\u003e;\n    #size-cells = \u003c2\u003e;\n\n    cpus {\n        #address-cells = \u003c1\u003e;\n        #size-cells = \u003c0\u003e;\n\n        cpu@0 {\n            compatible = \"arm,cortex-a72\";\n            device_type = \"cpu\";\n            reg = \u003c0\u003e;\n            enable-method = \"psci\";\n        };\n    };\n\n    soc {\n        compatible = \"simple-bus\";\n        #address-cells = \u003c2\u003e;\n        #size-cells = \u003c2\u003e;\n        ranges;\n\n        ipu: ipu@ff000000 {\n            compatible = \"vendor,ipu-v2\";\n            reg = \u003c0x0 0xff000000 0x0 0x100000\u003e;\n            interrupts = \u003cGIC_SPI 45 IRQ_TYPE_LEVEL_HIGH\u003e;\n            clocks = \u003c\u0026cru CLK_IPU\u003e;\n            clock-names = \"ipu_clk\";\n            power-domains = \u003c\u0026power IPU_PD\u003e;\n            iommus = \u003c\u0026iommu IPU_MMU\u003e;\n            status = \"okay\";\n        };\n    };\n};\n```\n\n### Camera Sensor Binding\n```dts\n\u0026i2c2 {\n    status = \"okay\";\n\n    imx219: sensor@10 {\n        compatible = \"sony,imx219\";\n        reg = \u003c0x10\u003e;\n        clocks = \u003c\u0026cru CLK_CAM_MCLK\u003e;\n        clock-names = \"xclk\";\n        clock-frequency = \u003c24000000\u003e;\n\n        reset-gpios = \u003c\u0026gpio1 RK_PA4 GPIO_ACTIVE_LOW\u003e;\n        powerdown-gpios = \u003c\u0026gpio1 RK_PA5 GPIO_ACTIVE_HIGH\u003e;\n\n        VANA-supply = \u003c\u0026cam_avdd_2v8\u003e;\n        VDIG-supply = \u003c\u0026cam_dvdd_1v2\u003e;\n        VDDL-supply = \u003c\u0026cam_dovdd_1v8\u003e;\n\n        port {\n            imx219_out: endpoint {\n                remote-endpoint = \u003c\u0026csi_in\u003e;\n                data-lanes = \u003c1 2\u003e;\n                clock-noncontinuous;\n                link-frequencies = /bits/ 64 \u003c456000000\u003e;\n            };\n        };\n    };\n};\n\n\u0026csi {\n    status = \"okay\";\n\n    ports {\n        port@0 {\n            csi_in: endpoint {\n                remote-endpoint = \u003c\u0026imx219_out\u003e;\n                data-lanes = \u003c1 2\u003e;\n            };\n        };\n    };\n};\n```\n\n### Parsing in Driver\n```c\nstatic int my_probe(struct platform_device *pdev) {\n    struct device *dev = \u0026pdev-\u003edev;\n    struct device_node *np = dev-\u003eof_node;\n    u32 val;\n    const char *name;\n\n    // Read property\n    if (of_property_read_u32(np, \"clock-frequency\", \u0026val))\n        val = 24000000; // default\n\n    // Read string\n    of_property_read_string(np, \"clock-names\", \u0026name);\n\n    // Get GPIO\n    priv-\u003ereset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\n    // Get regulator\n    priv-\u003evdd = devm_regulator_get(dev, \"VDIG\");\n\n    // Get clock\n    priv-\u003eclk = devm_clk_get(dev, \"xclk\");\n\n    // Parse endpoint\n    struct fwnode_handle *ep = fwnode_graph_get_next_endpoint(\n        dev_fwnode(dev), NULL);\n\n    return 0;\n}\n```\n\n## ACPI Integration\n\n### ACPI Device Matching\n```c\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id my_acpi_match[] = {\n    { \"INTC1234\", 0 },\n    { \"INTC5678\", 1 },\n    { }\n};\nMODULE_DEVICE_TABLE(acpi, my_acpi_match);\n#endif\n\nstatic struct platform_driver my_driver = {\n    .driver = {\n        .name = \"my-device\",\n        .of_match_table = my_of_match,\n        .acpi_match_table = ACPI_PTR(my_acpi_match),\n    },\n};\n```\n\n### Reading ACPI Properties\n```c\nstatic int my_acpi_probe(struct platform_device *pdev) {\n    struct acpi_device *adev = ACPI_COMPANION(\u0026pdev-\u003edev);\n    u64 val;\n\n    // Read _DSD property\n    if (!acpi_dev_get_property(adev, \"clock-frequency\",\n                               ACPI_TYPE_INTEGER, \u0026val)) {\n        priv-\u003eclk_freq = val;\n    }\n\n    // Read GPIO from _CRS\n    struct gpio_desc *gpio = devm_gpiod_get(\u0026pdev-\u003edev, \"reset\",\n                                            GPIOD_OUT_LOW);\n\n    return 0;\n}\n```\n\n### ACPI ASL Example\n```asl\nDevice (IPU0)\n{\n    Name (_HID, \"INTC1234\")\n    Name (_UID, 0)\n\n    Name (_CRS, ResourceTemplate () {\n        Memory32Fixed (ReadWrite, 0xFF000000, 0x100000)\n        Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { 45 }\n        GpioIo (Exclusive, PullDefault, 0, 0, IoRestrictionNone,\n                \"\\\\_SB.GPO1\") { 4 }\n    })\n\n    Name (_DSD, Package () {\n        ToUUID(\"daffd814-6eba-4d8c-8a91-bc9bbf4aa301\"),\n        Package () {\n            Package () { \"clock-frequency\", 400000000 },\n            Package () { \"power-domains\", Package () { \"\\\\_SB.PD01\" } },\n        }\n    })\n\n    Method (_STA, 0, NotSerialized) {\n        Return (0x0F)\n    }\n}\n```\n\n## Overlay Support\n\n### Runtime Overlay\n```dts\n/dts-v1/;\n/plugin/;\n\n\u0026i2c2 {\n    #address-cells = \u003c1\u003e;\n    #size-cells = \u003c0\u003e;\n\n    ov5640: camera@3c {\n        compatible = \"ovti,ov5640\";\n        reg = \u003c0x3c\u003e;\n        status = \"okay\";\n    };\n};\n```\n\n### Loading Overlay\n```bash\n# Compile overlay\ndtc -I dts -O dtb -o overlay.dtbo overlay.dts\n\n# Apply at runtime (if supported)\nmkdir /sys/kernel/config/device-tree/overlays/cam\ncat overlay.dtbo \u003e /sys/kernel/config/device-tree/overlays/cam/dtbo\n```\n"])</script><script>self.__next_f.push([1,"e:T1118,"])</script><script>self.__next_f.push([1,"\n# V4L2 Camera Subsystem\n\n## V4L2 Architecture\n\n```\n+------------------+\n|   User Space     |\n|  (v4l2-ctl, GS)  |\n+--------+---------+\n         |\n+--------v---------+\n|   V4L2 Core      |\n|  videobuf2       |\n+--------+---------+\n         |\n+--------v---------+\n|  Subdev Driver   |\n|  (sensor, ISP)   |\n+--------+---------+\n         |\n+--------v---------+\n|  Hardware        |\n|  (MIPI, IPU)     |\n+------------------+\n```\n\n## Video Device Registration\n\n```c\n#include \u003cmedia/v4l2-device.h\u003e\n#include \u003cmedia/v4l2-ioctl.h\u003e\n#include \u003cmedia/videobuf2-dma-contig.h\u003e\n\nstruct my_camera {\n    struct v4l2_device v4l2_dev;\n    struct video_device vdev;\n    struct vb2_queue queue;\n    struct mutex lock;\n};\n\nstatic const struct v4l2_ioctl_ops my_ioctl_ops = {\n    .vidioc_querycap = my_querycap,\n    .vidioc_enum_fmt_vid_cap = my_enum_fmt,\n    .vidioc_g_fmt_vid_cap = my_g_fmt,\n    .vidioc_s_fmt_vid_cap = my_s_fmt,\n    .vidioc_reqbufs = vb2_ioctl_reqbufs,\n    .vidioc_querybuf = vb2_ioctl_querybuf,\n    .vidioc_qbuf = vb2_ioctl_qbuf,\n    .vidioc_dqbuf = vb2_ioctl_dqbuf,\n    .vidioc_streamon = vb2_ioctl_streamon,\n    .vidioc_streamoff = vb2_ioctl_streamoff,\n};\n\nstatic const struct v4l2_file_operations my_fops = {\n    .owner = THIS_MODULE,\n    .open = v4l2_fh_open,\n    .release = vb2_fop_release,\n    .poll = vb2_fop_poll,\n    .mmap = vb2_fop_mmap,\n    .unlocked_ioctl = video_ioctl2,\n};\n```\n\n## Videobuf2 Queue Setup\n\n```c\nstatic const struct vb2_ops my_vb2_ops = {\n    .queue_setup = my_queue_setup,\n    .buf_prepare = my_buf_prepare,\n    .buf_queue = my_buf_queue,\n    .start_streaming = my_start_streaming,\n    .stop_streaming = my_stop_streaming,\n    .wait_prepare = vb2_ops_wait_prepare,\n    .wait_finish = vb2_ops_wait_finish,\n};\n\nstatic int my_queue_setup(struct vb2_queue *q,\n                          unsigned int *nbuffers,\n                          unsigned int *nplanes,\n                          unsigned int sizes[],\n                          struct device *alloc_devs[]) {\n    *nplanes = 1;\n    sizes[0] = cam-\u003eformat.sizeimage;\n    return 0;\n}\n\nstatic void my_buf_queue(struct vb2_buffer *vb) {\n    struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n    struct my_buffer *buf = container_of(vbuf, struct my_buffer, vb);\n\n    spin_lock(\u0026cam-\u003elock);\n    list_add_tail(\u0026buf-\u003elist, \u0026cam-\u003epending);\n    spin_unlock(\u0026cam-\u003elock);\n}\n```\n\n## Subdevice Driver (Sensor)\n\n```c\n#include \u003cmedia/v4l2-subdev.h\u003e\n#include \u003cmedia/v4l2-ctrls.h\u003e\n\nstatic int sensor_s_stream(struct v4l2_subdev *sd, int enable) {\n    struct sensor_dev *sensor = to_sensor(sd);\n\n    if (enable) {\n        // Configure sensor registers\n        sensor_write(sensor, REG_MODE, MODE_STREAMING);\n    } else {\n        sensor_write(sensor, REG_MODE, MODE_STANDBY);\n    }\n    return 0;\n}\n\nstatic const struct v4l2_subdev_video_ops sensor_video_ops = {\n    .s_stream = sensor_s_stream,\n};\n\nstatic const struct v4l2_subdev_pad_ops sensor_pad_ops = {\n    .enum_mbus_code = sensor_enum_mbus_code,\n    .get_fmt = sensor_get_fmt,\n    .set_fmt = sensor_set_fmt,\n};\n\nstatic const struct v4l2_subdev_ops sensor_ops = {\n    .video = \u0026sensor_video_ops,\n    .pad = \u0026sensor_pad_ops,\n};\n```\n\n## MIPI CSI-2 Receiver\n\n```c\n// MIPI CSI-2 data types\n#define MIPI_CSI2_DT_RAW8       0x2A\n#define MIPI_CSI2_DT_RAW10      0x2B\n#define MIPI_CSI2_DT_RAW12      0x2C\n#define MIPI_CSI2_DT_YUV422_8   0x1E\n\nstatic int csi2_configure(struct csi2_dev *csi,\n                          struct v4l2_mbus_config *cfg) {\n    u32 lanes = cfg-\u003ebus.mipi_csi2.num_data_lanes;\n\n    // Configure number of lanes\n    writel(lanes, csi-\u003ebase + CSI2_N_LANES);\n\n    // Configure data type\n    writel(MIPI_CSI2_DT_RAW10, csi-\u003ebase + CSI2_DATA_TYPE);\n\n    // Enable CSI-2 receiver\n    writel(CSI2_ENABLE, csi-\u003ebase + CSI2_CTRL);\n\n    return 0;\n}\n```\n\n## Media Controller\n\n```c\n#include \u003cmedia/media-device.h\u003e\n#include \u003cmedia/media-entity.h\u003e\n\n// Create media device\nmedia_device_init(\u0026cam-\u003emdev);\ncam-\u003emdev.dev = \u0026pdev-\u003edev;\nstrscpy(cam-\u003emdev.model, \"My Camera\", sizeof(cam-\u003emdev.model));\n\n// Register entities and create links\nmedia_device_register_entity(\u0026cam-\u003emdev, \u0026sensor-\u003eentity);\nmedia_device_register_entity(\u0026cam-\u003emdev, \u0026csi-\u003eentity);\nmedia_device_register_entity(\u0026cam-\u003emdev, \u0026isp-\u003eentity);\n\n// Create pad links\nmedia_create_pad_link(\u0026sensor-\u003eentity, 0, \u0026csi-\u003eentity, 0,\n                      MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n```\n"])</script><script>self.__next_f.push([1,"f:T2552,"])</script><script>self.__next_f.push([1,"\n# First Silicon Bring-up\n\n## Bring-up Phases\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    Silicon Bring-up Timeline                    │\n│                                                                  │\n│  Phase 0        Phase 1        Phase 2        Phase 3           │\n│  ATE Test       Basic Boot     OS Boot        Full Validation   │\n│     │              │              │              │               │\n│     ▼              ▼              ▼              ▼               │\n│ ┌───────┐     ┌───────┐     ┌───────┐     ┌───────┐           │\n│ │ Scan  │────►│ Boot  │────►│ Linux │────►│ Apps  │           │\n│ │ BIST  │     │ ROM   │     │ Boot  │     │ Tests │           │\n│ │ PLL   │     │ JTAG  │     │ Driver│     │ Perf  │           │\n│ └───────┘     └───────┘     └───────┘     └───────┘           │\n│                                                                  │\n│  Week 1        Week 1-2       Week 2-4       Week 4+            │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Phase 0: Initial Power-On\n\n### Power Sequencing Check\n```c\n/* Voltage rail bring-up verification */\nstruct power_rail {\n    const char *name;\n    float nominal_v;\n    float tolerance;\n    int gpio_enable;\n    int adc_channel;\n};\n\nstatic struct power_rail rails[] = {\n    {\"VDD_CORE\",  0.8,  0.05, GPIO_CORE_EN,  ADC_CH0},\n    {\"VDD_IO\",    1.8,  0.10, GPIO_IO_EN,    ADC_CH1},\n    {\"VDD_DDR\",   1.1,  0.05, GPIO_DDR_EN,   ADC_CH2},\n    {\"VDD_PLL\",   0.8,  0.05, GPIO_PLL_EN,   ADC_CH3},\n};\n\nint verify_power_rails(void) {\n    float measured;\n\n    for (int i = 0; i \u003c ARRAY_SIZE(rails); i++) {\n        /* Enable rail */\n        gpio_set(rails[i].gpio_enable, 1);\n        mdelay(10);\n\n        /* Measure voltage */\n        measured = adc_read_voltage(rails[i].adc_channel);\n\n        /* Verify within tolerance */\n        if (fabs(measured - rails[i].nominal_v) \u003e rails[i].tolerance) {\n            printf(\"FAIL: %s: expected %.2fV, measured %.2fV\\n\",\n                   rails[i].name, rails[i].nominal_v, measured);\n            return -1;\n        }\n\n        printf(\"PASS: %s: %.2fV\\n\", rails[i].name, measured);\n    }\n\n    return 0;\n}\n```\n\n### PLL Lock Verification\n```c\n/* Verify all PLLs lock successfully */\nstruct pll_config {\n    const char *name;\n    void __iomem *base;\n    u32 target_freq_mhz;\n};\n\nint verify_pll_lock(struct pll_config *pll) {\n    u32 status;\n    int timeout = 1000;\n\n    /* Check lock bit */\n    while (timeout--) {\n        status = readl(pll-\u003ebase + PLL_STATUS);\n        if (status \u0026 PLL_LOCKED)\n            break;\n        udelay(10);\n    }\n\n    if (!(status \u0026 PLL_LOCKED)) {\n        printf(\"FAIL: %s PLL failed to lock\\n\", pll-\u003ename);\n        return -1;\n    }\n\n    /* Measure frequency via counter */\n    u32 measured = measure_clock_freq(pll-\u003ebase);\n    u32 expected = pll-\u003etarget_freq_mhz * 1000000;\n\n    if (abs(measured - expected) \u003e (expected / 100)) {\n        printf(\"FAIL: %s freq mismatch: expected %u, got %u\\n\",\n               pll-\u003ename, expected, measured);\n        return -1;\n    }\n\n    printf(\"PASS: %s locked at %u MHz\\n\", pll-\u003ename, measured / 1000000);\n    return 0;\n}\n```\n\n## Phase 1: JTAG and Basic Access\n\n### JTAG Chain Verification\n```bash\n# Verify JTAG connectivity\nopenocd -f interface/jlink.cfg -c \"\n    transport select jtag\n    adapter speed 1000\n    jtag newtap chip cpu -irlen 4 -expected-id 0x4BA00477\n    init\n    scan_chain\n    exit\n\"\n```\n\n### First Memory Access\n```c\n/* SRAM read/write test */\nint sram_test(void __iomem *base, size_t size) {\n    u32 pattern[] = {0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};\n    int errors = 0;\n\n    printf(\"Testing SRAM at %p, size %zu\\n\", base, size);\n\n    for (int p = 0; p \u003c ARRAY_SIZE(pattern); p++) {\n        /* Write pattern */\n        for (size_t i = 0; i \u003c size; i += 4) {\n            writel(pattern[p], base + i);\n        }\n\n        /* Verify pattern */\n        for (size_t i = 0; i \u003c size; i += 4) {\n            u32 val = readl(base + i);\n            if (val != pattern[p]) {\n                printf(\"FAIL at 0x%zx: wrote 0x%08x, read 0x%08x\\n\",\n                       i, pattern[p], val);\n                errors++;\n            }\n        }\n    }\n\n    /* Address uniqueness test */\n    for (size_t i = 0; i \u003c size; i += 4) {\n        writel(i, base + i);\n    }\n    for (size_t i = 0; i \u003c size; i += 4) {\n        u32 val = readl(base + i);\n        if (val != i) {\n            printf(\"FAIL address test at 0x%zx\\n\", i);\n            errors++;\n        }\n    }\n\n    return errors;\n}\n```\n\n### Boot ROM Execution\n```c\n/* Minimal boot ROM code */\n.section .text.boot\n.global _start\n\n_start:\n    /* Disable interrupts */\n    msr daifset, #0xf\n\n    /* Set up stack */\n    ldr x0, =__stack_top\n    mov sp, x0\n\n    /* Clear BSS */\n    ldr x0, =__bss_start\n    ldr x1, =__bss_end\n1:  cmp x0, x1\n    b.ge 2f\n    str xzr, [x0], #8\n    b 1b\n2:\n    /* Initialize UART for debug */\n    bl uart_init\n\n    /* Print sign-of-life */\n    ldr x0, =boot_msg\n    bl uart_puts\n\n    /* Continue to main */\n    bl main\n\n    /* Should not return */\n    b .\n\nboot_msg:\n    .asciz \"Boot ROM started\\r\\n\"\n```\n\n## Phase 2: DDR Initialization\n\n```c\n/* DDR PHY training sequence */\nstruct ddr_training_result {\n    int write_leveling_pass;\n    int read_gate_pass;\n    int read_dqs_pass;\n    int write_dq_pass;\n    u8 delays[4][8];  /* Per-byte delay values */\n};\n\nint ddr_training(void __iomem *phy_base, struct ddr_training_result *result) {\n    u32 status;\n\n    /* Step 1: Write Leveling */\n    writel(PHY_WL_START, phy_base + PHY_TRAINING_CTRL);\n    status = wait_for_training_done(phy_base);\n    result-\u003ewrite_leveling_pass = (status \u0026 PHY_WL_PASS);\n\n    if (!result-\u003ewrite_leveling_pass) {\n        printf(\"Write leveling failed: 0x%08x\\n\", status);\n        return -1;\n    }\n\n    /* Step 2: Read Gate Training */\n    writel(PHY_RG_START, phy_base + PHY_TRAINING_CTRL);\n    status = wait_for_training_done(phy_base);\n    result-\u003eread_gate_pass = (status \u0026 PHY_RG_PASS);\n\n    /* Step 3: Read DQS Training */\n    writel(PHY_RD_START, phy_base + PHY_TRAINING_CTRL);\n    status = wait_for_training_done(phy_base);\n    result-\u003eread_dqs_pass = (status \u0026 PHY_RD_PASS);\n\n    /* Step 4: Write DQ Training */\n    writel(PHY_WD_START, phy_base + PHY_TRAINING_CTRL);\n    status = wait_for_training_done(phy_base);\n    result-\u003ewrite_dq_pass = (status \u0026 PHY_WD_PASS);\n\n    /* Save delay values for debug */\n    for (int byte = 0; byte \u003c 4; byte++) {\n        for (int bit = 0; bit \u003c 8; bit++) {\n            result-\u003edelays[byte][bit] =\n                readl(phy_base + PHY_DQ_DELAY(byte, bit));\n        }\n    }\n\n    printf(\"DDR training complete: WL=%d RG=%d RD=%d WD=%d\\n\",\n           result-\u003ewrite_leveling_pass, result-\u003eread_gate_pass,\n           result-\u003eread_dqs_pass, result-\u003ewrite_dq_pass);\n\n    return 0;\n}\n```\n\n## Phase 3: Peripheral Validation\n\n### I2C PMIC Communication\n```c\nint validate_pmic(void) {\n    u8 chip_id, revision;\n\n    /* Read PMIC identification */\n    i2c_read_reg(PMIC_ADDR, PMIC_ID_REG, \u0026chip_id);\n    i2c_read_reg(PMIC_ADDR, PMIC_REV_REG, \u0026revision);\n\n    printf(\"PMIC: ID=0x%02x Rev=0x%02x\\n\", chip_id, revision);\n\n    if (chip_id != EXPECTED_PMIC_ID) {\n        printf(\"FAIL: Wrong PMIC ID\\n\");\n        return -1;\n    }\n\n    /* Configure voltage regulators */\n    i2c_write_reg(PMIC_ADDR, BUCK1_VOUT, VCORE_850MV);\n    i2c_write_reg(PMIC_ADDR, BUCK2_VOUT, VIO_1800MV);\n\n    return 0;\n}\n```\n\n### Clock Tree Verification\n```c\nvoid dump_clock_tree(void) {\n    struct clk_node {\n        const char *name;\n        u32 reg;\n        u32 parent_mask;\n        u32 div_mask;\n    };\n\n    static struct clk_node clocks[] = {\n        {\"CPU_CLK\",  0x100, 0x03, 0x1F},\n        {\"BUS_CLK\",  0x104, 0x03, 0x0F},\n        {\"DDR_CLK\",  0x108, 0x03, 0x07},\n        {\"GPU_CLK\",  0x10C, 0x03, 0x0F},\n        {\"IPU_CLK\",  0x110, 0x03, 0x0F},\n    };\n\n    printf(\"Clock Tree Status:\\n\");\n    for (int i = 0; i \u003c ARRAY_SIZE(clocks); i++) {\n        u32 val = readl(clk_base + clocks[i].reg);\n        u32 parent = val \u0026 clocks[i].parent_mask;\n        u32 div = (val \u003e\u003e 8) \u0026 clocks[i].div_mask;\n\n        printf(\"  %s: parent=%d div=%d\\n\",\n               clocks[i].name, parent, div + 1);\n    }\n}\n```\n\n## Debug Checklist\n\n```markdown\n## First Power-On Checklist\n\n- [ ] Verify power rail sequencing with scope\n- [ ] Measure all voltage rails\n- [ ] Check current consumption (should be minimal before clocks)\n- [ ] Verify reset signals with scope\n- [ ] Check crystal oscillator output\n\n## JTAG Bring-up Checklist\n\n- [ ] JTAG chain detected correctly\n- [ ] Can halt CPU cores\n- [ ] Can read CPU registers\n- [ ] Can access memory-mapped registers\n- [ ] Boot ROM code executes\n\n## Clock Checklist\n\n- [ ] All PLLs lock\n- [ ] Clock frequencies within spec\n- [ ] Clock gating works correctly\n- [ ] Dynamic frequency scaling works\n\n## Memory Checklist\n\n- [ ] SRAM read/write passes\n- [ ] DDR training completes\n- [ ] DDR stress test passes\n- [ ] ECC functional (if enabled)\n```\n"])</script><script>self.__next_f.push([1,"10:T22ea,"])</script><script>self.__next_f.push([1,"\n# HAPS FPGA Prototyping\n\n## HAPS System Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    HAPS-80 System                                │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │                  HAPS-80 Motherboard                     │   │\n│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │   │\n│  │  │ FPGA 1  │  │ FPGA 2  │  │ FPGA 3  │  │ FPGA 4  │    │   │\n│  │  │(Xilinx  │  │(Xilinx  │  │(Xilinx  │  │(Xilinx  │    │   │\n│  │  │VU440)   │  │VU440)   │  │VU440)   │  │VU440)   │    │   │\n│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │   │\n│  │       └─────┬──────┴─────┬──────┴─────┬──────┘         │   │\n│  │             │   HapsTrak Connectors   │                │   │\n│  └─────────────┼─────────────────────────┼─────────────────┘   │\n│                │                         │                      │\n│  ┌─────────────▼─────────────────────────▼─────────────────┐   │\n│  │              Daughter Cards / Interfaces                 │   │\n│  │  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐            │   │\n│  │  │ DDR4  │  │ MIPI  │  │ PCIe  │  │ USB   │            │   │\n│  │  └───────┘  └───────┘  └───────┘  └───────┘            │   │\n│  └─────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## ProtoCompiler Flow\n\n```\nRTL Design\n    │\n    ▼\n┌────────────────┐\n│ ProtoCompiler  │\n│  ┌───────────┐ │\n│  │ Partition │ │  ← Splits design across FPGAs\n│  └─────┬─────┘ │\n│        │       │\n│  ┌─────▼─────┐ │\n│  │  Optimize │ │  ← Multi-FPGA timing closure\n│  └─────┬─────┘ │\n│        │       │\n│  ┌─────▼─────┐ │\n│  │  Compile  │ │  ← Xilinx Vivado synthesis\n│  └───────────┘ │\n└────────┬───────┘\n         │\n         ▼\n   Bitstreams\n```\n\n### ProtoCompiler Commands\n```bash\n# Create new project\nprotocompiler new_project mydesign\n\n# Add RTL files\nprotocompiler add_files mydesign -verilog design.v\nprotocompiler add_files mydesign -sv pkg.sv top.sv\nprotocompiler add_files mydesign -vhdl wrapper.vhd\n\n# Set top module\nprotocompiler set_top mydesign top_module\n\n# Configure target\nprotocompiler set_device mydesign haps80_s104_4\n\n# Run partitioning\nprotocompiler partition mydesign\n\n# Compile\nprotocompiler compile mydesign -j 16\n```\n\n## UMR (Unified Memory Region)\n\n```c\n/* UMR provides memory-mapped access to FPGA design */\n#include \"umr_api.h\"\n\nint main() {\n    umr_handle_t handle;\n    uint32_t data;\n\n    /* Open UMR connection */\n    umr_open(\u0026handle, \"HAPS80_S104\");\n\n    /* Memory-mapped register access */\n    umr_read32(handle, 0x00000000, \u0026data);  /* Base address */\n    printf(\"ID Register: 0x%08x\\n\", data);\n\n    /* Write to register */\n    umr_write32(handle, 0x00000004, 0x12345678);\n\n    /* Burst read */\n    uint32_t buffer[256];\n    umr_read_burst(handle, 0x00001000, buffer, 256);\n\n    /* Close connection */\n    umr_close(handle);\n\n    return 0;\n}\n```\n\n## Clock Configuration\n\n```\n┌──────────────────────────────────────────────────────────────┐\n│                  HAPS Clock Architecture                      │\n│                                                               │\n│  External Clock ──► PLL ──┬──► Design Clock (10-200 MHz)    │\n│                           │                                   │\n│                           ├──► DDR Clock                      │\n│                           │                                   │\n│                           └──► I/O Clock                      │\n│                                                               │\n│  Note: FPGA timing typically 10-20x slower than ASIC         │\n└──────────────────────────────────────────────────────────────┘\n```\n\n### Clock Commands\n```bash\n# Set main clock frequency\nhaps clock set CLK_MAIN 25.0\n\n# Set multiple clocks\nhaps clock set CLK_CPU 20.0 CLK_BUS 10.0 CLK_DDR 50.0\n\n# Read current settings\nhaps clock get all\n\n# Dynamic frequency scaling\nhaps clock scale CLK_MAIN 0.5  # Half speed\n```\n\n## Debug Techniques\n\n### Signal Probing with ChipScope\n```tcl\n# Vivado ILA insertion (in constraints)\ncreate_debug_core u_ila_0 ila\nset_property C_DATA_DEPTH 8192 [get_debug_cores u_ila_0]\nset_property C_TRIGIN_EN false [get_debug_cores u_ila_0]\nset_property C_INPUT_PIPE_STAGES 2 [get_debug_cores u_ila_0]\n\n# Connect signals to probe\nconnect_debug_port u_ila_0/probe0 [get_nets {cpu_data[*]}]\nconnect_debug_port u_ila_0/probe1 [get_nets {cpu_addr[*]}]\nconnect_debug_port u_ila_0/probe2 [get_nets cpu_valid]\n```\n\n### Embedded Logic Analyzer\n```bash\n# Start Vivado hardware manager\nvivado -mode tcl\n\n# Connect to JTAG\nopen_hw_manager\nconnect_hw_server\nopen_hw_target\n\n# Configure ILA\nset_property CONTROL.DATA_DEPTH 8192 [get_hw_ilas hw_ila_1]\nset_property CONTROL.TRIGGER_POSITION 4096 [get_hw_ilas hw_ila_1]\n\n# Set trigger\nset_property COMPARE_VALUE eq1'b1 [get_hw_probes cpu_valid]\nrun_hw_ila [get_hw_ilas hw_ila_1]\n\n# Export waveform\nwrite_hw_ila_data -csv_file capture.csv [upload_hw_ila_data hw_ila_1]\n```\n\n## Multi-FPGA Considerations\n\n### Time Domain Crossing\n```verilog\n// Signals crossing FPGA boundaries need special handling\n// ProtoCompiler inserts TDM (Time Division Multiplexing) bridges\n\n// Design requirement: avoid combinational paths across FPGAs\n// All cross-FPGA signals should be registered\n\nmodule cross_fpga_interface (\n    input  wire        clk,\n    input  wire        rst_n,\n    // To/from other FPGA\n    input  wire [31:0] data_in,\n    output reg  [31:0] data_out,\n    input  wire        valid_in,\n    output reg         valid_out\n);\n\n    // Double-register for metastability\n    reg [31:0] data_sync1, data_sync2;\n    reg        valid_sync1, valid_sync2;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_sync1  \u003c= 32'b0;\n            data_sync2  \u003c= 32'b0;\n            valid_sync1 \u003c= 1'b0;\n            valid_sync2 \u003c= 1'b0;\n        end else begin\n            data_sync1  \u003c= data_in;\n            data_sync2  \u003c= data_sync1;\n            valid_sync1 \u003c= valid_in;\n            valid_sync2 \u003c= valid_sync1;\n        end\n    end\n\n    // Use synchronized signals\n    assign rx_data  = data_sync2;\n    assign rx_valid = valid_sync2;\n\nendmodule\n```\n\n## Software Bring-up on HAPS\n\n```bash\n# Load FPGA bitstream\nhaps program all mydesign.bit\n\n# Reset the design\nhaps reset assert\nsleep 1\nhaps reset deassert\n\n# Load software\nhaps load_elf program.elf 0x80000000\n\n# Start execution\nhaps cpu run\n\n# Connect GDB\narm-none-eabi-gdb program.elf\n(gdb) target remote :3333\n```\n\n## Performance Considerations\n\n| Aspect | ASIC Target | HAPS FPGA |\n|--------|-------------|-----------|\n| Clock Frequency | 1 GHz | 25-50 MHz |\n| DDR Speed | 4266 MT/s | 1600 MT/s |\n| Real-time Ratio | 1x | 20-40x slower |\n\n### Optimization Tips\n- Use multi-FPGA partitioning wisely\n- Minimize cross-FPGA signal count\n- Use dedicated I/O daughter cards for high-speed interfaces\n- Enable deep pipeline insertion for timing closure\n"])</script><script>self.__next_f.push([1,"11:T2e68,"])</script><script>self.__next_f.push([1,"\n# Palladium Emulation\n\n## Emulation System Overview\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    Palladium Z2 System                           │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │                   Compute Cluster                        │   │\n│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │   │\n│  │  │Processor│  │Processor│  │Processor│  │Processor│    │   │\n│  │  │ Domain  │  │ Domain  │  │ Domain  │  │ Domain  │    │   │\n│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │   │\n│  │       └─────┬──────┴─────┬──────┴─────┬──────┘         │   │\n│  │             │      High-Speed Fabric  │                │   │\n│  └─────────────┼─────────────────────────┼─────────────────┘   │\n│                │                         │                      │\n│  ┌─────────────▼─────────────────────────▼─────────────────┐   │\n│  │                    I/O Infrastructure                    │   │\n│  │  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐            │   │\n│  │  │SpeedBr│  │  DDR  │  │ PCIe  │  │ USB   │            │   │\n│  │  │  idge │  │ Model │  │ Model │  │ Model │            │   │\n│  │  └───────┘  └───────┘  └───────┘  └───────┘            │   │\n│  └─────────────────────────────────────────────────────────┘   │\n│                            │                                    │\n│                    ┌───────▼───────┐                           │\n│                    │   Host Server │                           │\n│                    │   (Software)  │                           │\n│                    └───────────────┘                           │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Compilation Flow\n\n```\n         RTL + Testbench\n              │\n              ▼\n    ┌────────────────────┐\n    │     xeCompile      │ ← RTL elaboration\n    └─────────┬──────────┘\n              │\n              ▼\n    ┌────────────────────┐\n    │     xeBuild        │ ← Database generation\n    └─────────┬──────────┘\n              │\n              ▼\n    ┌────────────────────┐\n    │     xeLoad         │ ← Load to emulator\n    └─────────┬──────────┘\n              │\n              ▼\n    ┌────────────────────┐\n    │     xeRun          │ ← Execute design\n    └────────────────────┘\n```\n\n### Compilation Commands\n```bash\n# Analyze RTL\nxeCompile -top top_module \\\n    -f rtl_files.f \\\n    -sv_lib uvm \\\n    -timescale 1ns/1ps\n\n# Build database\nxeBuild -design my_design \\\n    -target palladium_z2 \\\n    -partition_count 4\n\n# Load to emulator\nxeLoad -design my_design \\\n    -session my_session\n\n# Run simulation\nxeRun -cycles 1000000\n```\n\n## SpeedBridge Integration\n\n### Host-Emulator Communication\n```c\n/* SpeedBridge provides high-speed co-emulation */\n#include \"speedbridge.h\"\n\ntypedef struct {\n    uint32_t addr;\n    uint32_t data;\n    uint8_t  wr_en;\n} axi_txn_t;\n\n/* Callback when emulator sends transaction */\nvoid emulator_callback(void *context, sb_packet_t *pkt) {\n    axi_txn_t *txn = (axi_txn_t *)pkt-\u003edata;\n\n    if (txn-\u003ewr_en) {\n        /* Handle write from emulator */\n        memory_write(txn-\u003eaddr, txn-\u003edata);\n    } else {\n        /* Handle read, send response */\n        uint32_t rdata = memory_read(txn-\u003eaddr);\n        sb_packet_t resp;\n        resp.data = \u0026rdata;\n        resp.size = sizeof(rdata);\n        sb_send(context, \u0026resp);\n    }\n}\n\nint main() {\n    sb_handle_t handle;\n\n    /* Initialize SpeedBridge */\n    sb_init(\u0026handle, \"my_session\");\n    sb_register_callback(handle, emulator_callback, NULL);\n\n    /* Start emulation */\n    sb_run(handle);\n\n    /* Cleanup */\n    sb_close(handle);\n    return 0;\n}\n```\n\n## Transactor-Based Verification\n\n```verilog\n// SystemVerilog transactor for AXI\nmodule axi_transactor (\n    input  wire        clk,\n    input  wire        rst_n,\n    // AXI interface to DUT\n    output reg  [31:0] awaddr,\n    output reg  [7:0]  awlen,\n    output reg         awvalid,\n    input  wire        awready,\n    output reg  [31:0] wdata,\n    output reg         wlast,\n    output reg         wvalid,\n    input  wire        wready,\n    input  wire [1:0]  bresp,\n    input  wire        bvalid,\n    output reg         bready\n);\n\n    // Import DPI functions\n    import \"DPI-C\" function int get_next_transaction(\n        output int addr, output int data, output int len);\n    import \"DPI-C\" function void report_completion(\n        input int addr, input int resp);\n\n    // State machine\n    typedef enum {IDLE, ADDR, DATA, RESP} state_t;\n    state_t state;\n\n    int txn_addr, txn_data, txn_len;\n    int beat_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state \u003c= IDLE;\n            awvalid \u003c= 0;\n            wvalid \u003c= 0;\n            bready \u003c= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (get_next_transaction(txn_addr, txn_data, txn_len)) begin\n                        awaddr \u003c= txn_addr;\n                        awlen \u003c= txn_len - 1;\n                        awvalid \u003c= 1;\n                        state \u003c= ADDR;\n                    end\n                end\n                ADDR: begin\n                    if (awready) begin\n                        awvalid \u003c= 0;\n                        wdata \u003c= txn_data;\n                        wvalid \u003c= 1;\n                        wlast \u003c= (txn_len == 1);\n                        beat_count \u003c= 1;\n                        state \u003c= DATA;\n                    end\n                end\n                DATA: begin\n                    if (wready) begin\n                        if (wlast) begin\n                            wvalid \u003c= 0;\n                            bready \u003c= 1;\n                            state \u003c= RESP;\n                        end else begin\n                            beat_count \u003c= beat_count + 1;\n                            wlast \u003c= (beat_count + 1 == txn_len);\n                        end\n                    end\n                end\n                RESP: begin\n                    if (bvalid) begin\n                        report_completion(txn_addr, bresp);\n                        bready \u003c= 0;\n                        state \u003c= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n```\n\n## Debug Capabilities\n\n### Waveform Capture\n```bash\n# Enable signal tracing\nxeDebug -design my_design \\\n    -signals top.cpu.* top.bus.* \\\n    -depth 2 \\\n    -start_cycle 100000 \\\n    -stop_cycle 200000\n\n# Generate waveform database\nxeWave -output waveform.fsdb\n```\n\n### Runtime Debug\n```bash\n# Interactive debug mode\nxeConsole -session my_session\n\n# In console:\n\u003e force top.rst_n 0\n\u003e run 100\n\u003e force top.rst_n 1\n\u003e run 1000000\n\u003e print top.cpu.pc\n\u003e watch top.cpu.exception\n```\n\n## ICE (In-Circuit Emulation) Mode\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    ICE Configuration                             │\n│                                                                  │\n│  ┌──────────────┐          ┌──────────────────────────────┐    │\n│  │   Target     │   MIPI   │        Palladium             │    │\n│  │   Board      │──────────│    (Running SoC Design)      │    │\n│  │   (Sensor)   │   I2C    │                              │    │\n│  └──────────────┘──────────│    ┌─────────────────────┐  │    │\n│                            │    │ Emulated SoC:        │  │    │\n│                            │    │  - CPU cores        │  │    │\n│                            │    │  - IPU/ISP          │  │    │\n│                            │    │  - Memory           │  │    │\n│                            │    └─────────────────────┘  │    │\n│                            └──────────────────────────────┘    │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### ICE Interface Setup\n```bash\n# Configure external connections\nxeICE -config ice_config.yaml\n\n# ice_config.yaml:\ninterfaces:\n  mipi_csi:\n    type: mipi\n    lanes: 4\n    speed: 1.5Gbps\n    connection: connector_a\n\n  i2c_ctrl:\n    type: i2c\n    speed: 400kHz\n    connection: connector_b\n    pull_ups: enabled\n```\n\n## Performance Optimization\n\n### Clock Gating Reduction\n```tcl\n# Reduce emulator overhead from clock gating\nset_compile_option -clock_gating_reduction high\n\n# Disable non-critical clock domains during debug\nxeRun -disable_domain peripheral_clk\n```\n\n### Memory Model Optimization\n```bash\n# Use abstract memory models for faster execution\nxeBuild -memory_abstraction high \\\n    -ddr_model_level functional\n```\n\n## Test Automation\n\n```python\n#!/usr/bin/env python3\n# run_regression.py\n\nimport subprocess\nimport json\n\ntests = [\n    {\"name\": \"boot_test\", \"cycles\": 1000000},\n    {\"name\": \"ddr_test\", \"cycles\": 5000000},\n    {\"name\": \"camera_capture\", \"cycles\": 10000000},\n]\n\nfor test in tests:\n    print(f\"Running {test['name']}...\")\n\n    # Load test-specific configuration\n    subprocess.run([\n        \"xeLoad\", \"-design\", \"soc_design\",\n        \"-stimulus\", f\"tests/{test['name']}.stim\"\n    ])\n\n    # Run emulation\n    result = subprocess.run([\n        \"xeRun\", \"-cycles\", str(test['cycles']),\n        \"-check\", f\"tests/{test['name']}.check\"\n    ], capture_output=True)\n\n    # Check results\n    if result.returncode == 0:\n        print(f\"  PASS: {test['name']}\")\n    else:\n        print(f\"  FAIL: {test['name']}\")\n        print(result.stderr.decode())\n```\n"])</script><script>self.__next_f.push([1,"12:T1eb3,"])</script><script>self.__next_f.push([1,"\n# Validation Methodology\n\n## V-Model Development\n\n```\nRequirements ─────────────────────────────────── System Test\n     │                                                │\n     ▼                                                ▲\nArchitecture ───────────────────────────── Integration Test\n     │                                          │\n     ▼                                          ▲\nDesign ─────────────────────────────── Unit Test\n     │                                    │\n     ▼                                    ▲\nImplementation ──────► Code Review ──────┘\n```\n\n## Test Levels\n\n### Unit Testing (IP Level)\n```c\n/* Example: UART transmit unit test */\nvoid test_uart_tx_single_char(void) {\n    uart_config_t cfg = {\n        .baudrate = 115200,\n        .databits = 8,\n        .parity = PARITY_NONE,\n        .stopbits = 1\n    };\n\n    /* Initialize */\n    uart_init(UART0_BASE, \u0026cfg);\n\n    /* Transmit character */\n    uart_putc(UART0_BASE, 'A');\n\n    /* Verify TX complete */\n    ASSERT(uart_tx_complete(UART0_BASE));\n\n    /* Verify data on loopback */\n    if (loopback_enabled) {\n        ASSERT_EQ(uart_getc(UART0_BASE), 'A');\n    }\n}\n\nvoid test_uart_tx_fifo_overflow(void) {\n    /* Fill TX FIFO beyond capacity */\n    for (int i = 0; i \u003c 32; i++) {\n        uart_putc_nonblock(UART0_BASE, 'X');\n    }\n\n    /* Next write should return busy/full */\n    ASSERT_EQ(uart_putc_nonblock(UART0_BASE, 'Y'), -EBUSY);\n}\n```\n\n### Integration Testing\n```c\n/* Example: Camera → IPU → Memory integration */\nvoid test_camera_capture_pipeline(void) {\n    struct buffer capture_buf;\n\n    /* Allocate DMA buffer */\n    capture_buf.size = 1920 * 1080 * 2;  /* YUV422 */\n    capture_buf.vaddr = dma_alloc_coherent(capture_buf.size,\n                                           \u0026capture_buf.paddr);\n\n    /* Configure CSI receiver */\n    csi_configure(CSI_LANES_4, CSI_SPEED_1500MBPS);\n\n    /* Configure IPU pipeline */\n    ipu_set_input(IPU_INPUT_CSI0, 1920, 1080, FMT_RAW10);\n    ipu_set_output(IPU_OUTPUT_MAIN, 1920, 1080, FMT_NV12);\n    ipu_set_buffer(capture_buf.paddr);\n\n    /* Start capture */\n    csi_start();\n    ipu_start();\n\n    /* Wait for frame */\n    ASSERT(wait_for_frame_done(1000) == 0);\n\n    /* Validate captured data */\n    validate_yuv_image(capture_buf.vaddr, 1920, 1080);\n\n    /* Cleanup */\n    csi_stop();\n    ipu_stop();\n    dma_free_coherent(capture_buf.vaddr);\n}\n```\n\n### System Testing\n```python\n#!/usr/bin/env python3\n# system_test_camera_streaming.py\n\nimport subprocess\nimport time\n\ndef test_4k_streaming_30fps():\n    \"\"\"Test sustained 4K video streaming at 30fps\"\"\"\n\n    # Start camera streaming\n    proc = subprocess.Popen([\n        \"gst-launch-1.0\",\n        \"v4l2src\", \"device=/dev/video0\",\n        \"!\", \"video/x-raw,width=3840,height=2160,framerate=30/1\",\n        \"!\", \"fakesink\"\n    ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n    # Run for 60 seconds\n    time.sleep(60)\n    proc.terminate()\n\n    # Parse output for dropped frames\n    stderr = proc.stderr.read().decode()\n\n    # Check no frame drops\n    assert \"dropping\" not in stderr.lower()\n    assert proc.returncode == 0\n\ndef test_thermal_throttling():\n    \"\"\"Verify thermal throttling engages correctly\"\"\"\n\n    # Start stress workload\n    stress_proc = subprocess.Popen([\"stress-ng\", \"--cpu\", \"4\"])\n\n    # Monitor temperature\n    max_temp = 0\n    throttled = False\n\n    for _ in range(120):  # 2 minutes\n        temp = read_thermal_zone(0)\n        max_temp = max(max_temp, temp)\n\n        if temp \u003e 85:\n            throttled = True\n            # Verify frequency reduced\n            freq = read_cpu_frequency()\n            assert freq \u003c MAX_FREQUENCY\n\n        time.sleep(1)\n\n    stress_proc.terminate()\n\n    print(f\"Max temperature: {max_temp}°C\")\n    assert max_temp \u003c 105  # Below critical\n```\n\n## Test Coverage Metrics\n\n### Code Coverage\n```bash\n# Compile with coverage\ngcc -fprofile-arcs -ftest-coverage -o mytest mytest.c\n\n# Run tests\n./mytest\n\n# Generate report\ngcov mytest.c\nlcov --capture --directory . --output-file coverage.info\ngenhtml coverage.info --output-directory coverage_html\n```\n\n### Register Coverage\n```python\n# Track register access during test\nclass RegisterCoverageTracker:\n    def __init__(self, reg_map):\n        self.reg_map = reg_map\n        self.read_coverage = {r: False for r in reg_map}\n        self.write_coverage = {r: False for r in reg_map}\n        self.bit_coverage = {r: 0 for r in reg_map}\n\n    def on_read(self, addr, value):\n        if addr in self.reg_map:\n            self.read_coverage[addr] = True\n            self.bit_coverage[addr] |= value\n\n    def on_write(self, addr, value):\n        if addr in self.reg_map:\n            self.write_coverage[addr] = True\n            self.bit_coverage[addr] |= value\n\n    def report(self):\n        total_regs = len(self.reg_map)\n        read_covered = sum(self.read_coverage.values())\n        write_covered = sum(self.write_coverage.values())\n\n        print(f\"Read coverage: {read_covered}/{total_regs}\")\n        print(f\"Write coverage: {write_covered}/{total_regs}\")\n```\n\n## Regression Testing\n\n### CI Pipeline\n```yaml\n# .gitlab-ci.yml for hardware validation\nstages:\n  - build\n  - unit_test\n  - hw_test\n  - system_test\n\nbuild_firmware:\n  stage: build\n  script:\n    - cmake -B build -DCMAKE_TOOLCHAIN_FILE=aarch64.cmake\n    - cmake --build build\n  artifacts:\n    paths:\n      - build/firmware.bin\n\nunit_tests:\n  stage: unit_test\n  script:\n    - cmake -B build_test -DBUILD_TESTS=ON\n    - cmake --build build_test\n    - ctest --test-dir build_test --output-on-failure\n\nhw_integration:\n  stage: hw_test\n  tags:\n    - hw-lab  # Runner connected to hardware\n  script:\n    - ./scripts/flash_board.sh build/firmware.bin\n    - ./scripts/run_hw_tests.sh\n  timeout: 2h\n\nsystem_validation:\n  stage: system_test\n  tags:\n    - hw-lab\n  script:\n    - pytest tests/system/ -v --junitxml=results.xml\n  artifacts:\n    reports:\n      junit: results.xml\n```\n\n## Bug Tracking and Triage\n\n```markdown\n## Bug Report Template\n\n### Summary\n[One-line description]\n\n### Environment\n- Silicon revision: A0/B0/C0\n- Board: [EVT/DVT/PVT]\n- Firmware version: [commit hash]\n- Linux kernel: [version]\n\n### Steps to Reproduce\n1. Step one\n2. Step two\n3. ...\n\n### Expected Behavior\n[What should happen]\n\n### Actual Behavior\n[What actually happens]\n\n### Debug Information\n- Register dumps\n- dmesg output\n- Waveform captures\n\n### Classification\n- Severity: [Critical/Major/Minor/Trivial]\n- Component: [CPU/IPU/DDR/PCIe/etc.]\n- Root cause: [RTL/Firmware/Software/Unknown]\n```\n\n## Performance Validation\n\n```c\n/* Bandwidth measurement framework */\nstruct bandwidth_test {\n    const char *name;\n    void __iomem *src;\n    void __iomem *dst;\n    size_t size;\n    int iterations;\n};\n\nvoid run_bandwidth_test(struct bandwidth_test *test) {\n    u64 start, end;\n    u64 total_cycles = 0;\n    u64 min_cycles = UINT64_MAX;\n    u64 max_cycles = 0;\n\n    /* Warmup */\n    memcpy_dma(test-\u003edst, test-\u003esrc, test-\u003esize);\n\n    /* Timed runs */\n    for (int i = 0; i \u003c test-\u003eiterations; i++) {\n        start = read_cycle_counter();\n        memcpy_dma(test-\u003edst, test-\u003esrc, test-\u003esize);\n        end = read_cycle_counter();\n\n        u64 cycles = end - start;\n        total_cycles += cycles;\n        min_cycles = min(min_cycles, cycles);\n        max_cycles = max(max_cycles, cycles);\n    }\n\n    u64 avg_cycles = total_cycles / test-\u003eiterations;\n    u64 freq_mhz = get_cpu_freq() / 1000000;\n    double bandwidth_mbps = (test-\u003esize * freq_mhz) / (avg_cycles);\n\n    printf(\"%s: %.2f MB/s (avg=%llu min=%llu max=%llu cycles)\\n\",\n           test-\u003ename, bandwidth_mbps, avg_cycles, min_cycles, max_cycles);\n}\n```\n"])</script><script>self.__next_f.push([1,"13:T175b,"])</script><script>self.__next_f.push([1,"\n# FreeRTOS Fundamentals\n\n## Task Management\n\n### Creating Tasks\n```c\n#include \"FreeRTOS.h\"\n#include \"task.h\"\n\nvoid vTaskFunction(void *pvParameters) {\n    const char *pcTaskName = (const char *)pvParameters;\n\n    for (;;) {\n        // Task logic\n        printf(\"Task: %s\\n\", pcTaskName);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nint main(void) {\n    xTaskCreate(\n        vTaskFunction,          // Function\n        \"Task1\",                // Name\n        configMINIMAL_STACK_SIZE * 2,  // Stack size\n        (void *)\"Task1\",        // Parameters\n        tskIDLE_PRIORITY + 1,   // Priority\n        NULL                    // Handle\n    );\n\n    vTaskStartScheduler();\n\n    // Should never reach here\n    for (;;);\n}\n```\n\n### Task States\n```\n                    ┌─────────────┐\n    vTaskCreate()   │             │   vTaskDelete()\n        ─────────►  │   Ready     │ ◄─────────\n                    │             │\n                    └──────┬──────┘\n                           │ Scheduler selects\n                           ▼\n                    ┌─────────────┐\n                    │             │\n                    │  Running    │\n                    │             │\n                    └──────┬──────┘\n                           │ Blocked on event\n                           ▼\n                    ┌─────────────┐\n                    │             │\n                    │  Blocked    │\n                    │             │\n                    └─────────────┘\n```\n\n## Synchronization Primitives\n\n### Semaphores\n```c\n#include \"semphr.h\"\n\nSemaphoreHandle_t xSemaphore;\n\nvoid vProducerTask(void *pvParameters) {\n    for (;;) {\n        // Produce data\n        produce_data();\n\n        // Signal consumer\n        xSemaphoreGive(xSemaphore);\n\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n\nvoid vConsumerTask(void *pvParameters) {\n    for (;;) {\n        // Wait for data\n        if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE) {\n            consume_data();\n        }\n    }\n}\n\nint main(void) {\n    xSemaphore = xSemaphoreCreateBinary();\n    // Create tasks...\n}\n```\n\n### Mutex (with Priority Inheritance)\n```c\nSemaphoreHandle_t xMutex;\n\nvoid vTask(void *pvParameters) {\n    for (;;) {\n        if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdTRUE) {\n            // Critical section - access shared resource\n            access_shared_resource();\n\n            xSemaphoreGive(xMutex);\n        }\n        vTaskDelay(pdMS_TO_TICKS(10));\n    }\n}\n\nint main(void) {\n    xMutex = xSemaphoreCreateMutex();\n    // Mutex supports priority inheritance to avoid priority inversion\n}\n```\n\n### Message Queues\n```c\n#include \"queue.h\"\n\ntypedef struct {\n    uint32_t sensor_id;\n    int32_t value;\n    TickType_t timestamp;\n} SensorData_t;\n\nQueueHandle_t xSensorQueue;\n\nvoid vSensorTask(void *pvParameters) {\n    SensorData_t data;\n\n    for (;;) {\n        data.sensor_id = 1;\n        data.value = read_sensor();\n        data.timestamp = xTaskGetTickCount();\n\n        xQueueSend(xSensorQueue, \u0026data, pdMS_TO_TICKS(10));\n\n        vTaskDelay(pdMS_TO_TICKS(100));\n    }\n}\n\nvoid vProcessorTask(void *pvParameters) {\n    SensorData_t received;\n\n    for (;;) {\n        if (xQueueReceive(xSensorQueue, \u0026received, portMAX_DELAY) == pdTRUE) {\n            process_sensor_data(\u0026received);\n        }\n    }\n}\n\nint main(void) {\n    xSensorQueue = xQueueCreate(10, sizeof(SensorData_t));\n}\n```\n\n## Interrupt Handling\n\n### ISR-Safe API\n```c\nvoid vISRHandler(void) {\n    BaseType_t xHigherPriorityTaskWoken = pdFALSE;\n\n    // Clear interrupt\n    CLEAR_INTERRUPT();\n\n    // Signal task from ISR\n    xSemaphoreGiveFromISR(xSemaphore, \u0026xHigherPriorityTaskWoken);\n\n    // Context switch if needed\n    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n}\n```\n\n### Deferred Interrupt Processing\n```c\nvoid vDeferredHandler(void *pvParameters) {\n    for (;;) {\n        // Wait for interrupt notification\n        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);\n\n        // Process interrupt in task context\n        process_interrupt_data();\n    }\n}\n\nvoid vISR(void) {\n    BaseType_t xHigherPriorityTaskWoken = pdFALSE;\n\n    CLEAR_INTERRUPT();\n\n    vTaskNotifyGiveFromISR(xDeferredHandlerTask, \u0026xHigherPriorityTaskWoken);\n\n    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);\n}\n```\n\n## Memory Management\n\n### Heap Schemes\n| Scheme | Description | Use Case |\n|--------|-------------|----------|\n| heap_1 | Simple, no free | Static allocation only |\n| heap_2 | Best fit, fragments | Variable size, no coalesce |\n| heap_4 | First fit, coalesces | General purpose |\n| heap_5 | Multiple regions | Non-contiguous memory |\n\n### Static Allocation\n```c\n// FreeRTOSConfig.h\n#define configSUPPORT_STATIC_ALLOCATION 1\n\n// Provide memory for idle task\nstatic StaticTask_t xIdleTaskTCBBuffer;\nstatic StackType_t xIdleStack[configMINIMAL_STACK_SIZE];\n\nvoid vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,\n                                    StackType_t **ppxIdleTaskStackBuffer,\n                                    uint32_t *pulIdleTaskStackSize) {\n    *ppxIdleTaskTCBBuffer = \u0026xIdleTaskTCBBuffer;\n    *ppxIdleTaskStackBuffer = xIdleStack;\n    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;\n}\n```\n\n## Software Timers\n```c\n#include \"timers.h\"\n\nvoid vTimerCallback(TimerHandle_t xTimer) {\n    uint32_t ulTimerID = (uint32_t)pvTimerGetTimerID(xTimer);\n    printf(\"Timer %lu expired\\n\", ulTimerID);\n}\n\nint main(void) {\n    TimerHandle_t xTimer = xTimerCreate(\n        \"Timer1\",                   // Name\n        pdMS_TO_TICKS(1000),        // Period\n        pdTRUE,                     // Auto-reload\n        (void *)1,                  // Timer ID\n        vTimerCallback              // Callback\n    );\n\n    xTimerStart(xTimer, 0);\n    vTaskStartScheduler();\n}\n```\n"])</script><script>self.__next_f.push([1,"14:T1a28,"])</script><script>self.__next_f.push([1,"\n# QNX Neutrino RTOS\n\n## Microkernel Architecture\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    User Space                            │\n│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │\n│  │ Driver  │  │  App    │  │ File    │  │ Network │    │\n│  │ Process │  │ Process │  │ System  │  │ Stack   │    │\n│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │\n│       │            │            │            │          │\n├───────┴────────────┴────────────┴────────────┴──────────┤\n│                   Message Passing                        │\n├─────────────────────────────────────────────────────────┤\n│                   QNX Microkernel                        │\n│         (Scheduling, IPC, Interrupt Handling)            │\n├─────────────────────────────────────────────────────────┤\n│                      Hardware                            │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Message Passing IPC\n\n### Server Process\n```c\n#include \u003csys/neutrino.h\u003e\n#include \u003csys/dispatch.h\u003e\n\n#define MY_PULSE_CODE _PULSE_CODE_MINAVAIL\n\ntypedef struct {\n    uint16_t type;\n    uint16_t subtype;\n    int data;\n} my_msg_t;\n\ntypedef struct {\n    uint16_t type;\n    int result;\n} my_reply_t;\n\nint main(void) {\n    name_attach_t *attach;\n    my_msg_t msg;\n    my_reply_t reply;\n    int rcvid;\n\n    // Create channel and register name\n    attach = name_attach(NULL, \"my_server\", 0);\n    if (attach == NULL) {\n        perror(\"name_attach\");\n        return EXIT_FAILURE;\n    }\n\n    printf(\"Server running, waiting for messages...\\n\");\n\n    for (;;) {\n        rcvid = MsgReceive(attach-\u003echid, \u0026msg, sizeof(msg), NULL);\n\n        if (rcvid == 0) {\n            // Pulse received\n            printf(\"Pulse received: code=%d, value=%d\\n\",\n                   msg.type, msg.subtype);\n        } else if (rcvid \u003e 0) {\n            // Message received\n            printf(\"Message: type=%d, data=%d\\n\", msg.type, msg.data);\n\n            reply.type = 0;\n            reply.result = msg.data * 2;  // Process and reply\n\n            MsgReply(rcvid, EOK, \u0026reply, sizeof(reply));\n        }\n    }\n\n    name_detach(attach, 0);\n    return EXIT_SUCCESS;\n}\n```\n\n### Client Process\n```c\n#include \u003csys/neutrino.h\u003e\n\nint main(void) {\n    int fd, result;\n    my_msg_t msg;\n    my_reply_t reply;\n\n    // Connect to server\n    fd = name_open(\"my_server\", 0);\n    if (fd == -1) {\n        perror(\"name_open\");\n        return EXIT_FAILURE;\n    }\n\n    // Send message\n    msg.type = 1;\n    msg.subtype = 0;\n    msg.data = 42;\n\n    result = MsgSend(fd, \u0026msg, sizeof(msg), \u0026reply, sizeof(reply));\n    if (result == -1) {\n        perror(\"MsgSend\");\n    } else {\n        printf(\"Reply: result=%d\\n\", reply.result);\n    }\n\n    name_close(fd);\n    return EXIT_SUCCESS;\n}\n```\n\n## Resource Manager (Device Driver)\n\n```c\n#include \u003csys/iofunc.h\u003e\n#include \u003csys/dispatch.h\u003e\n\nstatic resmgr_connect_funcs_t connect_funcs;\nstatic resmgr_io_funcs_t io_funcs;\nstatic iofunc_attr_t attr;\n\nint io_read(resmgr_context_t *ctp, io_read_t *msg,\n            RESMGR_OCB_T *ocb) {\n    int status;\n    char *buf = \"Hello from device!\\n\";\n    int nbytes = strlen(buf);\n\n    if (ocb-\u003eoffset \u003e= nbytes)\n        return 0;\n\n    nbytes -= ocb-\u003eoffset;\n\n    // Return data to client\n    _IO_SET_READ_NBYTES(ctp, nbytes);\n    SETIOV(\u0026ctp-\u003eiov[0], buf + ocb-\u003eoffset, nbytes);\n\n    ocb-\u003eoffset += nbytes;\n\n    return _RESMGR_NPARTS(1);\n}\n\nint io_write(resmgr_context_t *ctp, io_write_t *msg,\n             RESMGR_OCB_T *ocb) {\n    char *buf;\n    int nbytes = msg-\u003ei.nbytes;\n\n    buf = malloc(nbytes + 1);\n    resmgr_msgread(ctp, buf, nbytes, sizeof(msg-\u003ei));\n    buf[nbytes] = '\\0';\n\n    printf(\"Received: %s\\n\", buf);\n    free(buf);\n\n    _IO_SET_WRITE_NBYTES(ctp, nbytes);\n    return _RESMGR_NPARTS(0);\n}\n\nint main(void) {\n    dispatch_t *dpp;\n    resmgr_attr_t rattr;\n    dispatch_context_t *ctp;\n    int id;\n\n    dpp = dispatch_create();\n\n    memset(\u0026rattr, 0, sizeof(rattr));\n    rattr.nparts_max = 1;\n    rattr.msg_max_size = 2048;\n\n    iofunc_func_init(_RESMGR_CONNECT_NFUNCS, \u0026connect_funcs,\n                     _RESMGR_IO_NFUNCS, \u0026io_funcs);\n    io_funcs.read = io_read;\n    io_funcs.write = io_write;\n\n    iofunc_attr_init(\u0026attr, S_IFCHR | 0666, NULL, NULL);\n\n    id = resmgr_attach(dpp, \u0026rattr, \"/dev/mydevice\",\n                       _FTYPE_ANY, 0, \u0026connect_funcs,\n                       \u0026io_funcs, \u0026attr);\n\n    ctp = dispatch_context_alloc(dpp);\n\n    for (;;) {\n        ctp = dispatch_block(ctp);\n        dispatch_handler(ctp);\n    }\n\n    return EXIT_SUCCESS;\n}\n```\n\n## Interrupt Handling\n\n```c\n#include \u003csys/neutrino.h\u003e\n\nconst struct sigevent *isr_handler(void *arg, int id) {\n    struct sigevent *event = (struct sigevent *)arg;\n\n    // Clear interrupt at hardware level\n    out32(INT_CLEAR_REG, INT_MASK);\n\n    // Return event to wake up thread\n    return event;\n}\n\nvoid interrupt_thread(void *arg) {\n    struct sigevent event;\n    int iid;\n\n    // Get I/O privileges\n    ThreadCtl(_NTO_TCTL_IO, 0);\n\n    // Set up pulse event\n    SIGEV_INTR_INIT(\u0026event);\n\n    // Attach interrupt\n    iid = InterruptAttach(IRQ_NUM, isr_handler, \u0026event,\n                          sizeof(event), _NTO_INTR_FLAGS_TRK_MSK);\n\n    for (;;) {\n        InterruptWait(0, NULL);\n\n        // Process interrupt in thread context\n        process_hardware_data();\n\n        InterruptUnmask(IRQ_NUM, iid);\n    }\n}\n```\n\n## Adaptive Partitioning\n\n```c\n// Create partition\nsched_aps_create_parms parms;\nmemset(\u0026parms, 0, sizeof(parms));\nparms.budget_percent = 30;  // 30% CPU budget\nstrncpy(parms.name, \"camera_partition\", sizeof(parms.name));\n\nint part_id = SchedCtl(SCHED_APS_CREATE_PARTITION, \u0026parms, sizeof(parms));\n\n// Join partition\nsched_aps_join_parms join;\njoin.id = part_id;\njoin.pid = getpid();\njoin.tid = 0;\n\nSchedCtl(SCHED_APS_JOIN_PARTITION, \u0026join, sizeof(join));\n```\n"])</script><script>self.__next_f.push([1,"15:T15cb,"])</script><script>self.__next_f.push([1,"\n# Zephyr RTOS Development\n\n## Project Structure\n\n```\nmy_app/\n├── CMakeLists.txt\n├── prj.conf\n├── app.overlay\n└── src/\n    └── main.c\n```\n\n### CMakeLists.txt\n```cmake\ncmake_minimum_required(VERSION 3.20.0)\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(my_app)\n\ntarget_sources(app PRIVATE src/main.c)\n```\n\n### prj.conf\n```ini\nCONFIG_GPIO=y\nCONFIG_I2C=y\nCONFIG_SPI=y\nCONFIG_SENSOR=y\nCONFIG_LOG=y\nCONFIG_SHELL=y\nCONFIG_HEAP_MEM_POOL_SIZE=4096\n```\n\n## Thread and Synchronization\n\n### Thread Creation\n```c\n#include \u003czephyr/kernel.h\u003e\n\n#define STACK_SIZE 1024\n#define PRIORITY 5\n\nK_THREAD_STACK_DEFINE(my_stack, STACK_SIZE);\nstruct k_thread my_thread_data;\n\nvoid my_thread_entry(void *p1, void *p2, void *p3) {\n    while (1) {\n        printk(\"Thread running\\n\");\n        k_sleep(K_MSEC(1000));\n    }\n}\n\nvoid main(void) {\n    k_thread_create(\u0026my_thread_data, my_stack,\n                    K_THREAD_STACK_SIZEOF(my_stack),\n                    my_thread_entry,\n                    NULL, NULL, NULL,\n                    PRIORITY, 0, K_NO_WAIT);\n}\n```\n\n### Semaphores and Mutexes\n```c\nK_SEM_DEFINE(my_sem, 0, 1);\nK_MUTEX_DEFINE(my_mutex);\n\nvoid producer_thread(void) {\n    while (1) {\n        // Produce data\n        k_sem_give(\u0026my_sem);\n        k_sleep(K_MSEC(100));\n    }\n}\n\nvoid consumer_thread(void) {\n    while (1) {\n        k_sem_take(\u0026my_sem, K_FOREVER);\n\n        k_mutex_lock(\u0026my_mutex, K_FOREVER);\n        // Access shared resource\n        k_mutex_unlock(\u0026my_mutex);\n    }\n}\n```\n\n### Message Queues\n```c\nstruct sensor_msg {\n    uint32_t timestamp;\n    int32_t value;\n};\n\nK_MSGQ_DEFINE(sensor_msgq, sizeof(struct sensor_msg), 10, 4);\n\nvoid sensor_thread(void) {\n    struct sensor_msg msg;\n\n    while (1) {\n        msg.timestamp = k_uptime_get_32();\n        msg.value = read_sensor();\n\n        k_msgq_put(\u0026sensor_msgq, \u0026msg, K_NO_WAIT);\n        k_sleep(K_MSEC(100));\n    }\n}\n\nvoid processor_thread(void) {\n    struct sensor_msg msg;\n\n    while (1) {\n        k_msgq_get(\u0026sensor_msgq, \u0026msg, K_FOREVER);\n        process_sensor(\u0026msg);\n    }\n}\n```\n\n## Device Driver Model\n\n### Simple GPIO Driver\n```c\n#include \u003czephyr/device.h\u003e\n#include \u003czephyr/drivers/gpio.h\u003e\n\n#define LED0_NODE DT_ALIAS(led0)\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\n\nvoid main(void) {\n    int ret;\n\n    if (!gpio_is_ready_dt(\u0026led)) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(\u0026led, GPIO_OUTPUT_ACTIVE);\n    if (ret \u003c 0) {\n        return;\n    }\n\n    while (1) {\n        gpio_pin_toggle_dt(\u0026led);\n        k_sleep(K_MSEC(500));\n    }\n}\n```\n\n### I2C Sensor Driver\n```c\n#include \u003czephyr/drivers/i2c.h\u003e\n#include \u003czephyr/drivers/sensor.h\u003e\n\n#define SENSOR_I2C_ADDR 0x48\n#define TEMP_REG 0x00\n\nstruct my_sensor_data {\n    int16_t temperature;\n};\n\nstruct my_sensor_config {\n    struct i2c_dt_spec i2c;\n};\n\nstatic int my_sensor_sample_fetch(const struct device *dev,\n                                   enum sensor_channel chan) {\n    struct my_sensor_data *data = dev-\u003edata;\n    const struct my_sensor_config *cfg = dev-\u003econfig;\n    uint8_t buf[2];\n\n    if (i2c_burst_read_dt(\u0026cfg-\u003ei2c, TEMP_REG, buf, 2) \u003c 0) {\n        return -EIO;\n    }\n\n    data-\u003etemperature = (buf[0] \u003c\u003c 8) | buf[1];\n    return 0;\n}\n\nstatic int my_sensor_channel_get(const struct device *dev,\n                                  enum sensor_channel chan,\n                                  struct sensor_value *val) {\n    struct my_sensor_data *data = dev-\u003edata;\n\n    if (chan == SENSOR_CHAN_AMBIENT_TEMP) {\n        val-\u003eval1 = data-\u003etemperature / 256;\n        val-\u003eval2 = (data-\u003etemperature % 256) * 10000;\n        return 0;\n    }\n\n    return -ENOTSUP;\n}\n\nstatic const struct sensor_driver_api my_sensor_api = {\n    .sample_fetch = my_sensor_sample_fetch,\n    .channel_get = my_sensor_channel_get,\n};\n\n#define MY_SENSOR_INIT(n)                                           \\\n    static struct my_sensor_data my_sensor_data_##n;                \\\n    static const struct my_sensor_config my_sensor_config_##n = {   \\\n        .i2c = I2C_DT_SPEC_INST_GET(n),                            \\\n    };                                                              \\\n    SENSOR_DEVICE_DT_INST_DEFINE(n, my_sensor_init, NULL,          \\\n                                  \u0026my_sensor_data_##n,              \\\n                                  \u0026my_sensor_config_##n,            \\\n                                  POST_KERNEL,                      \\\n                                  CONFIG_SENSOR_INIT_PRIORITY,      \\\n                                  \u0026my_sensor_api);\n\nDT_INST_FOREACH_STATUS_OKAY(MY_SENSOR_INIT)\n```\n\n## Device Tree Overlay\n\n```dts\n/* app.overlay */\n/ {\n    aliases {\n        led0 = \u0026myled;\n    };\n\n    leds {\n        compatible = \"gpio-leds\";\n        myled: led_0 {\n            gpios = \u003c\u0026gpio0 13 GPIO_ACTIVE_LOW\u003e;\n            label = \"User LED\";\n        };\n    };\n};\n\n\u0026i2c0 {\n    status = \"okay\";\n\n    my_sensor: my_sensor@48 {\n        compatible = \"vendor,my-sensor\";\n        reg = \u003c0x48\u003e;\n        label = \"MY_SENSOR\";\n    };\n};\n```\n\n## Power Management\n\n```c\n#include \u003czephyr/pm/pm.h\u003e\n#include \u003czephyr/pm/device.h\u003e\n\nstatic int my_driver_pm_action(const struct device *dev,\n                                enum pm_device_action action) {\n    switch (action) {\n    case PM_DEVICE_ACTION_SUSPEND:\n        // Save state, disable hardware\n        return 0;\n    case PM_DEVICE_ACTION_RESUME:\n        // Restore state, enable hardware\n        return 0;\n    default:\n        return -ENOTSUP;\n    }\n}\n\nPM_DEVICE_DT_DEFINE(DT_NODELABEL(my_device), my_driver_pm_action);\n```\n"])</script><script>self.__next_f.push([1,"16:T29c6,"])</script><script>self.__next_f.push([1,"\n# IPU (Imaging Processing Unit)\n\n## IPU Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                           IPU                                    │\n│  ┌──────────────────────────────────────────────────────────┐  │\n│  │                   Input Interface                         │  │\n│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │  │\n│  │  │ CSI-2   │  │ CSI-2   │  │ Parallel│  │  TPG    │     │  │\n│  │  │  RX 0   │  │  RX 1   │  │Interface│  │(Test)   │     │  │\n│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘     │  │\n│  └───────┼───────────┼───────────┼───────────┼──────────────┘  │\n│          │           │           │           │                  │\n│  ┌───────▼───────────▼───────────▼───────────▼──────────────┐  │\n│  │                Input Stage (IS)                            │  │\n│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐                │  │\n│  │  │   BLC    │  │  LSC     │  │   DPC    │                │  │\n│  │  │(Blk Lvl) │  │(Lens     │  │(Dead Pxl)│                │  │\n│  │  │ Correct) │  │ Shading) │  │ Correct) │                │  │\n│  │  └──────────┘  └──────────┘  └──────────┘                │  │\n│  └─────────────────────────┬────────────────────────────────┘  │\n│                            │                                    │\n│  ┌─────────────────────────▼────────────────────────────────┐  │\n│  │               Processing Stage (PS)                       │  │\n│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │  │\n│  │  │ Demosaic │  │  CCM     │  │  Gamma   │  │  CSC     │ │  │\n│  │  │          │  │(Color    │  │ Correct  │  │(YUV/RGB) │ │  │\n│  │  │          │  │ Matrix)  │  │          │  │          │ │  │\n│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │  │\n│  └─────────────────────────┬────────────────────────────────┘  │\n│                            │                                    │\n│  ┌─────────────────────────▼────────────────────────────────┐  │\n│  │                Output Stage                               │  │\n│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐               │  │\n│  │  │ Scaler   │  │ Cropper  │  │   DMA    │               │  │\n│  │  │          │  │          │  │  Output  │               │  │\n│  │  └──────────┘  └──────────┘  └──────────┘               │  │\n│  └──────────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## ISP Pipeline Blocks\n\n### Black Level Correction (BLC)\n```c\nstruct blc_config {\n    s16 offset_r;   /* Red channel offset */\n    s16 offset_gr;  /* Green-Red channel offset */\n    s16 offset_gb;  /* Green-Blue channel offset */\n    s16 offset_b;   /* Blue channel offset */\n};\n\nstatic void ipu_set_blc(struct ipu_dev *ipu, struct blc_config *cfg) {\n    writel((cfg-\u003eoffset_r \u0026 0xFFFF) | ((cfg-\u003eoffset_gr \u0026 0xFFFF) \u003c\u003c 16),\n           ipu-\u003ebase + IPU_BLC_OFFSET_RG);\n    writel((cfg-\u003eoffset_b \u0026 0xFFFF) | ((cfg-\u003eoffset_gb \u0026 0xFFFF) \u003c\u003c 16),\n           ipu-\u003ebase + IPU_BLC_OFFSET_GB);\n}\n```\n\n### Lens Shading Correction (LSC)\n```c\nstruct lsc_table {\n    u16 r_gain[17][17];    /* Red gain table */\n    u16 gr_gain[17][17];   /* Green-Red gain table */\n    u16 gb_gain[17][17];   /* Green-Blue gain table */\n    u16 b_gain[17][17];    /* Blue gain table */\n};\n\nstatic void ipu_load_lsc_table(struct ipu_dev *ipu, struct lsc_table *lsc) {\n    int i, j;\n    u32 *table_addr = ipu-\u003elsc_sram;\n\n    for (i = 0; i \u003c 17; i++) {\n        for (j = 0; j \u003c 17; j++) {\n            *table_addr++ = (lsc-\u003er_gain[i][j] \u0026 0x1FFF) |\n                           ((lsc-\u003egr_gain[i][j] \u0026 0x1FFF) \u003c\u003c 16);\n            *table_addr++ = (lsc-\u003egb_gain[i][j] \u0026 0x1FFF) |\n                           ((lsc-\u003eb_gain[i][j] \u0026 0x1FFF) \u003c\u003c 16);\n        }\n    }\n\n    writel(IPU_LSC_ENABLE, ipu-\u003ebase + IPU_LSC_CTRL);\n}\n```\n\n### Color Correction Matrix (CCM)\n```c\n/*\n * CCM: 3x3 matrix transforming sensor RGB to sRGB\n * [R']   [ccm00 ccm01 ccm02] [R]\n * [G'] = [ccm10 ccm11 ccm12] [G]\n * [B']   [ccm20 ccm21 ccm22] [B]\n */\nstruct ccm_config {\n    s16 matrix[3][3];  /* Signed Q3.9 format */\n    s16 offset[3];     /* RGB offsets */\n};\n\nstatic void ipu_set_ccm(struct ipu_dev *ipu, struct ccm_config *ccm) {\n    int i, j;\n\n    for (i = 0; i \u003c 3; i++) {\n        for (j = 0; j \u003c 3; j++) {\n            writel(ccm-\u003ematrix[i][j],\n                   ipu-\u003ebase + IPU_CCM_COEF(i, j));\n        }\n        writel(ccm-\u003eoffset[i], ipu-\u003ebase + IPU_CCM_OFFSET(i));\n    }\n}\n```\n\n### Demosaic (Bayer Interpolation)\n```c\n/*\n * Bayer Pattern:\n * R  Gr R  Gr R  Gr\n * Gb B  Gb B  Gb B\n * R  Gr R  Gr R  Gr\n * Gb B  Gb B  Gb B\n */\nenum bayer_pattern {\n    BAYER_RGGB = 0,\n    BAYER_GRBG = 1,\n    BAYER_GBRG = 2,\n    BAYER_BGGR = 3,\n};\n\nstatic void ipu_set_demosaic(struct ipu_dev *ipu,\n                              enum bayer_pattern pattern,\n                              bool edge_adaptive) {\n    u32 val = pattern \u0026 0x3;\n\n    if (edge_adaptive)\n        val |= IPU_DEMOSAIC_EDGE_ADAPTIVE;\n    else\n        val |= IPU_DEMOSAIC_BILINEAR;\n\n    writel(val, ipu-\u003ebase + IPU_DEMOSAIC_CTRL);\n}\n```\n\n## 3A Algorithms Interface\n\n### Auto Exposure (AE)\n```c\nstruct ae_stats {\n    u32 luma_sum[16][16];  /* Zone luminance sums */\n    u32 pixel_count[16][16];\n    u32 histogram[256];\n};\n\nstruct ae_result {\n    u32 exposure_time;     /* in microseconds */\n    u32 analog_gain;       /* Q4.8 format */\n    u32 digital_gain;      /* Q4.8 format */\n};\n\nstatic int ipu_get_ae_stats(struct ipu_dev *ipu, struct ae_stats *stats) {\n    void __iomem *stat_base = ipu-\u003ebase + IPU_AE_STATS;\n    int i;\n\n    /* Read zone statistics */\n    for (i = 0; i \u003c 256; i++) {\n        stats-\u003eluma_sum[i / 16][i % 16] = readl(stat_base + i * 8);\n        stats-\u003epixel_count[i / 16][i % 16] = readl(stat_base + i * 8 + 4);\n    }\n\n    /* Read histogram */\n    for (i = 0; i \u003c 256; i++) {\n        stats-\u003ehistogram[i] = readl(ipu-\u003ebase + IPU_AE_HIST + i * 4);\n    }\n\n    return 0;\n}\n```\n\n### Auto White Balance (AWB)\n```c\nstruct awb_stats {\n    u32 r_sum[32][32];\n    u32 g_sum[32][32];\n    u32 b_sum[32][32];\n    u32 count[32][32];\n};\n\nstruct awb_result {\n    u16 r_gain;   /* Red gain, Q2.10 */\n    u16 g_gain;   /* Green gain (usually 1.0) */\n    u16 b_gain;   /* Blue gain, Q2.10 */\n};\n\nstatic void ipu_apply_awb(struct ipu_dev *ipu, struct awb_result *awb) {\n    writel(awb-\u003er_gain, ipu-\u003ebase + IPU_AWB_R_GAIN);\n    writel(awb-\u003eg_gain, ipu-\u003ebase + IPU_AWB_G_GAIN);\n    writel(awb-\u003eb_gain, ipu-\u003ebase + IPU_AWB_B_GAIN);\n}\n```\n\n### Auto Focus (AF)\n```c\nstruct af_stats {\n    u32 fv_h[9];   /* Horizontal frequency variance for 9 zones */\n    u32 fv_v[9];   /* Vertical frequency variance */\n    u32 contrast[9];\n};\n\nstatic void ipu_configure_af_zones(struct ipu_dev *ipu,\n                                    struct rect *zones, int num) {\n    int i;\n\n    for (i = 0; i \u003c num; i++) {\n        writel((zones[i].left \u003c\u003c 16) | zones[i].top,\n               ipu-\u003ebase + IPU_AF_ZONE_POS(i));\n        writel((zones[i].width \u003c\u003c 16) | zones[i].height,\n               ipu-\u003ebase + IPU_AF_ZONE_SIZE(i));\n    }\n\n    writel(num - 1, ipu-\u003ebase + IPU_AF_ZONE_NUM);\n}\n```\n\n## Buffer Management\n\n```c\nstruct ipu_buffer {\n    struct vb2_v4l2_buffer vb;\n    struct list_head list;\n    dma_addr_t dma_addr;\n    u32 size;\n};\n\nstatic void ipu_queue_buffer(struct ipu_dev *ipu, struct ipu_buffer *buf) {\n    /* Write buffer address to hardware */\n    writeq(buf-\u003edma_addr, ipu-\u003ebase + IPU_OUT_ADDR);\n    writel(buf-\u003esize, ipu-\u003ebase + IPU_OUT_SIZE);\n\n    /* Trigger buffer switch on next frame */\n    writel(IPU_BUF_UPDATE, ipu-\u003ebase + IPU_CTRL);\n}\n\nstatic irqreturn_t ipu_frame_done_isr(int irq, void *dev_id) {\n    struct ipu_dev *ipu = dev_id;\n    struct ipu_buffer *buf;\n\n    /* Get completed buffer */\n    spin_lock(\u0026ipu-\u003elock);\n    buf = list_first_entry(\u0026ipu-\u003eactive_list, struct ipu_buffer, list);\n    list_del(\u0026buf-\u003elist);\n    spin_unlock(\u0026ipu-\u003elock);\n\n    /* Mark buffer done */\n    buf-\u003evb.vb2_buf.timestamp = ktime_get_ns();\n    buf-\u003evb.sequence = ipu-\u003eframe_count++;\n    vb2_buffer_done(\u0026buf-\u003evb.vb2_buf, VB2_BUF_STATE_DONE);\n\n    /* Queue next buffer if available */\n    spin_lock(\u0026ipu-\u003elock);\n    if (!list_empty(\u0026ipu-\u003epending_list)) {\n        buf = list_first_entry(\u0026ipu-\u003epending_list, struct ipu_buffer, list);\n        list_move_tail(\u0026buf-\u003elist, \u0026ipu-\u003eactive_list);\n        ipu_queue_buffer(ipu, buf);\n    }\n    spin_unlock(\u0026ipu-\u003elock);\n\n    return IRQ_HANDLED;\n}\n```\n"])</script><script>self.__next_f.push([1,"17:T2660,"])</script><script>self.__next_f.push([1,"\n# SoC Architecture Fundamentals\n\n## Modern SoC Block Diagram\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                          SoC                                     │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │                    CPU Cluster                           │   │\n│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │\n│  │  │ Cortex  │ │ Cortex  │ │ Cortex  │ │ Cortex  │       │   │\n│  │  │  A78    │ │  A78    │ │  A55    │ │  A55    │       │   │\n│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘       │   │\n│  │       │           │           │           │             │   │\n│  │       └─────┬─────┴─────┬─────┴─────┬─────┘             │   │\n│  │             │    L3 Cache          │                    │   │\n│  │             └──────────┬───────────┘                    │   │\n│  └─────────────────────────┼───────────────────────────────┘   │\n│                            │                                    │\n│  ┌─────────────────────────┼───────────────────────────────┐   │\n│  │                  NoC (Network on Chip)                   │   │\n│  │              (CCI-500 / CMN-600 / NoC-400)              │   │\n│  └───────┬─────────┬───────┴───────┬─────────┬─────────────┘   │\n│          │         │               │         │                  │\n│    ┌─────▼───┐ ┌───▼────┐   ┌─────▼───┐ ┌───▼────┐            │\n│    │   GPU   │ │  NPU   │   │   IPU   │ │  VPU   │            │\n│    │         │ │  (AI)  │   │ (Camera)│ │(Video) │            │\n│    └─────────┘ └────────┘   └─────────┘ └────────┘            │\n│                                                                 │\n│    ┌─────────────────────────────────────────────────────┐    │\n│    │                Memory Controller                      │    │\n│    │              (LPDDR5/DDR5 Interface)                  │    │\n│    └─────────────────────────────────────────────────────┘    │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## ARM CPU Subsystem\n\n### Exception Levels\n```\nEL3 - Secure Monitor (ATF/TF-A)\n │\n ├── EL2 - Hypervisor (KVM, Xen)\n │    │\n │    └── EL1 - OS Kernel (Linux, RTOS)\n │         │\n │         └── EL0 - User Applications\n │\n └── Secure World\n      ├── S-EL1 - Secure OS (OP-TEE)\n      └── S-EL0 - Trusted Applications\n```\n\n### CPU Core Configuration\n```c\n// Reading CPU features (CPUID)\nstatic void read_cpu_features(void) {\n    u64 midr, mpidr, revidr;\n\n    // Main ID Register\n    midr = read_sysreg(MIDR_EL1);\n    pr_info(\"MIDR: Implementer=0x%x, Variant=%d, Part=0x%x, Rev=%d\\n\",\n            (midr \u003e\u003e 24) \u0026 0xFF,\n            (midr \u003e\u003e 20) \u0026 0xF,\n            (midr \u003e\u003e 4) \u0026 0xFFF,\n            midr \u0026 0xF);\n\n    // Multiprocessor Affinity Register\n    mpidr = read_sysreg(MPIDR_EL1);\n    pr_info(\"MPIDR: Aff3=%d, Aff2=%d, Aff1=%d, Aff0=%d\\n\",\n            (mpidr \u003e\u003e 32) \u0026 0xFF,\n            (mpidr \u003e\u003e 16) \u0026 0xFF,\n            (mpidr \u003e\u003e 8) \u0026 0xFF,\n            mpidr \u0026 0xFF);\n}\n```\n\n## NoC (Network on Chip)\n\n### NoC Topology\n```\n         ┌─────────┐\n         │  CPU    │\n         └────┬────┘\n              │\n    ┌─────────┼─────────┐\n    │         │         │\n┌───▼───┐ ┌───▼───┐ ┌───▼───┐\n│ Router│ │ Router│ │ Router│\n└───┬───┘ └───┬───┘ └───┬───┘\n    │         │         │\n┌───▼───┐ ┌───▼───┐ ┌───▼───┐\n│  GPU  │ │  IPU  │ │  DDR  │\n└───────┘ └───────┘ └───────┘\n```\n\n### QoS (Quality of Service)\n```c\n// NoC QoS register configuration\nstruct noc_qos_regs {\n    u32 priority;       // Transaction priority\n    u32 mode;           // Fixed/Limiter/Regulator\n    u32 bandwidth;      // Bandwidth limit\n    u32 saturation;     // Saturation threshold\n};\n\nstatic void configure_noc_qos(void __iomem *base, int master_id,\n                               struct noc_qos_regs *qos) {\n    void __iomem *master_base = base + (master_id * 0x100);\n\n    writel(qos-\u003epriority, master_base + NOC_QOS_PRIORITY);\n    writel(qos-\u003emode, master_base + NOC_QOS_MODE);\n    writel(qos-\u003ebandwidth, master_base + NOC_QOS_BANDWIDTH);\n    writel(qos-\u003esaturation, master_base + NOC_QOS_SATURATION);\n}\n```\n\n## Power Domain Management\n\n### Power Domain Hierarchy\n```dts\npower: power-controller@ff010000 {\n    compatible = \"vendor,power-controller\";\n    reg = \u003c0x0 0xff010000 0x0 0x1000\u003e;\n    #power-domain-cells = \u003c1\u003e;\n\n    pd_gpu: power-domain@0 {\n        reg = \u003c0\u003e;\n        #power-domain-cells = \u003c0\u003e;\n    };\n\n    pd_ipu: power-domain@1 {\n        reg = \u003c1\u003e;\n        #power-domain-cells = \u003c0\u003e;\n        power-domains = \u003c\u0026pd_top\u003e;  /* Parent dependency */\n    };\n\n    pd_vpu: power-domain@2 {\n        reg = \u003c2\u003e;\n        #power-domain-cells = \u003c0\u003e;\n    };\n};\n\ngpu: gpu@ff100000 {\n    power-domains = \u003c\u0026pd_gpu\u003e;\n};\n```\n\n### Power Domain Driver\n```c\n#include \u003clinux/pm_domain.h\u003e\n\nstruct my_pm_domain {\n    struct generic_pm_domain genpd;\n    void __iomem *base;\n    u32 pwr_mask;\n};\n\nstatic int my_pd_power_on(struct generic_pm_domain *genpd) {\n    struct my_pm_domain *pd = container_of(genpd, struct my_pm_domain, genpd);\n    u32 val;\n    int timeout = 1000;\n\n    // Request power on\n    val = readl(pd-\u003ebase + PWR_CTRL);\n    val |= pd-\u003epwr_mask;\n    writel(val, pd-\u003ebase + PWR_CTRL);\n\n    // Wait for power good\n    while (--timeout) {\n        val = readl(pd-\u003ebase + PWR_STATUS);\n        if (val \u0026 pd-\u003epwr_mask)\n            return 0;\n        udelay(10);\n    }\n\n    return -ETIMEDOUT;\n}\n\nstatic int my_pd_power_off(struct generic_pm_domain *genpd) {\n    struct my_pm_domain *pd = container_of(genpd, struct my_pm_domain, genpd);\n    u32 val;\n\n    val = readl(pd-\u003ebase + PWR_CTRL);\n    val \u0026= ~pd-\u003epwr_mask;\n    writel(val, pd-\u003ebase + PWR_CTRL);\n\n    return 0;\n}\n```\n\n## Clock Tree\n\n```\n                    ┌─────────────┐\n                    │   PLL0      │\n                    │  (24MHz →   │\n                    │   1.2GHz)   │\n                    └──────┬──────┘\n                           │\n        ┌──────────────────┼──────────────────┐\n        │                  │                  │\n   ┌────▼─────┐      ┌─────▼────┐      ┌─────▼────┐\n   │ CPU DIV  │      │ GPU DIV  │      │ BUS DIV  │\n   │  (/1)    │      │  (/2)    │      │  (/4)    │\n   └────┬─────┘      └─────┬────┘      └─────┬────┘\n        │                  │                  │\n   ┌────▼─────┐      ┌─────▼────┐      ┌─────▼────┐\n   │ CPU Gate │      │ GPU Gate │      │ BUS Gate │\n   └────┬─────┘      └─────┬────┘      └─────┬────┘\n        │                  │                  │\n        ▼                  ▼                  ▼\n     1.2GHz             600MHz             300MHz\n```\n\n### Clock Driver\n```c\n#include \u003clinux/clk-provider.h\u003e\n\nstatic const struct clk_ops my_pll_ops = {\n    .recalc_rate = my_pll_recalc_rate,\n    .set_rate = my_pll_set_rate,\n    .round_rate = my_pll_round_rate,\n    .enable = my_pll_enable,\n    .disable = my_pll_disable,\n    .is_enabled = my_pll_is_enabled,\n};\n\nstatic unsigned long my_pll_recalc_rate(struct clk_hw *hw,\n                                         unsigned long parent_rate) {\n    struct my_pll *pll = to_my_pll(hw);\n    u32 fbdiv, refdiv, postdiv;\n\n    fbdiv = readl(pll-\u003ebase + PLL_FBDIV) \u0026 0xFFF;\n    refdiv = readl(pll-\u003ebase + PLL_REFDIV) \u0026 0x3F;\n    postdiv = readl(pll-\u003ebase + PLL_POSTDIV) \u0026 0x7;\n\n    return (parent_rate * fbdiv) / (refdiv * postdiv);\n}\n```\n"])</script><script>self.__next_f.push([1,"18:T22da,"])</script><script>self.__next_f.push([1,"\n# ARM TrustZone and Secure Boot\n\n## TrustZone Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        ARM Processor                             │\n│  ┌──────────────────────┐    ┌──────────────────────┐          │\n│  │     Normal World     │    │     Secure World     │          │\n│  │  ┌────────────────┐  │    │  ┌────────────────┐  │          │\n│  │  │ Rich OS (Linux)│  │    │  │  Secure OS     │  │          │\n│  │  │     EL1       │  │    │  │  (OP-TEE) S-EL1│  │          │\n│  │  └───────┬────────┘  │    │  └───────┬────────┘  │          │\n│  │          │          │    │          │          │          │\n│  │  ┌───────▼────────┐  │    │  ┌───────▼────────┐  │          │\n│  │  │ User Apps EL0  │  │    │  │Trusted Apps    │  │          │\n│  │  └────────────────┘  │◄──►│  │    S-EL0       │  │          │\n│  └──────────────────────┘    │  └────────────────┘  │          │\n│                              └──────────────────────┘          │\n│                    ┌────────────────────┐                       │\n│                    │  Secure Monitor    │                       │\n│                    │      EL3 (ATF)     │                       │\n│                    └────────────────────┘                       │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Secure Boot Chain\n\n```\nBoot ROM (Immutable)\n    │\n    ▼ Verify signature\nBL1 (Primary Bootloader in ROM)\n    │\n    ▼ Verify signature\nBL2 (Trusted Boot Firmware)\n    │\n    ├─► BL31 (EL3 Runtime - ATF)\n    │\n    ├─► BL32 (Secure OS - OP-TEE) [Optional]\n    │\n    └─► BL33 (Normal World - U-Boot)\n            │\n            ▼ Verify signature\n        Linux Kernel + DTB\n            │\n            ▼ dm-verity\n        Root Filesystem\n```\n\n## ARM Trusted Firmware (ATF)\n\n### BL31 Services\n```c\n/* PSCI (Power State Coordination Interface) */\n#include \u003clib/psci/psci.h\u003e\n\nstatic int my_pwr_domain_on(u_register_t mpidr) {\n    unsigned int core = plat_core_pos_by_mpidr(mpidr);\n\n    /* Configure core reset vector */\n    mmio_write_32(RVBAR_ADDR(core), BL31_BASE);\n\n    /* Release core from reset */\n    mmio_setbits_32(PWR_CTRL_ADDR(core), CORE_PWRON);\n\n    return PSCI_E_SUCCESS;\n}\n\nstatic void my_pwr_domain_off(const psci_power_state_t *state) {\n    unsigned int core = plat_my_core_pos();\n\n    /* Disable GIC CPU interface */\n    gicv3_cpuif_disable(get_gic_data());\n\n    /* Power down core */\n    mmio_clrbits_32(PWR_CTRL_ADDR(core), CORE_PWRON);\n}\n\nstatic const plat_psci_ops_t my_psci_ops = {\n    .pwr_domain_on = my_pwr_domain_on,\n    .pwr_domain_off = my_pwr_domain_off,\n    .pwr_domain_suspend = my_pwr_domain_suspend,\n    .pwr_domain_on_finish = my_pwr_domain_on_finish,\n    .system_reset = my_system_reset,\n};\n```\n\n### SMC Handling\n```c\n/* Secure Monitor Call handler */\nstatic uintptr_t my_sip_smc_handler(\n    unsigned int smc_fid,\n    u_register_t x1, u_register_t x2,\n    u_register_t x3, u_register_t x4,\n    void *cookie, void *handle, u_register_t flags)\n{\n    switch (smc_fid) {\n    case MY_SIP_SVC_CALL_COUNT:\n        SMC_RET1(handle, MY_SIP_CALL_COUNT);\n\n    case MY_SIP_SVC_UID:\n        SMC_UUID_RET(handle, my_sip_svc_uid);\n\n    case MY_SIP_SVC_VERSION:\n        SMC_RET2(handle, MY_SVC_VERSION_MAJOR, MY_SVC_VERSION_MINOR);\n\n    case MY_SIP_DDR_FUNC:\n        return my_ddr_smc_handler(x1, x2, x3, x4, handle);\n\n    default:\n        WARN(\"Unimplemented SIP call: 0x%x\\n\", smc_fid);\n        SMC_RET1(handle, SMC_UNK);\n    }\n}\n\nDECLARE_RT_SVC(\n    my_sip_svc,\n    OEN_SIP_START,\n    OEN_SIP_END,\n    SMC_TYPE_FAST,\n    NULL,\n    my_sip_smc_handler\n);\n```\n\n## OP-TEE Integration\n\n### Trusted Application\n```c\n/* ta/my_ta/my_ta.c */\n#include \u003ctee_internal_api.h\u003e\n\n#define TA_MY_CMD_ENCRYPT  0\n#define TA_MY_CMD_DECRYPT  1\n\nTEE_Result TA_CreateEntryPoint(void) {\n    DMSG(\"TA created\\n\");\n    return TEE_SUCCESS;\n}\n\nTEE_Result TA_InvokeCommandEntryPoint(\n    void *sess_ctx, uint32_t cmd,\n    uint32_t param_types,\n    TEE_Param params[4])\n{\n    switch (cmd) {\n    case TA_MY_CMD_ENCRYPT:\n        return do_encrypt(param_types, params);\n    case TA_MY_CMD_DECRYPT:\n        return do_decrypt(param_types, params);\n    default:\n        return TEE_ERROR_NOT_SUPPORTED;\n    }\n}\n\nstatic TEE_Result do_encrypt(uint32_t param_types, TEE_Param params[4]) {\n    TEE_OperationHandle op;\n    TEE_ObjectHandle key;\n\n    /* Allocate crypto operation */\n    TEE_AllocateOperation(\u0026op, TEE_ALG_AES_CBC_NOPAD,\n                          TEE_MODE_ENCRYPT, 256);\n\n    /* Set key */\n    TEE_SetOperationKey(op, key);\n\n    /* Encrypt */\n    TEE_CipherUpdate(op, params[0].memref.buffer,\n                     params[0].memref.size,\n                     params[1].memref.buffer,\n                     \u0026params[1].memref.size);\n\n    TEE_FreeOperation(op);\n    return TEE_SUCCESS;\n}\n```\n\n### Linux OP-TEE Client\n```c\n#include \u003ctee_client_api.h\u003e\n\n#define TA_UUID { 0x12345678, 0x1234, 0x1234, \\\n                  { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0 } }\n\nint encrypt_data(void *input, size_t in_len, void *output, size_t *out_len) {\n    TEEC_Context ctx;\n    TEEC_Session sess;\n    TEEC_Operation op;\n    TEEC_UUID uuid = TA_UUID;\n    TEEC_Result res;\n\n    /* Initialize context */\n    res = TEEC_InitializeContext(NULL, \u0026ctx);\n    if (res != TEEC_SUCCESS)\n        return -1;\n\n    /* Open session with TA */\n    res = TEEC_OpenSession(\u0026ctx, \u0026sess, \u0026uuid,\n                           TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);\n    if (res != TEEC_SUCCESS)\n        goto err_ctx;\n\n    /* Prepare operation */\n    memset(\u0026op, 0, sizeof(op));\n    op.paramTypes = TEEC_PARAM_TYPES(\n        TEEC_MEMREF_TEMP_INPUT,\n        TEEC_MEMREF_TEMP_OUTPUT,\n        TEEC_NONE, TEEC_NONE);\n    op.params[0].tmpref.buffer = input;\n    op.params[0].tmpref.size = in_len;\n    op.params[1].tmpref.buffer = output;\n    op.params[1].tmpref.size = *out_len;\n\n    /* Invoke command */\n    res = TEEC_InvokeCommand(\u0026sess, TA_MY_CMD_ENCRYPT, \u0026op, NULL);\n    if (res == TEEC_SUCCESS)\n        *out_len = op.params[1].tmpref.size;\n\n    TEEC_CloseSession(\u0026sess);\nerr_ctx:\n    TEEC_FinalizeContext(\u0026ctx);\n    return (res == TEEC_SUCCESS) ? 0 : -1;\n}\n```\n\n## Secure Boot Key Management\n\n### FIT Image Signing\n```bash\n# Generate key pair\nopenssl genpkey -algorithm RSA -out dev.key -pkeyopt rsa_keygen_bits:2048\nopenssl req -batch -new -x509 -key dev.key -out dev.crt\n\n# Sign FIT image\nmkimage -f kernel.its -k keys/ -K u-boot.dtb -r kernel.itb\n```\n\n### Device Tree Key Node\n```dts\n/ {\n    signature {\n        key-dev {\n            required = \"image\";\n            algo = \"sha256,rsa2048\";\n            key-name-hint = \"dev\";\n        };\n    };\n};\n```\n\n## Hardware Security Module\n\n```c\n/* HSM register access (example) */\nstruct hsm_regs {\n    u32 ctrl;\n    u32 status;\n    u32 key_slot;\n    u32 data_in[8];\n    u32 data_out[8];\n    u32 iv[4];\n};\n\nstatic int hsm_aes_encrypt(struct hsm_dev *hsm,\n                           u8 *in, u8 *out, size_t len,\n                           u8 *iv, int key_slot) {\n    /* Select key slot */\n    writel(key_slot, hsm-\u003ebase + HSM_KEY_SLOT);\n\n    /* Load IV */\n    for (int i = 0; i \u003c 4; i++)\n        writel(((u32 *)iv)[i], hsm-\u003ebase + HSM_IV + i * 4);\n\n    /* Process data blocks */\n    for (size_t offset = 0; offset \u003c len; offset += 16) {\n        /* Load input block */\n        for (int i = 0; i \u003c 4; i++)\n            writel(((u32 *)(in + offset))[i],\n                   hsm-\u003ebase + HSM_DATA_IN + i * 4);\n\n        /* Start operation */\n        writel(HSM_OP_AES_CBC_ENC | HSM_START, hsm-\u003ebase + HSM_CTRL);\n\n        /* Wait for completion */\n        while (!(readl(hsm-\u003ebase + HSM_STATUS) \u0026 HSM_DONE))\n            cpu_relax();\n\n        /* Read output */\n        for (int i = 0; i \u003c 4; i++)\n            ((u32 *)(out + offset))[i] =\n                readl(hsm-\u003ebase + HSM_DATA_OUT + i * 4);\n    }\n\n    return 0;\n}\n```\n"])</script><script>self.__next_f.push([1,"19:T17d5,"])</script><script>self.__next_f.push([1,"\n# CMake Build System\n\n## Project Structure\n\n```\nmy-project/\n├── CMakeLists.txt              # Root CMake file\n├── cmake/\n│   ├── toolchain-aarch64.cmake # Cross-compile toolchain\n│   └── FindMyLib.cmake         # Custom find module\n├── src/\n│   ├── CMakeLists.txt\n│   ├── main.cpp\n│   └── driver/\n│       ├── CMakeLists.txt\n│       └── my_driver.cpp\n├── include/\n│   └── myproject/\n│       └── driver.h\n├── tests/\n│   ├── CMakeLists.txt\n│   └── test_driver.cpp\n└── third_party/\n    └── googletest/\n```\n\n## Root CMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.16)\n\nproject(MyProject\n    VERSION 1.0.0\n    DESCRIPTION \"SoC driver framework\"\n    LANGUAGES C CXX\n)\n\n# C++ standard\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n\n# Build type\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING \"Build type\" FORCE)\nendif()\n\n# Options\noption(BUILD_SHARED_LIBS \"Build shared libraries\" ON)\noption(BUILD_TESTS \"Build tests\" ON)\noption(ENABLE_SANITIZERS \"Enable ASan/UBSan\" OFF)\n\n# Compiler flags\nset(CMAKE_C_FLAGS_DEBUG \"-g -O0 -DDEBUG\")\nset(CMAKE_C_FLAGS_RELEASE \"-O2 -DNDEBUG\")\nset(CMAKE_CXX_FLAGS_DEBUG \"-g -O0 -DDEBUG\")\nset(CMAKE_CXX_FLAGS_RELEASE \"-O2 -DNDEBUG\")\n\nif(ENABLE_SANITIZERS)\n    add_compile_options(-fsanitize=address,undefined)\n    add_link_options(-fsanitize=address,undefined)\nendif()\n\n# Find packages\nfind_package(PkgConfig REQUIRED)\npkg_check_modules(LIBDRM REQUIRED libdrm)\n\n# Include directories\ninclude_directories(${CMAKE_SOURCE_DIR}/include)\n\n# Add subdirectories\nadd_subdirectory(src)\n\nif(BUILD_TESTS)\n    enable_testing()\n    add_subdirectory(third_party/googletest)\n    add_subdirectory(tests)\nendif()\n```\n\n## Cross-Compilation Toolchain\n\n```cmake\n# cmake/toolchain-aarch64.cmake\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR aarch64)\n\n# Specify cross-compiler\nset(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)\nset(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)\n\n# Sysroot (optional)\nset(CMAKE_SYSROOT /opt/sysroot/aarch64)\nset(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})\n\n# Search paths\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n\n# Target-specific flags\nset(CMAKE_C_FLAGS_INIT \"-march=armv8.2-a -mtune=cortex-a78\")\nset(CMAKE_CXX_FLAGS_INIT \"-march=armv8.2-a -mtune=cortex-a78\")\n```\n\n## Library CMakeLists.txt\n\n```cmake\n# src/driver/CMakeLists.txt\n\nadd_library(mydriver\n    my_driver.cpp\n    register_access.cpp\n    dma_engine.cpp\n)\n\ntarget_include_directories(mydriver\n    PUBLIC\n        $\u003cBUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include\u003e\n        $\u003cINSTALL_INTERFACE:include\u003e\n    PRIVATE\n        ${CMAKE_CURRENT_SOURCE_DIR}\n)\n\ntarget_link_libraries(mydriver\n    PUBLIC\n        ${LIBDRM_LIBRARIES}\n    PRIVATE\n        pthread\n)\n\ntarget_compile_definitions(mydriver\n    PRIVATE\n        DRIVER_VERSION=\"${PROJECT_VERSION}\"\n)\n\n# Platform-specific\nif(CMAKE_SYSTEM_PROCESSOR MATCHES \"aarch64\")\n    target_compile_definitions(mydriver PRIVATE PLATFORM_ARM64)\nelseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"x86_64\")\n    target_compile_definitions(mydriver PRIVATE PLATFORM_X86_64)\nendif()\n\n# Install rules\ninstall(TARGETS mydriver\n    EXPORT mydriverTargets\n    LIBRARY DESTINATION lib\n    ARCHIVE DESTINATION lib\n    RUNTIME DESTINATION bin\n    INCLUDES DESTINATION include\n)\n\ninstall(DIRECTORY ${CMAKE_SOURCE_DIR}/include/myproject\n    DESTINATION include\n)\n```\n\n## Custom Find Module\n\n```cmake\n# cmake/FindMyLib.cmake\n\nfind_path(MYLIB_INCLUDE_DIR\n    NAMES mylib/api.h\n    PATHS\n        /usr/include\n        /usr/local/include\n        ${MYLIB_ROOT}/include\n)\n\nfind_library(MYLIB_LIBRARY\n    NAMES mylib\n    PATHS\n        /usr/lib\n        /usr/local/lib\n        ${MYLIB_ROOT}/lib\n)\n\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(MyLib\n    REQUIRED_VARS MYLIB_LIBRARY MYLIB_INCLUDE_DIR\n)\n\nif(MYLIB_FOUND AND NOT TARGET MyLib::MyLib)\n    add_library(MyLib::MyLib UNKNOWN IMPORTED)\n    set_target_properties(MyLib::MyLib PROPERTIES\n        IMPORTED_LOCATION \"${MYLIB_LIBRARY}\"\n        INTERFACE_INCLUDE_DIRECTORIES \"${MYLIB_INCLUDE_DIR}\"\n    )\nendif()\n```\n\n## Test CMakeLists.txt\n\n```cmake\n# tests/CMakeLists.txt\n\nfind_package(GTest REQUIRED)\n\nadd_executable(test_driver\n    test_driver.cpp\n    test_dma.cpp\n)\n\ntarget_link_libraries(test_driver\n    PRIVATE\n        mydriver\n        GTest::GTest\n        GTest::Main\n)\n\ninclude(GoogleTest)\ngtest_discover_tests(test_driver)\n```\n\n## Common Build Commands\n\n```bash\n# Configure (out-of-source build)\nmkdir build \u0026\u0026 cd build\ncmake ..\n\n# Cross-compile\ncmake -DCMAKE_TOOLCHAIN_FILE=../cmake/toolchain-aarch64.cmake ..\n\n# Build with parallel jobs\ncmake --build . -j$(nproc)\n\n# Build specific target\ncmake --build . --target mydriver\n\n# Install\ncmake --install . --prefix /opt/myproject\n\n# Run tests\nctest --output-on-failure\n\n# Generate compile_commands.json (for IDE/LSP)\ncmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..\n```\n\n## Advanced Features\n\n### Generator Expressions\n```cmake\ntarget_compile_definitions(mylib\n    PUBLIC\n        $\u003c$\u003cCONFIG:Debug\u003e:DEBUG_BUILD\u003e\n        $\u003c$\u003cBOOL:${ENABLE_FEATURE}\u003e:FEATURE_ENABLED\u003e\n)\n\ntarget_link_libraries(mylib\n    PRIVATE\n        $\u003c$\u003cPLATFORM_ID:Linux\u003e:dl\u003e\n)\n```\n\n### Interface Library (Header-only)\n```cmake\nadd_library(myheaders INTERFACE)\ntarget_include_directories(myheaders\n    INTERFACE\n        $\u003cBUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include\u003e\n        $\u003cINSTALL_INTERFACE:include\u003e\n)\ntarget_compile_features(myheaders INTERFACE cxx_std_17)\n```\n\n### Precompiled Headers\n```cmake\ntarget_precompile_headers(mydriver\n    PRIVATE\n        \u003cvector\u003e\n        \u003cmemory\u003e\n        \u003ccstdint\u003e\n        \"driver.h\"\n)\n```\n\n### Fetching Dependencies\n```cmake\ninclude(FetchContent)\n\nFetchContent_Declare(\n    fmt\n    GIT_REPOSITORY https://github.com/fmtlib/fmt.git\n    GIT_TAG 9.1.0\n)\nFetchContent_MakeAvailable(fmt)\n\ntarget_link_libraries(myapp PRIVATE fmt::fmt)\n```\n"])</script><script>self.__next_f.push([1,"1a:T15f1,"])</script><script>self.__next_f.push([1,"\n# Git Workflows for Embedded\n\n## Kernel Development Workflow\n\n```\n                    ┌─────────────────────┐\n                    │   linux-stable      │\n                    │  (Linus's tree)     │\n                    └──────────┬──────────┘\n                               │\n            ┌──────────────────┼──────────────────┐\n            │                  │                  │\n    ┌───────▼───────┐  ┌───────▼───────┐  ┌──────▼──────┐\n    │  linux-next   │  │ vendor/kernel │  │ subsystem   │\n    │  (integration)│  │   (v5.15-soc) │  │ maintainer  │\n    └───────────────┘  └───────┬───────┘  └─────────────┘\n                               │\n                    ┌──────────▼──────────┐\n                    │   feature/ipu-v2    │\n                    │  (your dev branch)  │\n                    └─────────────────────┘\n```\n\n## Branch Strategy\n\n```bash\n# Long-running branches\nmain           # Production-ready code\ndevelop        # Integration branch\nrelease/v1.x   # Release maintenance\n\n# Short-lived branches\nfeature/xxx    # New features\nbugfix/xxx     # Bug fixes\nhotfix/xxx     # Critical production fixes\n\n# Vendor tracking\nvendor/kernel-5.15   # Vendor kernel baseline\nvendor/atf-2.8       # ARM Trusted Firmware\n```\n\n## Common Workflows\n\n### Rebasing Feature Branch\n```bash\n# Update local main\ngit checkout main\ngit fetch origin\ngit merge origin/main\n\n# Rebase feature branch\ngit checkout feature/my-driver\ngit rebase main\n\n# Resolve conflicts if any\ngit add \u003cresolved-files\u003e\ngit rebase --continue\n\n# Force push (only for private branches)\ngit push --force-with-lease origin feature/my-driver\n```\n\n### Cherry-picking Fixes\n```bash\n# Find commit in upstream\ngit log --oneline linux-stable/linux-5.15.y -- drivers/media/\n\n# Cherry-pick to vendor branch\ngit checkout vendor/kernel-5.15\ngit cherry-pick -x \u003ccommit-sha\u003e\n\n# Handle conflicts\ngit status\n# Edit conflicted files\ngit add \u003cfiles\u003e\ngit cherry-pick --continue\n```\n\n### Creating Patch Series\n```bash\n# Generate patches from branch\ngit format-patch main..feature/my-driver -o patches/\n\n# With cover letter\ngit format-patch main..feature/my-driver --cover-letter -o patches/\n\n# Apply patches\ngit am patches/*.patch\n\n# Apply with 3-way merge\ngit am -3 patches/*.patch\n```\n\n## Kernel Patch Submission\n\n```bash\n# Check patch\n./scripts/checkpatch.pl --strict patches/0001-*.patch\n\n# Get maintainers\n./scripts/get_maintainer.pl patches/0001-*.patch\n\n# Send patch (using git send-email)\ngit send-email \\\n    --to=maintainer@kernel.org \\\n    --cc=linux-media@vger.kernel.org \\\n    patches/0001-*.patch\n```\n\n### Proper Commit Message\n```\nsubsystem: component: Brief description (50 chars)\n\nDetailed explanation of what this commit does and why.\nWrap at 72 characters.\n\n- Bullet points for clarity if needed\n- Reference relevant specs or documentation\n\nFixes: abc1234def56 (\"broken commit subject\")\nSigned-off-by: Your Name \u003cyour.email@example.com\u003e\n```\n\n## Submodule Management\n\n```bash\n# Add submodule\ngit submodule add https://github.com/vendor/firmware.git external/firmware\ngit commit -m \"Add firmware submodule\"\n\n# Clone with submodules\ngit clone --recurse-submodules \u003crepo-url\u003e\n\n# Update submodules\ngit submodule update --init --recursive\n\n# Update to latest\ngit submodule update --remote external/firmware\ngit commit -m \"Update firmware to latest\"\n```\n\n## Git Bisect for Bug Finding\n\n```bash\n# Start bisect\ngit bisect start\n\n# Mark current as bad\ngit bisect bad HEAD\n\n# Mark known good commit\ngit bisect good v5.15\n\n# Test each commit, then mark\ngit bisect good  # or\ngit bisect bad\n\n# Automated bisect with script\ngit bisect run ./test-script.sh\n\n# When done\ngit bisect reset\n```\n\n## Worktree for Parallel Development\n\n```bash\n# Create worktree for different branch\ngit worktree add ../kernel-debug debug/my-issue\n\n# List worktrees\ngit worktree list\n\n# Remove worktree\ngit worktree remove ../kernel-debug\n```\n\n## Useful Git Configurations\n\n```bash\n# ~/.gitconfig\n[user]\n    name = Your Name\n    email = your.email@example.com\n    signingkey = ABCD1234\n\n[commit]\n    gpgsign = true\n\n[alias]\n    lg = log --oneline --graph --decorate\n    st = status -sb\n    co = checkout\n    br = branch\n    cp = cherry-pick\n    fp = format-patch\n\n[diff]\n    algorithm = histogram\n    colorMoved = default\n\n[merge]\n    conflictstyle = zdiff3\n\n[rebase]\n    autosquash = true\n    autostash = true\n\n[pull]\n    rebase = true\n\n[sendemail]\n    smtpserver = smtp.example.com\n    smtpserverport = 587\n    smtpencryption = tls\n    smtpuser = your.email@example.com\n```\n\n## Git Hooks for Quality\n\n```bash\n# .git/hooks/pre-commit (make executable)\n#!/bin/bash\n\n# Run checkpatch on staged changes\ngit diff --cached --name-only | grep -E '\\.(c|h)$' | while read file; do\n    ./scripts/checkpatch.pl --strict -f \"$file\"\n    if [ $? -ne 0 ]; then\n        echo \"checkpatch failed for $file\"\n        exit 1\n    fi\ndone\n```\n\n## Managing Large Binary Files\n\n```bash\n# Setup Git LFS\ngit lfs install\n\n# Track binary files\ngit lfs track \"*.bin\"\ngit lfs track \"*.elf\"\ngit lfs track \"firmware/*\"\n\n# Commit tracking file\ngit add .gitattributes\ngit commit -m \"Track binary files with LFS\"\n```\n"])</script><script>self.__next_f.push([1,"1b:T1eee,"])</script><script>self.__next_f.push([1,"\n# JTAG and Hardware Debugging\n\n## JTAG Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         Target SoC                               │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │\n│  │   CPU 0     │  │   CPU 1     │  │   Cortex-M  │             │\n│  │  (Cortex-A) │  │  (Cortex-A) │  │   (MCU)     │             │\n│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │\n│         │                │                │                      │\n│  ┌──────▼────────────────▼────────────────▼──────┐             │\n│  │              Debug Access Port (DAP)           │             │\n│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐       │             │\n│  │  │  APB-AP │  │  AXI-AP │  │  JTAG-AP│       │             │\n│  │  └─────────┘  └─────────┘  └─────────┘       │             │\n│  └──────────────────────┬────────────────────────┘             │\n│                         │                                       │\n│  ┌──────────────────────▼────────────────────────┐             │\n│  │                   JTAG TAP                     │             │\n│  │           TDI ─► TDO   TMS   TCK   TRST       │             │\n│  └────────────┬─────┬─────┬─────┬─────┬──────────┘             │\n└───────────────┼─────┼─────┼─────┼─────┼──────────────────────────┘\n                │     │     │     │     │\n         ┌──────▼─────▼─────▼─────▼─────▼──────┐\n         │           JTAG Debugger              │\n         │      (Lauterbach, Segger, etc.)     │\n         └──────────────────────────────────────┘\n```\n\n## OpenOCD Configuration\n\n### Target Configuration\n```tcl\n# myboard.cfg\n\n# Interface\nadapter driver ftdi\nftdi_vid_pid 0x0403 0x6010\nftdi_layout_init 0x0018 0x001b\nftdi_layout_signal nTRST -data 0x0010 -oe 0x0010\nftdi_layout_signal nSRST -data 0x0020 -oe 0x0020\n\nadapter speed 1000\n\n# SWD or JTAG\ntransport select jtag\n\n# Target\nset _CHIPNAME myboard\nset _DAP_TAPID 0x4BA00477\n\n# Create DAP\njtag newtap $_CHIPNAME cpu -expected-id $_DAP_TAPID \\\n    -irlen 4\n\ndap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu\n\n# Create targets\nset _TARGETNAME $_CHIPNAME.cpu\ntarget create ${_TARGETNAME}0 cortex_a -dap $_CHIPNAME.dap \\\n    -coreid 0 -dbgbase 0x80010000\ntarget create ${_TARGETNAME}1 cortex_a -dap $_CHIPNAME.dap \\\n    -coreid 1 -dbgbase 0x80012000\n\n# SMP configuration\ntarget smp ${_TARGETNAME}0 ${_TARGETNAME}1\n```\n\n### GDB Server Script\n```tcl\n# openocd-gdb.cfg\n\nsource [find myboard.cfg]\n\ninit\nhalt\n\n# Load symbols\ngdb_memory_map enable\ngdb_flash_program disable\ngdb_breakpoint_override hard\n\n# Listen on port 3333\ngdb_port 3333\n```\n\n## Lauterbach TRACE32 Scripts\n\n### System Reset and Attach\n```cmm\n; reset_attach.cmm\nSYStem.RESet\nSYStem.CPU CortexA78\nSYStem.CONFIG CoreNumber 4\nSYStem.CONFIG COREDEBUG.Base DAP:0x80010000 DAP:0x80012000 \\\n                              DAP:0x80014000 DAP:0x80016000\nSYStem.CONFIG CTI.Base DAP:0x80018000 DAP:0x8001A000 \\\n                       DAP:0x8001C000 DAP:0x8001E000\nSYStem.JtagClock 20MHz\nSYStem.Option TRST OFF\nSYStem.Mode Attach\n\nIF RUN()\n    Break\n\n; Load symbols\nData.LOAD.Elf vmlinux /NoCODE\n```\n\n### Memory Access\n```cmm\n; Memory read/write\nData.dump AD:0x80000000\nData.Set AD:0x80000000 %Long 0x12345678\n\n; Register access\nRegister.Set PC 0xFFFF0000\nRegister.view\n\n; Peripheral register dump\nPER.view %%a 0xFF000000--0xFF000FFF\n```\n\n### Trace Configuration\n```cmm\n; ETM trace setup\nETM.RESet\nETM.ON\nETM.TraceID 1\nETM.Timestamps ON\nETM.Stall ON\n\n; Configure trace buffer\nTrace.METHOD CAnalyzer\nTrace.SIZE 1G\nTrace.INIT\n\n; Start tracing\nGo\nWAIT !STATE.RUN()\nTrace.List\n```\n\n## GDB Commands for Embedded\n\n```bash\n# Connect to OpenOCD\n$ arm-none-eabi-gdb vmlinux\n(gdb) target extended-remote localhost:3333\n\n# Hardware breakpoints (limited number)\n(gdb) hbreak my_function\n(gdb) info breakpoints\n\n# Memory examination\n(gdb) x/10x 0x80000000     # 10 hex words\n(gdb) x/s 0x80001000       # String\n(gdb) x/10i $pc            # Instructions\n\n# Register access\n(gdb) info registers\n(gdb) info registers cpsr\n(gdb) set $x0 = 0x1234\n\n# Memory-mapped register access\n(gdb) set *0xFF000000 = 0x1\n(gdb) print/x *0xFF000000\n\n# Watchpoint (hardware)\n(gdb) watch *(int *)0x80002000\n(gdb) rwatch *(int *)0x80002000  # Read watch\n\n# Load binary\n(gdb) restore myapp.bin binary 0x80100000\n\n# Core file debugging\n(gdb) target core core.dump\n```\n\n## Linux Kernel Debugging\n\n### Kernel Debug Symbols\n```bash\n# Configure kernel\nCONFIG_DEBUG_INFO=y\nCONFIG_DEBUG_INFO_DWARF5=y\nCONFIG_GDB_SCRIPTS=y\nCONFIG_FRAME_POINTER=y\nCONFIG_KGDB=y\n```\n\n### KGDB Setup\n```bash\n# Kernel command line\nkgdbwait kgdboc=ttyS0,115200\n\n# Connect from host\n$ gdb vmlinux\n(gdb) set remotebaud 115200\n(gdb) target remote /dev/ttyUSB0\n```\n\n### GDB Kernel Scripts\n```bash\n# Load kernel helper scripts\n(gdb) add-auto-load-safe-path /path/to/linux/scripts/gdb\n\n# Use kernel-specific commands\n(gdb) lx-dmesg              # Show kernel log\n(gdb) lx-symbols            # Load module symbols\n(gdb) lx-lsmod              # List modules\n(gdb) lx-ps                 # List processes\n(gdb) lx-device-list-bus    # Show devices\n```\n\n## Debug Print / UART Logging\n\n```c\n/* Early printk for pre-console debug */\nstatic void __init my_early_write(const char *s, unsigned n) {\n    void __iomem *uart = (void __iomem *)UART_BASE;\n\n    while (n--) {\n        while (!(readl(uart + UART_LSR) \u0026 UART_LSR_THRE))\n            cpu_relax();\n        writel(*s++, uart + UART_THR);\n    }\n}\n\n/* Setup earlycon */\nEARLYCON_DECLARE(myuart, my_early_write);\n```\n\n### Dynamic Debug\n```bash\n# Enable all pr_debug in a file\necho \"file my_driver.c +p\" \u003e /sys/kernel/debug/dynamic_debug/control\n\n# Enable for specific function\necho \"func my_probe +p\" \u003e /sys/kernel/debug/dynamic_debug/control\n\n# Show all enabled debug points\ncat /sys/kernel/debug/dynamic_debug/control | grep \"=p\"\n```\n\n## Logic Analyzer Integration\n\n```c\n/* GPIO-based debug traces */\n#define DEBUG_GPIO_BASE    0xFF100000\n#define DEBUG_TRACE(x)     writel((x), debug_gpio_base + 0x4)\n\nvoid my_critical_function(void) {\n    DEBUG_TRACE(0x01);  /* Function entry */\n\n    /* ... processing ... */\n    DEBUG_TRACE(0x02);  /* Checkpoint 1 */\n\n    /* ... more processing ... */\n    DEBUG_TRACE(0x03);  /* Function exit */\n}\n```\n\n## Core Dump Analysis\n\n```bash\n# Generate crash dump (kdump configured)\necho c \u003e /proc/sysrq-trigger\n\n# Analyze with crash utility\n$ crash vmlinux vmcore\n\n# Common crash commands\ncrash\u003e bt          # Backtrace\ncrash\u003e log         # dmesg\ncrash\u003e ps          # Process list\ncrash\u003e vm          # Virtual memory info\ncrash\u003e dev         # Device list\ncrash\u003e struct task_struct \u003caddr\u003e\n```\n"])</script><script>self.__next_f.push([1,"1c:T1d02,"])</script><script>self.__next_f.push([1,"\n# Yocto Project \u0026 BitBake\n\n## Build System Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                    Yocto Build System                            │\n│  ┌─────────────────────────────────────────────────────────┐   │\n│  │                    BitBake Engine                        │   │\n│  └─────────────────────────┬───────────────────────────────┘   │\n│                            │                                    │\n│  ┌─────────────────────────▼───────────────────────────────┐   │\n│  │                     Metadata                             │   │\n│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐           │   │\n│  │  │  Recipes  │  │  Classes  │  │   Conf    │           │   │\n│  │  │  (.bb)    │  │  (.bbclass)│  │ (.conf)   │           │   │\n│  │  └───────────┘  └───────────┘  └───────────┘           │   │\n│  └─────────────────────────────────────────────────────────┘   │\n│                                                                 │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────────┐  │\n│  │poky (core)  │ │meta-openemb.│ │ meta-\u003cvendor\u003e (BSP)     │  │\n│  └─────────────┘ └─────────────┘ └─────────────────────────┘  │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Layer Structure\n\n```bash\nmeta-mylayer/\n├── conf/\n│   ├── layer.conf           # Layer configuration\n│   └── machine/\n│       └── myboard.conf     # Machine configuration\n├── recipes-bsp/\n│   ├── u-boot/\n│   │   └── u-boot_%.bbappend\n│   └── linux/\n│       └── linux-myboard_5.15.bb\n├── recipes-core/\n│   └── images/\n│       └── my-image.bb\n├── recipes-kernel/\n│   └── kernel-modules/\n│       └── my-driver_1.0.bb\n└── classes/\n    └── my-custom.bbclass\n```\n\n## Machine Configuration\n\n```bash\n# conf/machine/myboard.conf\n\n#@TYPE: Machine\n#@NAME: My Development Board\n#@DESCRIPTION: Machine configuration for my board\n\nDEFAULTTUNE ?= \"cortexa78\"\nrequire conf/machine/include/arm/armv8-2a/tune-cortexa78.inc\n\nSERIAL_CONSOLES = \"115200;ttyS0\"\n\nKERNEL_IMAGETYPE = \"Image\"\nKERNEL_DEVICETREE = \"myvendor/myboard.dtb\"\n\n# Bootloader\nPREFERRED_PROVIDER_virtual/bootloader = \"u-boot\"\nUBOOT_MACHINE = \"myboard_defconfig\"\nUBOOT_SUFFIX = \"bin\"\n\n# Kernel\nPREFERRED_PROVIDER_virtual/kernel = \"linux-myboard\"\nPREFERRED_VERSION_linux-myboard = \"5.15%\"\n\n# Graphics\nMACHINE_FEATURES += \"gpu\"\nPREFERRED_PROVIDER_virtual/egl = \"mesa\"\nPREFERRED_PROVIDER_virtual/libgles2 = \"mesa\"\n\n# Package architecture\nPACKAGE_EXTRA_ARCHS:append = \" myboard\"\n```\n\n## Recipe Development\n\n### Basic Recipe Structure\n```bash\n# recipes-kernel/kernel-modules/my-driver_1.0.bb\n\nSUMMARY = \"My custom kernel driver\"\nDESCRIPTION = \"A driver for my hardware IP\"\nLICENSE = \"GPL-2.0-only\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=xxxxx\"\n\ninherit module\n\nSRC_URI = \"git://github.com/myorg/mydriver.git;branch=main;protocol=https\"\nSRCREV = \"abc123def456...\"\n\nS = \"${WORKDIR}/git\"\n\n# Module build arguments\nEXTRA_OEMAKE:append = \" KDIR=${STAGING_KERNEL_DIR}\"\n\n# Install destination\ndo_install:append() {\n    install -d ${D}${sysconfdir}/modules-load.d\n    echo \"my-driver\" \u003e ${D}${sysconfdir}/modules-load.d/my-driver.conf\n}\n\nFILES:${PN} += \"${sysconfdir}/modules-load.d\"\n```\n\n### Recipe with CMake\n```bash\n# recipes-app/myapp/myapp_1.0.bb\n\nSUMMARY = \"My Application\"\nLICENSE = \"MIT\"\nLIC_FILES_CHKSUM = \"file://LICENSE;md5=xxxxx\"\n\ninherit cmake pkgconfig\n\nDEPENDS = \"opencv libdrm\"\n\nSRC_URI = \"file://src/\"\nS = \"${WORKDIR}/src\"\n\nEXTRA_OECMAKE = \" \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DENABLE_TESTS=OFF \\\n\"\n\ndo_install:append() {\n    install -d ${D}${bindir}\n    install -m 0755 ${B}/myapp ${D}${bindir}\n}\n```\n\n## bbappend Files\n\n```bash\n# recipes-bsp/u-boot/u-boot_%.bbappend\n\nFILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"\n\nSRC_URI += \" \\\n    file://0001-myboard-add-board-support.patch \\\n    file://myboard_defconfig \\\n\"\n\ndo_configure:prepend() {\n    cp ${WORKDIR}/myboard_defconfig ${S}/configs/\n}\n```\n\n## Image Recipe\n\n```bash\n# recipes-core/images/my-image.bb\n\nSUMMARY = \"My Custom Image\"\n\ninherit core-image\n\nIMAGE_FEATURES += \" \\\n    debug-tweaks \\\n    ssh-server-dropbear \\\n    package-management \\\n\"\n\nIMAGE_INSTALL += \" \\\n    kernel-modules \\\n    my-driver \\\n    myapp \\\n    devmem2 \\\n    i2c-tools \\\n    spitools \\\n    pciutils \\\n    usbutils \\\n    v4l-utils \\\n    gstreamer1.0 \\\n    gstreamer1.0-plugins-base \\\n    gstreamer1.0-plugins-good \\\n\"\n\n# Rootfs size\nIMAGE_ROOTFS_SIZE = \"1048576\"\nIMAGE_OVERHEAD_FACTOR = \"1.2\"\n\n# Enable systemd\nDISTRO_FEATURES:append = \" systemd\"\nVIRTUAL-RUNTIME_init_manager = \"systemd\"\n```\n\n## Custom Class\n\n```bash\n# classes/my-custom.bbclass\n\n# Common settings for all my packages\nINHIBIT_PACKAGE_STRIP = \"1\"\nINHIBIT_SYSROOT_STRIP = \"1\"\n\n# Add common dependencies\nDEPENDS += \"my-common-lib\"\n\n# Custom staging\nmy_custom_stage() {\n    install -d ${STAGING_INCDIR}/myvendor\n    install -m 644 ${S}/include/*.h ${STAGING_INCDIR}/myvendor/\n}\n\ndo_install:append() {\n    my_custom_stage\n}\n```\n\n## DevTool Workflow\n\n```bash\n# Create workspace from existing recipe\ndevtool modify linux-myboard\n\n# Make changes to source\ncd workspace/sources/linux-myboard\ngit checkout -b my-feature\n# ... edit code ...\ngit commit -a -m \"Add my feature\"\n\n# Build with changes\ndevtool build linux-myboard\n\n# Generate patches\ndevtool finish linux-myboard meta-mylayer\n```\n\n## Common Commands\n\n```bash\n# Build image\nbitbake my-image\n\n# Build specific package\nbitbake myapp\n\n# Clean and rebuild\nbitbake -c cleanall myapp \u0026\u0026 bitbake myapp\n\n# List tasks\nbitbake -c listtasks myapp\n\n# Show dependencies\nbitbake -g myapp \u0026\u0026 cat pn-buildlist\n\n# Enter devshell\nbitbake -c devshell myapp\n\n# Create SDK\nbitbake my-image -c populate_sdk\n\n# Debug\nbitbake -e myapp | grep ^SRC_URI\n```\n\n## Working with SDK\n\n```bash\n# Install SDK\n./poky-glibc-x86_64-my-image-cortexa78-myboard-toolchain-3.4.sh\n\n# Setup environment\nsource /opt/poky/3.4/environment-setup-cortexa78-poky-linux\n\n# Cross-compile\n$CC -o mytest mytest.c\n\n# CMake cross-compile\ncmake -DCMAKE_TOOLCHAIN_FILE=$OECORE_NATIVE_SYSROOT/usr/share/cmake/toolchain.cmake\n```\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ba2ac58ab1b61886.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"xBTWBRbXqt2oOshNbvapZ\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/notes/\",\"initialTree\":[\"\",{\"children\":[\"notes\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"notes\",{\"children\":[\"__PAGE__\",{},[\"$L4\",[\"$\",\"main\",null,{\"className\":\"min-h-screen pt-16 bg-white dark:bg-gray-900\",\"children\":[\"$\",\"$L5\",null,{\"categories\":[{\"name\":\"Hardware-ips\",\"slug\":\"hardware-ips\",\"notes\":[{\"slug\":\"i2c-protocol\",\"title\":\"I2C Protocol and Drivers\",\"date\":\"2024-01-18\",\"category\":\"Hardware IPs\",\"order\":1,\"filePath\":\"hardware-ips/i2c-protocol\"},{\"slug\":\"spi-protocol\",\"title\":\"SPI Protocol and Drivers\",\"date\":\"2024-01-22\",\"category\":\"Hardware IPs\",\"order\":2,\"filePath\":\"hardware-ips/spi-protocol\"},{\"slug\":\"mipi-csi2\",\"title\":\"MIPI CSI-2 Camera Interface\",\"date\":\"2024-02-01\",\"category\":\"Hardware IPs\",\"order\":3,\"filePath\":\"hardware-ips/mipi-csi2\"},{\"slug\":\"pcie-drivers\",\"title\":\"PCIe Driver Development\",\"date\":\"2024-02-08\",\"category\":\"Hardware IPs\",\"order\":4,\"filePath\":\"hardware-ips/pcie-drivers\"},{\"slug\":\"gic-controller\",\"title\":\"GIC (Generic Interrupt Controller)\",\"date\":\"2024-02-12\",\"category\":\"Hardware IPs\",\"order\":5,\"filePath\":\"hardware-ips/gic-controller\"},{\"slug\":\"mmu-smmu\",\"title\":\"MMU and SMMU/IOMMU\",\"date\":\"2024-02-18\",\"category\":\"Hardware IPs\",\"order\":6,\"filePath\":\"hardware-ips/mmu-smmu\"}],\"icon\":\"📝\"},{\"name\":\"Linux-kernel\",\"slug\":\"linux-kernel\",\"notes\":[{\"slug\":\"device-drivers\",\"title\":\"Linux Device Driver Development\",\"date\":\"2024-01-15\",\"category\":\"Linux Kernel\",\"order\":1,\"filePath\":\"linux-kernel/device-drivers\"},{\"slug\":\"v4l2-subsystem\",\"title\":\"V4L2 Camera Subsystem\",\"date\":\"2024-02-10\",\"category\":\"Linux Kernel\",\"order\":2,\"filePath\":\"linux-kernel/v4l2-subsystem\"},{\"slug\":\"device-tree\",\"title\":\"Device Tree and ACPI\",\"date\":\"2024-01-20\",\"category\":\"Linux Kernel\",\"order\":3,\"filePath\":\"linux-kernel/device-tree\"}],\"icon\":\"📝\"},{\"name\":\"Pre-silicon\",\"slug\":\"pre-silicon\",\"notes\":[{\"slug\":\"haps-prototyping\",\"title\":\"HAPS FPGA Prototyping\",\"date\":\"2024-01-20\",\"category\":\"Pre-Silicon\",\"order\":1,\"filePath\":\"pre-silicon/haps-prototyping\"},{\"slug\":\"palladium-emulation\",\"title\":\"Palladium Emulation\",\"date\":\"2024-01-22\",\"category\":\"Pre-Silicon\",\"order\":2,\"filePath\":\"pre-silicon/palladium-emulation\"},{\"slug\":\"first-silicon-bringup\",\"title\":\"First Silicon Bring-up\",\"date\":\"2024-02-05\",\"category\":\"Pre-Silicon\",\"order\":3,\"filePath\":\"pre-silicon/first-silicon-bringup\"},{\"slug\":\"validation-methodology\",\"title\":\"Validation Methodology\",\"date\":\"2024-02-15\",\"category\":\"Pre-Silicon\",\"order\":4,\"filePath\":\"pre-silicon/validation-methodology\"}],\"icon\":\"📝\"},{\"name\":\"Rtos\",\"slug\":\"rtos\",\"notes\":[{\"slug\":\"freertos-fundamentals\",\"title\":\"FreeRTOS Fundamentals\",\"date\":\"2024-01-25\",\"category\":\"RTOS\",\"order\":1,\"filePath\":\"rtos/freertos-fundamentals\"},{\"slug\":\"qnx-neutrino\",\"title\":\"QNX Neutrino RTOS\",\"date\":\"2024-02-05\",\"category\":\"RTOS\",\"order\":2,\"filePath\":\"rtos/qnx-neutrino\"},{\"slug\":\"zephyr-rtos\",\"title\":\"Zephyr RTOS Development\",\"date\":\"2024-02-15\",\"category\":\"RTOS\",\"order\":3,\"filePath\":\"rtos/zephyr-rtos\"}],\"icon\":\"📝\"},{\"name\":\"Soc-architecture\",\"slug\":\"soc-architecture\",\"notes\":[{\"slug\":\"soc-fundamentals\",\"title\":\"SoC Architecture Fundamentals\",\"date\":\"2024-01-12\",\"category\":\"SoC Architecture\",\"order\":1,\"filePath\":\"soc-architecture/soc-fundamentals\"},{\"slug\":\"ipu-architecture\",\"title\":\"IPU (Imaging Processing Unit)\",\"date\":\"2024-01-28\",\"category\":\"SoC Architecture\",\"order\":2,\"filePath\":\"soc-architecture/ipu-architecture\"},{\"slug\":\"trustzone-security\",\"title\":\"ARM TrustZone and Secure Boot\",\"date\":\"2024-02-20\",\"category\":\"SoC Architecture\",\"order\":3,\"filePath\":\"soc-architecture/trustzone-security\"}],\"icon\":\"📝\"},{\"name\":\"Tools\",\"slug\":\"tools\",\"notes\":[{\"slug\":\"yocto-bitbake\",\"title\":\"Yocto Project \u0026 BitBake\",\"date\":\"2024-01-08\",\"category\":\"Tools\",\"order\":1,\"filePath\":\"tools/yocto-bitbake\"},{\"slug\":\"jtag-debugging\",\"title\":\"JTAG and Hardware Debugging\",\"date\":\"2024-01-15\",\"category\":\"Tools\",\"order\":2,\"filePath\":\"tools/jtag-debugging\"},{\"slug\":\"cmake-build\",\"title\":\"CMake Build System\",\"date\":\"2024-02-01\",\"category\":\"Tools\",\"order\":3,\"filePath\":\"tools/cmake-build\"},{\"slug\":\"git-workflows\",\"title\":\"Git Workflows for Embedded\",\"date\":\"2024-02-10\",\"category\":\"Tools\",\"order\":4,\"filePath\":\"tools/git-workflows\"}],\"icon\":\"📝\"}],\"allNotesContent\":{\"hardware-ips/gic-controller\":{\"slug\":\"gic-controller\",\"title\":\"GIC (Generic Interrupt Controller)\",\"date\":\"2024-02-12\",\"category\":\"Hardware IPs\",\"order\":5,\"filePath\":\"hardware-ips/gic-controller\",\"content\":\"$6\"},\"hardware-ips/i2c-protocol\":{\"slug\":\"i2c-protocol\",\"title\":\"I2C Protocol and Drivers\",\"date\":\"2024-01-18\",\"category\":\"Hardware IPs\",\"order\":1,\"filePath\":\"hardware-ips/i2c-protocol\",\"content\":\"$7\"},\"hardware-ips/mipi-csi2\":{\"slug\":\"mipi-csi2\",\"title\":\"MIPI CSI-2 Camera Interface\",\"date\":\"2024-02-01\",\"category\":\"Hardware IPs\",\"order\":3,\"filePath\":\"hardware-ips/mipi-csi2\",\"content\":\"$8\"},\"hardware-ips/mmu-smmu\":{\"slug\":\"mmu-smmu\",\"title\":\"MMU and SMMU/IOMMU\",\"date\":\"2024-02-18\",\"category\":\"Hardware IPs\",\"order\":6,\"filePath\":\"hardware-ips/mmu-smmu\",\"content\":\"$9\"},\"hardware-ips/pcie-drivers\":{\"slug\":\"pcie-drivers\",\"title\":\"PCIe Driver Development\",\"date\":\"2024-02-08\",\"category\":\"Hardware IPs\",\"order\":4,\"filePath\":\"hardware-ips/pcie-drivers\",\"content\":\"$a\"},\"hardware-ips/spi-protocol\":{\"slug\":\"spi-protocol\",\"title\":\"SPI Protocol and Drivers\",\"date\":\"2024-01-22\",\"category\":\"Hardware IPs\",\"order\":2,\"filePath\":\"hardware-ips/spi-protocol\",\"content\":\"$b\"},\"linux-kernel/device-drivers\":{\"slug\":\"device-drivers\",\"title\":\"Linux Device Driver Development\",\"date\":\"2024-01-15\",\"category\":\"Linux Kernel\",\"order\":1,\"filePath\":\"linux-kernel/device-drivers\",\"content\":\"$c\"},\"linux-kernel/device-tree\":{\"slug\":\"device-tree\",\"title\":\"Device Tree and ACPI\",\"date\":\"2024-01-20\",\"category\":\"Linux Kernel\",\"order\":3,\"filePath\":\"linux-kernel/device-tree\",\"content\":\"$d\"},\"linux-kernel/v4l2-subsystem\":{\"slug\":\"v4l2-subsystem\",\"title\":\"V4L2 Camera Subsystem\",\"date\":\"2024-02-10\",\"category\":\"Linux Kernel\",\"order\":2,\"filePath\":\"linux-kernel/v4l2-subsystem\",\"content\":\"$e\"},\"pre-silicon/first-silicon-bringup\":{\"slug\":\"first-silicon-bringup\",\"title\":\"First Silicon Bring-up\",\"date\":\"2024-02-05\",\"category\":\"Pre-Silicon\",\"order\":3,\"filePath\":\"pre-silicon/first-silicon-bringup\",\"content\":\"$f\"},\"pre-silicon/haps-prototyping\":{\"slug\":\"haps-prototyping\",\"title\":\"HAPS FPGA Prototyping\",\"date\":\"2024-01-20\",\"category\":\"Pre-Silicon\",\"order\":1,\"filePath\":\"pre-silicon/haps-prototyping\",\"content\":\"$10\"},\"pre-silicon/palladium-emulation\":{\"slug\":\"palladium-emulation\",\"title\":\"Palladium Emulation\",\"date\":\"2024-01-22\",\"category\":\"Pre-Silicon\",\"order\":2,\"filePath\":\"pre-silicon/palladium-emulation\",\"content\":\"$11\"},\"pre-silicon/validation-methodology\":{\"slug\":\"validation-methodology\",\"title\":\"Validation Methodology\",\"date\":\"2024-02-15\",\"category\":\"Pre-Silicon\",\"order\":4,\"filePath\":\"pre-silicon/validation-methodology\",\"content\":\"$12\"},\"rtos/freertos-fundamentals\":{\"slug\":\"freertos-fundamentals\",\"title\":\"FreeRTOS Fundamentals\",\"date\":\"2024-01-25\",\"category\":\"RTOS\",\"order\":1,\"filePath\":\"rtos/freertos-fundamentals\",\"content\":\"$13\"},\"rtos/qnx-neutrino\":{\"slug\":\"qnx-neutrino\",\"title\":\"QNX Neutrino RTOS\",\"date\":\"2024-02-05\",\"category\":\"RTOS\",\"order\":2,\"filePath\":\"rtos/qnx-neutrino\",\"content\":\"$14\"},\"rtos/zephyr-rtos\":{\"slug\":\"zephyr-rtos\",\"title\":\"Zephyr RTOS Development\",\"date\":\"2024-02-15\",\"category\":\"RTOS\",\"order\":3,\"filePath\":\"rtos/zephyr-rtos\",\"content\":\"$15\"},\"soc-architecture/ipu-architecture\":{\"slug\":\"ipu-architecture\",\"title\":\"IPU (Imaging Processing Unit)\",\"date\":\"2024-01-28\",\"category\":\"SoC Architecture\",\"order\":2,\"filePath\":\"soc-architecture/ipu-architecture\",\"content\":\"$16\"},\"soc-architecture/soc-fundamentals\":{\"slug\":\"soc-fundamentals\",\"title\":\"SoC Architecture Fundamentals\",\"date\":\"2024-01-12\",\"category\":\"SoC Architecture\",\"order\":1,\"filePath\":\"soc-architecture/soc-fundamentals\",\"content\":\"$17\"},\"soc-architecture/trustzone-security\":{\"slug\":\"trustzone-security\",\"title\":\"ARM TrustZone and Secure Boot\",\"date\":\"2024-02-20\",\"category\":\"SoC Architecture\",\"order\":3,\"filePath\":\"soc-architecture/trustzone-security\",\"content\":\"$18\"},\"tools/cmake-build\":{\"slug\":\"cmake-build\",\"title\":\"CMake Build System\",\"date\":\"2024-02-01\",\"category\":\"Tools\",\"order\":3,\"filePath\":\"tools/cmake-build\",\"content\":\"$19\"},\"tools/git-workflows\":{\"slug\":\"git-workflows\",\"title\":\"Git Workflows for Embedded\",\"date\":\"2024-02-10\",\"category\":\"Tools\",\"order\":4,\"filePath\":\"tools/git-workflows\",\"content\":\"$1a\"},\"tools/jtag-debugging\":{\"slug\":\"jtag-debugging\",\"title\":\"JTAG and Hardware Debugging\",\"date\":\"2024-01-15\",\"category\":\"Tools\",\"order\":2,\"filePath\":\"tools/jtag-debugging\",\"content\":\"$1b\"},\"tools/yocto-bitbake\":{\"slug\":\"yocto-bitbake\",\"title\":\"Yocto Project \u0026 BitBake\",\"date\":\"2024-01-08\",\"category\":\"Tools\",\"order\":1,\"filePath\":\"tools/yocto-bitbake\",\"content\":\"$1c\"}},\"initialNotePath\":\"hardware-ips/i2c-protocol\"}]}],null]]},[\"$\",\"$L1d\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"notes\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L1e\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":null}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"script\",null,{\"type\":\"application/ld+json\",\"dangerouslySetInnerHTML\":{\"__html\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Ding Yunliang\\\",\\\"url\\\":\\\"https://dingyunliang.github.io\\\",\\\"jobTitle\\\":\\\"Full-Stack Developer\\\",\\\"description\\\":\\\"Full-Stack Developer specializing in React, Next.js, TypeScript, and Node.js\\\",\\\"sameAs\\\":[\\\"https://github.com/dingyunliang\\\",\\\"https://www.linkedin.com/in/yunliang-ding\\\",\\\"https://twitter.com/dingyunliang\\\"],\\\"knowsAbout\\\":[\\\"Web Development\\\",\\\"React\\\",\\\"Next.js\\\",\\\"TypeScript\\\",\\\"Node.js\\\",\\\"JavaScript\\\",\\\"Tailwind CSS\\\"]}\"}}]}],[\"$\",\"body\",null,{\"className\":\"bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300\",\"children\":[\"$\",\"$L1f\",null,{\"children\":[[\"$\",\"$L20\",null,{}],[\"$\",\"main\",null,{\"role\":\"main\",\"children\":[\"$\",\"$L1d\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L1e\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"footer\",null,{\"className\":\"bg-gray-900 dark:bg-gray-950 text-white transition-colors duration-300\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"py-12 grid grid-cols-1 md:grid-cols-3 gap-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"$L21\",null,{\"href\":\"/\",\"className\":\"flex items-center space-x-2\",\"children\":[[\"$\",\"div\",null,{\"className\":\"w-10 h-10 bg-gradient-to-br from-primary-400 to-primary-600 rounded-lg flex items-center justify-center\",\"children\":[\"$\",\"span\",null,{\"className\":\"text-white font-bold text-xl\",\"children\":\"SD\"}]}],[\"$\",\"span\",null,{\"className\":\"font-bold text-xl\",\"children\":\"Ding Yunliang\"}]]}],[\"$\",\"p\",null,{\"className\":\"text-gray-400 max-w-xs\",\"children\":\"Building digital experiences that make a difference. Let's create something amazing together.\"}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"font-semibold text-lg mb-4\",\"children\":\"Quick Links\"}],[\"$\",\"ul\",null,{\"className\":\"space-y-2\",\"children\":[[\"$\",\"li\",\"Home\",{\"children\":[\"$\",\"$L21\",null,{\"href\":\"#home\",\"className\":\"text-gray-400 hover:text-white transition-colors\",\"children\":\"Home\"}]}],[\"$\",\"li\",\"About\",{\"children\":[\"$\",\"$L21\",null,{\"href\":\"#about\",\"className\":\"text-gray-400 hover:text-white transition-colors\",\"children\":\"About\"}]}],[\"$\",\"li\",\"Projects\",{\"children\":[\"$\",\"$L21\",null,{\"href\":\"#projects\",\"className\":\"text-gray-400 hover:text-white transition-colors\",\"children\":\"Projects\"}]}],[\"$\",\"li\",\"Contact\",{\"children\":[\"$\",\"$L21\",null,{\"href\":\"#contact\",\"className\":\"text-gray-400 hover:text-white transition-colors\",\"children\":\"Contact\"}]}]]}]]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"font-semibold text-lg mb-4\",\"children\":\"Get in Touch\"}],[\"$\",\"p\",null,{\"className\":\"text-gray-400 mb-4\",\"children\":\"Feel free to reach out for collaborations or just a friendly hello!\"}],[\"$\",\"div\",null,{\"className\":\"flex space-x-4\",\"children\":[[\"$\",\"$L21\",\"GitHub\",{\"href\":\"https://github.com\",\"className\":\"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200\",\"aria-label\":\"GitHub\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":[\"$\",\"svg\",null,{\"className\":\"w-5 h-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z\"}]}]}],[\"$\",\"$L21\",\"LinkedIn\",{\"href\":\"https://www.linkedin.com/in/yunliang-ding\",\"className\":\"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200\",\"aria-label\":\"LinkedIn\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":[\"$\",\"svg\",null,{\"className\":\"w-5 h-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"d\":\"M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z\"}]}]}],[\"$\",\"$L21\",\"Twitter\",{\"href\":\"https://twitter.com\",\"className\":\"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200\",\"aria-label\":\"Twitter\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":[\"$\",\"svg\",null,{\"className\":\"w-5 h-5\",\"fill\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"d\":\"M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z\"}]}]}],[\"$\",\"$L21\",\"Email\",{\"href\":\"mailto:yunliang.ding@gmail.com\",\"className\":\"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200\",\"aria-label\":\"Email\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":[\"$\",\"svg\",null,{\"className\":\"w-5 h-5\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z\"}]}]}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"border-t border-gray-800 dark:border-gray-700 py-6 flex flex-col sm:flex-row justify-between items-center gap-4\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-gray-400 text-sm\",\"children\":[\"© \",2026,\" Ding Yunliang. All rights reserved.\"]}],[\"$\",\"p\",null,{\"className\":\"text-gray-500 text-sm\",\"children\":[\"Built with\",\" \",[\"$\",\"span\",null,{\"className\":\"text-red-500\",\"children\":\"❤\"}],\" using Next.js \u0026 Tailwind CSS\"]}]]}]]}]}]]}]}]]}],null]],\"initialHead\":[false,\"$L22\"],\"globalErrorComponent\":\"$23\"}]]\n"])</script><script>self.__next_f.push([1,"22:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: light)\",\"content\":\"#ffffff\"}],[\"$\",\"meta\",\"2\",{\"name\":\"theme-color\",\"media\":\"(prefers-color-scheme: dark)\",\"content\":\"#111827\"}],[\"$\",\"meta\",\"3\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"4\",{\"children\":\"Learning Notes | Ding Yunliang\"}],[\"$\",\"meta\",\"5\",{\"name\":\"description\",\"content\":\"Personal learning notes on JavaScript, CSS, React, Cloudflare, and other web development topics.\"}],[\"$\",\"link\",\"6\",{\"rel\":\"author\",\"href\":\"https://dingyunliang.github.io\"}],[\"$\",\"meta\",\"7\",{\"name\":\"author\",\"content\":\"Ding Yunliang\"}],[\"$\",\"link\",\"8\",{\"rel\":\"manifest\",\"href\":\"/site.webmanifest\"}],[\"$\",\"meta\",\"9\",{\"name\":\"keywords\",\"content\":\"Full-Stack Developer,Web Developer,React Developer,Next.js,TypeScript,Node.js,Portfolio,Ding Yunliang\"}],[\"$\",\"meta\",\"10\",{\"name\":\"creator\",\"content\":\"Ding Yunliang\"}],[\"$\",\"meta\",\"11\",{\"name\":\"publisher\",\"content\":\"Ding Yunliang\"}],[\"$\",\"meta\",\"12\",{\"name\":\"robots\",\"content\":\"index, follow\"}],[\"$\",\"meta\",\"13\",{\"name\":\"googlebot\",\"content\":\"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1\"}],[\"$\",\"meta\",\"14\",{\"name\":\"category\",\"content\":\"technology\"}],[\"$\",\"link\",\"15\",{\"rel\":\"canonical\",\"href\":\"https://dingyunliang.github.io\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:title\",\"content\":\"Ding Yunliang | Full-Stack Developer \u0026 Creative Problem Solver\"}],[\"$\",\"meta\",\"17\",{\"property\":\"og:description\",\"content\":\"Explore the portfolio of Ding Yunliang - a Full-Stack Developer crafting beautiful, performant web applications with React, Next.js, and modern technologies.\"}],[\"$\",\"meta\",\"18\",{\"property\":\"og:url\",\"content\":\"https://dingyunliang.github.io\"}],[\"$\",\"meta\",\"19\",{\"property\":\"og:site_name\",\"content\":\"Ding Yunliang Portfolio\"}],[\"$\",\"meta\",\"20\",{\"property\":\"og:locale\",\"content\":\"en_US\"}],[\"$\",\"meta\",\"21\",{\"property\":\"og:image\",\"content\":\"http://localhost:3000/og-image.jpg\"}],[\"$\",\"meta\",\"22\",{\"property\":\"og:image:width\",\"content\":\"1200\"}],[\"$\",\"meta\",\"23\",{\"property\":\"og:image:height\",\"content\":\"630\"}],[\"$\",\"meta\",\"24\",{\"property\":\"og:image:alt\",\"content\":\"Ding Yunliang - Full-Stack Developer Portfolio\"}],[\"$\",\"meta\",\"25\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"26\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"27\",{\"name\":\"twitter:creator\",\"content\":\"@dingyunliang\"}],[\"$\",\"meta\",\"28\",{\"name\":\"twitter:title\",\"content\":\"Ding Yunliang | Full-Stack Developer\"}],[\"$\",\"meta\",\"29\",{\"name\":\"twitter:description\",\"content\":\"Full-Stack Developer specializing in React, Next.js, and Node.js. View my portfolio and let's build something amazing together.\"}],[\"$\",\"meta\",\"30\",{\"name\":\"twitter:image\",\"content\":\"http://localhost:3000/og-image.jpg\"}],[\"$\",\"link\",\"31\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon-16x16.png\"}],[\"$\",\"link\",\"32\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\"}],[\"$\",\"link\",\"33\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-touch-icon.png\"}]]\n"])</script><script>self.__next_f.push([1,"4:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>