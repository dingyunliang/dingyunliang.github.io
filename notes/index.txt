2:I[33343,["102","static/chunks/102-53c00f3c219cee5b.js","531","static/chunks/531-91565e0f279205d9.js","131","static/chunks/131-2ce19c52dc066886.js","151","static/chunks/app/notes/page-b381320519e05c08.js"],""]
1a:I[5613,[],""]
1b:I[31778,[],""]
1c:I[26713,["250","static/chunks/250-61453098be97c510.js","185","static/chunks/app/layout-95d959a8dba1d822.js"],"ThemeProvider"]
1d:I[8718,["250","static/chunks/250-61453098be97c510.js","185","static/chunks/app/layout-95d959a8dba1d822.js"],""]
1e:I[25250,["250","static/chunks/250-61453098be97c510.js","185","static/chunks/app/layout-95d959a8dba1d822.js"],""]
3:T1add,
# GIC (Generic Interrupt Controller)

## GIC Architecture

```
┌────────────────────────────────────────────────────────────┐
│                        GIC-600                              │
│  ┌────────────────────────────────────────────────────┐   │
│  │                   Distributor                       │   │
│  │          (Interrupt routing & prioritization)       │   │
│  └────────────────────────┬───────────────────────────┘   │
│                           │                                │
│  ┌──────────────┬─────────┴──────────┬──────────────┐    │
│  │              │                    │              │    │
│  │ Redistributor│   Redistributor   │Redistributor │    │
│  │   (CPU0)     │     (CPU1)        │   (CPU2)     │    │
│  └──────┬───────┴────────┬──────────┴──────┬───────┘    │
│         │                │                  │            │
│  ┌──────▼───────┐ ┌──────▼───────┐ ┌───────▼──────┐    │
│  │ CPU Interface│ │CPU Interface │ │CPU Interface │    │
│  │    (CPU0)    │ │   (CPU1)     │ │   (CPU2)     │    │
│  └──────────────┘ └──────────────┘ └──────────────┘    │
└────────────────────────────────────────────────────────────┘
         │                │                  │
         ▼                ▼                  ▼
      Core 0           Core 1            Core 2
```

## Interrupt Types

| Type | Range | Description |
|------|-------|-------------|
| SGI | 0-15 | Software Generated Interrupts (IPI) |
| PPI | 16-31 | Private Peripheral Interrupts |
| SPI | 32-1019 | Shared Peripheral Interrupts |
| LPI | 8192+ | Locality-specific Peripheral Interrupts |

## GIC Driver (Linux)

### Device Tree Configuration
```dts
gic: interrupt-controller@fee00000 {
    compatible = "arm,gic-v3";
    #interrupt-cells = <3>;
    #address-cells = <2>;
    #size-cells = <2>;
    ranges;
    interrupt-controller;

    reg = <0x0 0xfee00000 0 0x10000>,   /* GICD */
          <0x0 0xfef00000 0 0xc0000>,   /* GICR */
          <0x0 0xfff00000 0 0x10000>,   /* GICC */
          <0x0 0xfff10000 0 0x10000>,   /* GICH */
          <0x0 0xfff20000 0 0x10000>;   /* GICV */

    interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;

    its: msi-controller@fee20000 {
        compatible = "arm,gic-v3-its";
        reg = <0x0 0xfee20000 0x0 0x20000>;
        msi-controller;
        #msi-cells = <1>;
    };
};
```

### Using GIC in Device Driver
```c
#include <linux/interrupt.h>
#include <linux/of_irq.h>

static int my_driver_probe(struct platform_device *pdev) {
    int irq, ret;
    struct device *dev = &pdev->dev;

    // Get IRQ from device tree
    irq = platform_get_irq(pdev, 0);
    if (irq < 0)
        return irq;

    // Request threaded IRQ
    ret = devm_request_threaded_irq(dev, irq,
                                     my_hard_isr,
                                     my_thread_handler,
                                     IRQF_SHARED,
                                     "my-device",
                                     priv);

    return ret;
}
```

### IRQ Domain and Mapping
```c
#include <linux/irqdomain.h>

struct my_irq_chip_data {
    void __iomem *base;
    struct irq_domain *domain;
    spinlock_t lock;
};

static void my_irq_mask(struct irq_data *d) {
    struct my_irq_chip_data *data = irq_data_get_irq_chip_data(d);
    u32 reg;

    spin_lock(&data->lock);
    reg = readl(data->base + IRQ_ENABLE);
    reg &= ~BIT(d->hwirq);
    writel(reg, data->base + IRQ_ENABLE);
    spin_unlock(&data->lock);
}

static void my_irq_unmask(struct irq_data *d) {
    struct my_irq_chip_data *data = irq_data_get_irq_chip_data(d);
    u32 reg;

    spin_lock(&data->lock);
    reg = readl(data->base + IRQ_ENABLE);
    reg |= BIT(d->hwirq);
    writel(reg, data->base + IRQ_ENABLE);
    spin_unlock(&data->lock);
}

static struct irq_chip my_irq_chip = {
    .name = "my-irq",
    .irq_mask = my_irq_mask,
    .irq_unmask = my_irq_unmask,
    .irq_ack = my_irq_ack,
    .irq_set_type = my_irq_set_type,
};

static int my_irq_domain_map(struct irq_domain *domain,
                              unsigned int virq,
                              irq_hw_number_t hwirq) {
    struct my_irq_chip_data *data = domain->host_data;

    irq_set_chip_and_handler(virq, &my_irq_chip, handle_level_irq);
    irq_set_chip_data(virq, data);
    irq_set_noprobe(virq);

    return 0;
}

static const struct irq_domain_ops my_irq_domain_ops = {
    .map = my_irq_domain_map,
    .xlate = irq_domain_xlate_twocell,
};
```

## IPI (Inter-Processor Interrupt)

```c
// Send IPI to specific CPU
#include <linux/smp.h>

// Using arch-specific call
void send_ipi_to_cpu(int cpu) {
    smp_call_function_single(cpu, my_ipi_handler, data, wait);
}

// Send to all CPUs
smp_call_function(my_handler, data, wait);

// Low-level GIC IPI (SGI)
// For custom bare-metal or hypervisor use
static inline void gic_send_sgi(u8 sgi_id, u64 target_list) {
    u64 val = ((target_list & 0xFFFF) << 0) |
              ((u64)sgi_id << 24);

    // Write to ICC_SGI1R_EL1
    write_sysreg_s(val, SYS_ICC_SGI1R_EL1);
    isb();
}
```

## Affinity and CPU Binding

```c
// Set IRQ affinity
#include <linux/interrupt.h>
#include <linux/cpumask.h>

int set_irq_affinity(int irq, int cpu) {
    cpumask_t mask;

    cpumask_clear(&mask);
    cpumask_set_cpu(cpu, &mask);

    return irq_set_affinity(irq, &mask);
}

// Set affinity hint (for performance)
irq_set_affinity_hint(irq, cpumask_of(cpu));

// Read current affinity
const struct cpumask *mask = irq_get_affinity_mask(irq);
```

## Debug and Status

```bash
# View interrupt statistics
cat /proc/interrupts

# View IRQ affinity
cat /proc/irq/<irq>/smp_affinity

# Set affinity (hex mask)
echo 4 > /proc/irq/<irq>/smp_affinity  # CPU 2 only

# View effective affinity
cat /proc/irq/<irq>/effective_affinity

# IRQ debug info
cat /sys/kernel/debug/irq/<irq>/chip_name
cat /sys/kernel/debug/irq/<irq>/actions
```
4:T13c6,
# I2C Protocol and Drivers

## I2C Protocol Overview

```
Master                           Slave (0x50)
  │                                  │
  │◄──────── SDA (bidirectional) ────►│
  │◄──────── SCL (clock) ────────────►│
  │                                  │

Start → Address (7/10-bit) → R/W → ACK → Data → ACK → Stop
```

### Timing Diagram
```
SCL:  ▔▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔╲__╱▔▔▔
SDA:  ▔▔╲_____A6____A5____A4____A3____A2____A1____A0____R/W__╱▔
          │                                              │
        Start                                          Stop
```

## Linux I2C Subsystem

### I2C Adapter Driver
```c
#include <linux/i2c.h>
#include <linux/platform_device.h>

struct my_i2c {
    void __iomem *base;
    struct i2c_adapter adapter;
    struct clk *clk;
    int irq;
    struct completion xfer_done;
};

static int my_i2c_xfer(struct i2c_adapter *adap,
                       struct i2c_msg *msgs, int num) {
    struct my_i2c *i2c = i2c_get_adapdata(adap);
    int i, ret;

    for (i = 0; i < num; i++) {
        reinit_completion(&i2c->xfer_done);

        // Set slave address
        writel(msgs[i].addr, i2c->base + I2C_ADDR);

        // Set transfer direction
        if (msgs[i].flags & I2C_M_RD)
            writel(I2C_READ, i2c->base + I2C_CTRL);
        else
            writel(I2C_WRITE, i2c->base + I2C_CTRL);

        // Set data length
        writel(msgs[i].len, i2c->base + I2C_LEN);

        // Start transfer
        writel(I2C_START, i2c->base + I2C_CMD);

        // Wait for completion
        ret = wait_for_completion_timeout(&i2c->xfer_done,
                                          msecs_to_jiffies(1000));
        if (!ret)
            return -ETIMEDOUT;
    }

    return num;
}

static u32 my_i2c_func(struct i2c_adapter *adap) {
    return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
}

static const struct i2c_algorithm my_i2c_algo = {
    .master_xfer = my_i2c_xfer,
    .functionality = my_i2c_func,
};

static irqreturn_t my_i2c_isr(int irq, void *dev_id) {
    struct my_i2c *i2c = dev_id;
    u32 status = readl(i2c->base + I2C_STATUS);

    if (status & I2C_COMPLETE) {
        writel(I2C_COMPLETE, i2c->base + I2C_STATUS);
        complete(&i2c->xfer_done);
    }

    return IRQ_HANDLED;
}

static int my_i2c_probe(struct platform_device *pdev) {
    struct my_i2c *i2c;
    struct resource *res;

    i2c = devm_kzalloc(&pdev->dev, sizeof(*i2c), GFP_KERNEL);

    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    i2c->base = devm_ioremap_resource(&pdev->dev, res);

    i2c->clk = devm_clk_get(&pdev->dev, NULL);
    clk_prepare_enable(i2c->clk);

    i2c->irq = platform_get_irq(pdev, 0);
    devm_request_irq(&pdev->dev, i2c->irq, my_i2c_isr, 0,
                     "my-i2c", i2c);

    init_completion(&i2c->xfer_done);

    i2c->adapter.owner = THIS_MODULE;
    i2c->adapter.algo = &my_i2c_algo;
    i2c->adapter.dev.parent = &pdev->dev;
    i2c->adapter.dev.of_node = pdev->dev.of_node;
    i2c_set_adapdata(&i2c->adapter, i2c);

    return i2c_add_adapter(&i2c->adapter);
}
```

### I2C Client Driver (Sensor)
```c
#include <linux/i2c.h>
#include <linux/regmap.h>

struct my_sensor {
    struct i2c_client *client;
    struct regmap *regmap;
};

static const struct regmap_config my_regmap_config = {
    .reg_bits = 8,
    .val_bits = 8,
    .max_register = 0xFF,
    .cache_type = REGCACHE_RBTREE,
};

static int my_sensor_read_temp(struct my_sensor *sensor, int *temp) {
    unsigned int val;
    int ret;

    ret = regmap_read(sensor->regmap, TEMP_REG, &val);
    if (ret)
        return ret;

    *temp = (int)(val * 1000) / 256;  // Convert to milli-degrees
    return 0;
}

static int my_sensor_probe(struct i2c_client *client) {
    struct my_sensor *sensor;

    sensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);
    sensor->client = client;

    sensor->regmap = devm_regmap_init_i2c(client, &my_regmap_config);
    if (IS_ERR(sensor->regmap))
        return PTR_ERR(sensor->regmap);

    i2c_set_clientdata(client, sensor);

    return 0;
}

static const struct i2c_device_id my_sensor_id[] = {
    { "my-sensor", 0 },
    { }
};
MODULE_DEVICE_TABLE(i2c, my_sensor_id);

static const struct of_device_id my_sensor_of_match[] = {
    { .compatible = "vendor,my-sensor" },
    { }
};
MODULE_DEVICE_TABLE(of, my_sensor_of_match);

static struct i2c_driver my_sensor_driver = {
    .driver = {
        .name = "my-sensor",
        .of_match_table = my_sensor_of_match,
    },
    .probe = my_sensor_probe,
    .id_table = my_sensor_id,
};
module_i2c_driver(my_sensor_driver);
```

## I2C Debug Commands

```bash
# List I2C buses
i2cdetect -l

# Scan bus for devices
i2cdetect -y 0

# Read register
i2cget -y 0 0x50 0x00

# Write register
i2cset -y 0 0x50 0x00 0xFF

# Dump all registers
i2cdump -y 0 0x50

# Transfer with multiple messages
i2ctransfer -y 0 w2@0x50 0x00 0x10 r4
```
5:T1ce9,
# MIPI CSI-2 Camera Interface

## CSI-2 Architecture

```
┌─────────────────┐         ┌─────────────────┐
│  Image Sensor   │         │  SoC CSI-2 RX   │
│                 │         │                 │
│  ┌───────────┐  │   D-PHY │  ┌───────────┐  │
│  │   ISP     │  │◄────────┤  │   D-PHY   │  │
│  └───────────┘  │  Clock  │  │   RX      │  │
│       │        │  Lane    │  └───────────┘  │
│  ┌───────────┐  │         │       │        │
│  │   CSI-2   │──┼─────────┼──►┌───────────┐  │
│  │   TX      │  │  Data   │  │   CSI-2   │  │
│  └───────────┘  │  Lanes  │  │   Parser  │  │
│       │        │  (1-4)   │  └───────────┘  │
│  ┌───────────┐  │         │       │        │
│  │   D-PHY   │──┼─────────┼──►┌───────────┐  │
│  │   TX      │  │         │  │   DMA     │  │
│  └───────────┘  │         │  └───────────┘  │
└─────────────────┘         └─────────────────┘
```

## CSI-2 Packet Format

### Short Packet (Frame/Line Sync)
```
┌────────┬────────┬────────────┬────────┐
│ SoT    │ Data ID│ Data Field │ ECC    │
│ (D-PHY)│ (8-bit)│  (16-bit)  │ (8-bit)│
└────────┴────────┴────────────┴────────┘
```

### Long Packet (Pixel Data)
```
┌────────┬────────┬───────────┬─────────────────┬──────────┐
│ SoT    │ Data ID│ Word Count│    Payload      │ Checksum │
│ (D-PHY)│ (8-bit)│  (16-bit) │   (Variable)    │  (16-bit)│
└────────┴────────┴───────────┴─────────────────┴──────────┘
```

### Data Types
| Code | Description |
|------|-------------|
| 0x00 | Frame Start |
| 0x01 | Frame End |
| 0x02 | Line Start |
| 0x03 | Line End |
| 0x2A | RAW8 |
| 0x2B | RAW10 |
| 0x2C | RAW12 |
| 0x1E | YUV422 8-bit |
| 0x24 | RGB888 |

## CSI-2 Receiver Driver

```c
#include <media/v4l2-subdev.h>
#include <media/v4l2-fwnode.h>

struct csi2_dev {
    struct device *dev;
    void __iomem *base;
    struct v4l2_subdev sd;
    struct media_pad pads[2];  // sink and source
    struct v4l2_async_notifier notifier;
    struct v4l2_mbus_framefmt format;
    u8 num_lanes;
    u8 data_lanes[4];
};

#define CSI2_CTRL           0x00
#define CSI2_N_LANES        0x04
#define CSI2_DATA_TYPE      0x08
#define CSI2_ERR_STATUS     0x10
#define CSI2_IRQ_ENABLE     0x14

static int csi2_s_stream(struct v4l2_subdev *sd, int enable) {
    struct csi2_dev *csi2 = container_of(sd, struct csi2_dev, sd);
    u32 val;

    if (enable) {
        // Configure number of data lanes
        writel(csi2->num_lanes - 1, csi2->base + CSI2_N_LANES);

        // Configure expected data type based on format
        val = mbus_code_to_dt(csi2->format.code);
        writel(val, csi2->base + CSI2_DATA_TYPE);

        // Enable error interrupts
        writel(CSI2_ERR_ALL, csi2->base + CSI2_IRQ_ENABLE);

        // Enable CSI-2 receiver
        val = readl(csi2->base + CSI2_CTRL);
        val |= CSI2_CTRL_ENABLE;
        writel(val, csi2->base + CSI2_CTRL);
    } else {
        val = readl(csi2->base + CSI2_CTRL);
        val &= ~CSI2_CTRL_ENABLE;
        writel(val, csi2->base + CSI2_CTRL);
    }

    return 0;
}

static u8 mbus_code_to_dt(u32 code) {
    switch (code) {
    case MEDIA_BUS_FMT_SBGGR10_1X10:
    case MEDIA_BUS_FMT_SGBRG10_1X10:
    case MEDIA_BUS_FMT_SGRBG10_1X10:
    case MEDIA_BUS_FMT_SRGGB10_1X10:
        return 0x2B;  // RAW10
    case MEDIA_BUS_FMT_UYVY8_1X16:
        return 0x1E;  // YUV422-8
    default:
        return 0x2A;  // RAW8
    }
}
```

## D-PHY Configuration

```c
#define DPHY_CTRL           0x00
#define DPHY_PLL_CTRL       0x04
#define DPHY_TIMING         0x08
#define DPHY_LANE_ENABLE    0x0C

struct dphy_timing {
    u32 clk_prepare;
    u32 clk_zero;
    u32 clk_trail;
    u32 hs_prepare;
    u32 hs_zero;
    u32 hs_trail;
    u32 hs_exit;
};

static int dphy_configure(struct csi2_dev *csi2, u64 link_freq) {
    struct dphy_timing timing;
    u32 val;

    // Calculate timing parameters based on link frequency
    // Values in nanoseconds, convert to PHY clock cycles
    timing.clk_prepare = DIV_ROUND_UP(38 * link_freq, 1000000000);
    timing.clk_zero = DIV_ROUND_UP(300 * link_freq, 1000000000);
    timing.clk_trail = DIV_ROUND_UP(60 * link_freq, 1000000000);
    timing.hs_prepare = DIV_ROUND_UP(55 * link_freq, 1000000000);
    timing.hs_zero = DIV_ROUND_UP(145 * link_freq, 1000000000);
    timing.hs_trail = DIV_ROUND_UP(60 * link_freq, 1000000000);
    timing.hs_exit = DIV_ROUND_UP(100 * link_freq, 1000000000);

    // Program timing registers
    val = (timing.clk_prepare << 24) | (timing.clk_zero << 16) |
          (timing.clk_trail << 8);
    writel(val, csi2->base + DPHY_TIMING);

    // Enable lanes
    val = 0;
    for (int i = 0; i < csi2->num_lanes; i++)
        val |= BIT(csi2->data_lanes[i]);
    val |= BIT(4);  // Clock lane
    writel(val, csi2->base + DPHY_LANE_ENABLE);

    // Enable D-PHY
    writel(DPHY_ENABLE, csi2->base + DPHY_CTRL);

    return 0;
}
```

## Error Handling

```c
static irqreturn_t csi2_isr(int irq, void *dev_id) {
    struct csi2_dev *csi2 = dev_id;
    u32 status = readl(csi2->base + CSI2_ERR_STATUS);

    if (status & CSI2_ERR_ECC_CORRECTED)
        dev_dbg(csi2->dev, "ECC error corrected\n");

    if (status & CSI2_ERR_ECC_UNCORRECTED)
        dev_err(csi2->dev, "Uncorrectable ECC error\n");

    if (status & CSI2_ERR_CRC)
        dev_err(csi2->dev, "CRC error\n");

    if (status & CSI2_ERR_FIFO_OVERFLOW)
        dev_err(csi2->dev, "FIFO overflow\n");

    if (status & CSI2_ERR_SOT_SYNC)
        dev_warn(csi2->dev, "SOT sync error\n");

    // Clear errors
    writel(status, csi2->base + CSI2_ERR_STATUS);

    return IRQ_HANDLED;
}
```

## Device Tree Binding

```dts
csi2: csi@ff100000 {
    compatible = "vendor,csi2-receiver";
    reg = <0x0 0xff100000 0x0 0x1000>;
    interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&cru CLK_CSI>;
    clock-names = "csi_clk";

    ports {
        #address-cells = <1>;
        #size-cells = <0>;

        port@0 {
            reg = <0>;
            csi2_in: endpoint {
                remote-endpoint = <&sensor_out>;
                data-lanes = <1 2 3 4>;
                clock-noncontinuous;
            };
        };

        port@1 {
            reg = <1>;
            csi2_out: endpoint {
                remote-endpoint = <&isp_in>;
            };
        };
    };
};
```
6:T1f48,
# MMU and SMMU/IOMMU

## Memory Management Unit (MMU)

### Address Translation
```
┌──────────────┐    ┌─────────────┐    ┌──────────────┐
│   Virtual    │    │    MMU      │    │   Physical   │
│   Address    │───►│  (TLB +     │───►│   Address    │
│              │    │ Page Table) │    │              │
└──────────────┘    └─────────────┘    └──────────────┘

VA: 0xFFFF_0000_1234_5678
    │       │        │
    ├───────┘        │
    │ L0 Index       │
    │ L1 Index       │
    │ L2 Index       │
    │ L3 Index       │
    └── Page Offset  ┘

4KB pages: 12-bit offset
64KB pages: 16-bit offset
```

### Page Table Entry (ARM64)
```c
/* PTE bits */
#define PTE_VALID       (1UL << 0)
#define PTE_TABLE       (1UL << 1)  /* Points to next level table */
#define PTE_PAGE        (1UL << 1)  /* Valid page */
#define PTE_AF          (1UL << 10) /* Access Flag */
#define PTE_SH_INNER    (3UL << 8)  /* Inner shareable */
#define PTE_AP_RO       (1UL << 7)  /* Read-only */
#define PTE_AP_USER     (1UL << 6)  /* User accessible */
#define PTE_UXN         (1UL << 54) /* User execute never */
#define PTE_PXN         (1UL << 53) /* Privileged execute never */

/* Memory attributes (MAIR index) */
#define PTE_ATTRINDX(n) ((n) << 2)
#define MT_DEVICE_nGnRnE 0  /* Device memory */
#define MT_NORMAL        4  /* Normal cacheable */
```

## System MMU (SMMU/IOMMU)

### SMMU Architecture
```
┌─────────────────────────────────────────────────────────────┐
│                         SMMU                                 │
│  ┌────────────────────────────────────────────────────┐    │
│  │              Stream Table Entry (STE)               │    │
│  │    (Maps StreamID to Context Descriptor)            │    │
│  └────────────────────────┬───────────────────────────┘    │
│                           │                                 │
│  ┌────────────────────────▼───────────────────────────┐    │
│  │            Context Descriptor (CD)                  │    │
│  │      (Contains page table base address)             │    │
│  └────────────────────────┬───────────────────────────┘    │
│                           │                                 │
│  ┌────────────────────────▼───────────────────────────┐    │
│  │              Translation Tables                     │    │
│  │         (Same format as CPU page tables)            │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### Linux IOMMU API

```c
#include <linux/iommu.h>
#include <linux/dma-mapping.h>

static int my_driver_probe(struct platform_device *pdev) {
    struct device *dev = &pdev->dev;
    struct iommu_domain *domain;
    phys_addr_t phys;
    dma_addr_t iova;

    // Check if IOMMU is available
    if (!device_iommu_mapped(dev)) {
        dev_info(dev, "No IOMMU, using direct DMA\n");
        goto use_dma_api;
    }

    // Allocate custom IOMMU domain (optional)
    domain = iommu_domain_alloc(dev->bus);
    if (!domain)
        return -ENOMEM;

    // Attach device to domain
    iommu_attach_device(domain, dev);

    // Map physical memory to IOVA
    phys = virt_to_phys(buffer);
    iova = 0x10000000;  // Desired IOVA

    iommu_map(domain, iova, phys, size,
              IOMMU_READ | IOMMU_WRITE | IOMMU_CACHE);

    return 0;

use_dma_api:
    // Standard DMA API (IOMMU-aware)
    iova = dma_map_single(dev, buffer, size, DMA_BIDIRECTIONAL);
    if (dma_mapping_error(dev, iova))
        return -ENOMEM;

    return 0;
}
```

### Device Tree IOMMU Binding
```dts
smmu: iommu@fd800000 {
    compatible = "arm,smmu-v3";
    reg = <0x0 0xfd800000 0x0 0x100000>;
    interrupts = <GIC_SPI 200 IRQ_TYPE_EDGE_RISING>,
                 <GIC_SPI 201 IRQ_TYPE_EDGE_RISING>;
    interrupt-names = "eventq", "gerror";
    #iommu-cells = <1>;
    dma-coherent;
};

gpu: gpu@ff100000 {
    compatible = "vendor,gpu";
    reg = <0x0 0xff100000 0x0 0x10000>;
    iommus = <&smmu 0x100>;  /* StreamID = 0x100 */
};

ipu: ipu@ff200000 {
    compatible = "vendor,ipu";
    reg = <0x0 0xff200000 0x0 0x20000>;
    iommus = <&smmu 0x101>;  /* StreamID = 0x101 */
};
```

### Custom IOMMU Operations

```c
#include <linux/iommu.h>

static struct iommu_domain *my_iommu_domain_alloc(unsigned type) {
    struct my_domain *domain;

    if (type != IOMMU_DOMAIN_DMA && type != IOMMU_DOMAIN_UNMANAGED)
        return NULL;

    domain = kzalloc(sizeof(*domain), GFP_KERNEL);
    if (!domain)
        return NULL;

    // Allocate page tables
    domain->pgd = (pgd_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);

    return &domain->domain;
}

static int my_iommu_map(struct iommu_domain *domain,
                        unsigned long iova, phys_addr_t paddr,
                        size_t size, int prot, gfp_t gfp) {
    struct my_domain *my = to_my_domain(domain);
    unsigned long flags = 0;

    if (prot & IOMMU_READ)
        flags |= PTE_VALID;
    if (prot & IOMMU_WRITE)
        flags |= PTE_WRITE;
    if (prot & IOMMU_CACHE)
        flags |= PTE_ATTRINDX(MT_NORMAL);

    return my_create_mapping(my, iova, paddr, size, flags);
}

static const struct iommu_ops my_iommu_ops = {
    .domain_alloc = my_iommu_domain_alloc,
    .probe_device = my_iommu_probe_device,
    .device_group = generic_device_group,
    .default_domain_ops = &(const struct iommu_domain_ops) {
        .attach_dev = my_iommu_attach_device,
        .map = my_iommu_map,
        .unmap = my_iommu_unmap,
        .iova_to_phys = my_iommu_iova_to_phys,
        .free = my_iommu_domain_free,
    },
};
```

## TLB Management

```c
// Invalidate TLB in SMMU
static void my_smmu_tlb_inv_context(void *cookie) {
    struct my_smmu_domain *domain = cookie;
    struct my_smmu *smmu = domain->smmu;

    // Issue TLBI command
    writel(CMDQ_OP_TLBI_NH_ASID | domain->asid,
           smmu->base + SMMU_CMDQ_PROD);

    // Wait for completion
    my_smmu_cmdq_sync(smmu);
}

static void my_smmu_tlb_inv_range(unsigned long iova, size_t size,
                                   size_t granule, bool leaf,
                                   void *cookie) {
    struct my_smmu_domain *domain = cookie;
    unsigned long end = iova + size;

    while (iova < end) {
        // Issue TLBI by VA
        my_smmu_issue_tlbi_va(domain, iova, granule, leaf);
        iova += granule;
    }
}

static const struct iommu_flush_ops my_smmu_flush_ops = {
    .tlb_flush_all = my_smmu_tlb_inv_context,
    .tlb_flush_walk = my_smmu_tlb_inv_range,
    .tlb_add_page = my_smmu_tlb_inv_range,
};
```

## Debug

```bash
# Check IOMMU groups
ls /sys/kernel/iommu_groups/

# View devices in group
ls /sys/kernel/iommu_groups/0/devices/

# IOMMU debug
cat /sys/kernel/debug/iommu/domain_*/mappings
```
7:T22c1,
# PCIe Driver Development

## PCIe Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                       Root Complex                           │
│  ┌─────────────────────────────────────────────────────┐    │
│  │              Root Port (RP)                          │    │
│  └────────────────────────┬────────────────────────────┘    │
└───────────────────────────┼─────────────────────────────────┘
                            │ PCIe Link (x1, x4, x8, x16)
                            │
┌───────────────────────────┴─────────────────────────────────┐
│                      Endpoint (EP)                           │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │   BAR0     │  │   BAR1     │  │   BAR2     │            │
│  │  (MMIO)    │  │  (MMIO)    │  │   (DMA)    │            │
│  └────────────┘  └────────────┘  └────────────┘            │
└─────────────────────────────────────────────────────────────┘
```

## PCIe Device Driver

```c
#include <linux/pci.h>
#include <linux/module.h>
#include <linux/interrupt.h>

#define VENDOR_ID       0x8086
#define DEVICE_ID       0x1234

struct my_pcie_dev {
    struct pci_dev *pdev;
    void __iomem *bar0;
    void __iomem *bar1;
    int irq;
    spinlock_t lock;
};

static int my_pcie_probe(struct pci_dev *pdev,
                         const struct pci_device_id *id) {
    struct my_pcie_dev *dev;
    int ret;

    dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
    if (!dev)
        return -ENOMEM;

    dev->pdev = pdev;
    pci_set_drvdata(pdev, dev);

    // Enable device
    ret = pcim_enable_device(pdev);
    if (ret)
        return ret;

    // Request regions
    ret = pcim_iomap_regions(pdev, BIT(0) | BIT(1), "my-pcie");
    if (ret)
        return ret;

    // Map BARs
    dev->bar0 = pcim_iomap_table(pdev)[0];
    dev->bar1 = pcim_iomap_table(pdev)[1];

    // Enable bus mastering for DMA
    pci_set_master(pdev);

    // Set DMA mask
    ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
    if (ret) {
        ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
        if (ret)
            return ret;
    }

    // Request MSI-X or MSI interrupts
    ret = pci_alloc_irq_vectors(pdev, 1, 4, PCI_IRQ_MSIX | PCI_IRQ_MSI);
    if (ret < 0)
        return ret;

    dev->irq = pci_irq_vector(pdev, 0);
    ret = devm_request_irq(&pdev->dev, dev->irq, my_pcie_isr,
                           0, "my-pcie", dev);
    if (ret)
        return ret;

    spin_lock_init(&dev->lock);

    // Initialize hardware
    writel(CTRL_RESET, dev->bar0 + REG_CTRL);
    udelay(100);
    writel(CTRL_ENABLE, dev->bar0 + REG_CTRL);

    dev_info(&pdev->dev, "Device initialized\n");

    return 0;
}

static void my_pcie_remove(struct pci_dev *pdev) {
    struct my_pcie_dev *dev = pci_get_drvdata(pdev);

    // Disable hardware
    writel(0, dev->bar0 + REG_CTRL);

    pci_free_irq_vectors(pdev);
}

static const struct pci_device_id my_pcie_ids[] = {
    { PCI_DEVICE(VENDOR_ID, DEVICE_ID) },
    { }
};
MODULE_DEVICE_TABLE(pci, my_pcie_ids);

static struct pci_driver my_pcie_driver = {
    .name = "my-pcie",
    .id_table = my_pcie_ids,
    .probe = my_pcie_probe,
    .remove = my_pcie_remove,
};
module_pci_driver(my_pcie_driver);
```

## DMA Operations

```c
struct my_dma_desc {
    dma_addr_t src;
    dma_addr_t dst;
    u32 len;
    u32 flags;
} __packed;

static int my_pcie_dma_transfer(struct my_pcie_dev *dev,
                                 void *buf, size_t len,
                                 enum dma_data_direction dir) {
    dma_addr_t dma_addr;
    struct my_dma_desc *desc;
    dma_addr_t desc_dma;

    // Allocate descriptor
    desc = dma_alloc_coherent(&dev->pdev->dev, sizeof(*desc),
                              &desc_dma, GFP_KERNEL);
    if (!desc)
        return -ENOMEM;

    // Map buffer
    dma_addr = dma_map_single(&dev->pdev->dev, buf, len, dir);
    if (dma_mapping_error(&dev->pdev->dev, dma_addr)) {
        dma_free_coherent(&dev->pdev->dev, sizeof(*desc), desc, desc_dma);
        return -ENOMEM;
    }

    // Setup descriptor
    if (dir == DMA_TO_DEVICE) {
        desc->src = dma_addr;
        desc->dst = 0;  // Device internal address
        desc->flags = DMA_DESC_TO_DEVICE;
    } else {
        desc->src = 0;
        desc->dst = dma_addr;
        desc->flags = DMA_DESC_FROM_DEVICE;
    }
    desc->len = len;

    // Write descriptor address to hardware
    writeq(desc_dma, dev->bar0 + REG_DMA_DESC);

    // Start DMA
    writel(DMA_START, dev->bar0 + REG_DMA_CTRL);

    // Wait for completion (in real driver, use interrupt)
    while (!(readl(dev->bar0 + REG_DMA_STATUS) & DMA_COMPLETE))
        cpu_relax();

    // Cleanup
    dma_unmap_single(&dev->pdev->dev, dma_addr, len, dir);
    dma_free_coherent(&dev->pdev->dev, sizeof(*desc), desc, desc_dma);

    return 0;
}
```

## MSI-X Interrupt Handling

```c
#define NUM_MSIX_VECTORS 4

struct my_pcie_dev {
    struct pci_dev *pdev;
    void __iomem *bar0;
    int num_vectors;
    struct {
        int irq;
        char name[32];
    } vectors[NUM_MSIX_VECTORS];
};

static irqreturn_t my_msix_handler(int irq, void *data) {
    struct my_pcie_dev *dev = data;
    u32 status = readl(dev->bar0 + REG_INT_STATUS);

    // Handle interrupt based on status
    if (status & INT_DMA_COMPLETE)
        complete(&dev->dma_done);

    if (status & INT_ERROR)
        dev_err(&dev->pdev->dev, "Error interrupt\n");

    // Clear interrupt
    writel(status, dev->bar0 + REG_INT_STATUS);

    return IRQ_HANDLED;
}

static int setup_msix(struct my_pcie_dev *dev) {
    int ret, i;

    ret = pci_alloc_irq_vectors(dev->pdev, 1, NUM_MSIX_VECTORS,
                                PCI_IRQ_MSIX);
    if (ret < 0)
        return ret;

    dev->num_vectors = ret;

    for (i = 0; i < dev->num_vectors; i++) {
        dev->vectors[i].irq = pci_irq_vector(dev->pdev, i);
        snprintf(dev->vectors[i].name, sizeof(dev->vectors[i].name),
                 "my-pcie-%d", i);

        ret = request_irq(dev->vectors[i].irq, my_msix_handler,
                          0, dev->vectors[i].name, dev);
        if (ret)
            goto err_free_irq;
    }

    return 0;

err_free_irq:
    while (--i >= 0)
        free_irq(dev->vectors[i].irq, dev);
    pci_free_irq_vectors(dev->pdev);
    return ret;
}
```

## Configuration Space Access

```c
// Read configuration space
u16 vendor, device;
u8 revision;

pci_read_config_word(pdev, PCI_VENDOR_ID, &vendor);
pci_read_config_word(pdev, PCI_DEVICE_ID, &device);
pci_read_config_byte(pdev, PCI_REVISION_ID, &revision);

// Write configuration space
pci_write_config_word(pdev, PCI_COMMAND,
                      PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);

// Read capability
int pos = pci_find_capability(pdev, PCI_CAP_ID_MSI);
if (pos) {
    u16 ctrl;
    pci_read_config_word(pdev, pos + PCI_MSI_FLAGS, &ctrl);
}

// Extended capability (PCIe)
pos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);
```

## Power Management

```c
static int my_pcie_suspend(struct device *dev) {
    struct pci_dev *pdev = to_pci_dev(dev);
    struct my_pcie_dev *priv = pci_get_drvdata(pdev);

    // Save device state
    pci_save_state(pdev);

    // Disable interrupts
    writel(0, priv->bar0 + REG_INT_ENABLE);

    // Enter D3
    pci_set_power_state(pdev, PCI_D3hot);

    return 0;
}

static int my_pcie_resume(struct device *dev) {
    struct pci_dev *pdev = to_pci_dev(dev);
    struct my_pcie_dev *priv = pci_get_drvdata(pdev);

    // Return to D0
    pci_set_power_state(pdev, PCI_D0);

    // Restore state
    pci_restore_state(pdev);

    // Re-enable device
    writel(CTRL_ENABLE, priv->bar0 + REG_CTRL);
    writel(INT_ALL, priv->bar0 + REG_INT_ENABLE);

    return 0;
}

static DEFINE_SIMPLE_DEV_PM_OPS(my_pcie_pm_ops,
                                 my_pcie_suspend,
                                 my_pcie_resume);
```
8:T1808,
# SPI Protocol and Drivers

## SPI Protocol Overview

```
Master                              Slave
  │                                   │
  ├──────── SCLK (Clock) ────────────►│
  ├──────── MOSI (Master Out) ───────►│
  │◄──────── MISO (Master In) ────────┤
  ├──────── CS (Chip Select) ────────►│
  │                                   │
```

### SPI Modes
| Mode | CPOL | CPHA | Description |
|------|------|------|-------------|
| 0    | 0    | 0    | Clock idle low, sample on rising edge |
| 1    | 0    | 1    | Clock idle low, sample on falling edge |
| 2    | 1    | 0    | Clock idle high, sample on falling edge |
| 3    | 1    | 1    | Clock idle high, sample on rising edge |

## Linux SPI Controller Driver

```c
#include <linux/spi/spi.h>
#include <linux/platform_device.h>

struct my_spi {
    void __iomem *base;
    struct spi_controller *ctlr;
    struct clk *clk;
    struct completion done;
    const u8 *tx_buf;
    u8 *rx_buf;
    int len;
};

static int my_spi_transfer_one(struct spi_controller *ctlr,
                                struct spi_device *spi,
                                struct spi_transfer *xfer) {
    struct my_spi *spi_dev = spi_controller_get_devdata(ctlr);
    u32 ctrl = 0;

    reinit_completion(&spi_dev->done);

    spi_dev->tx_buf = xfer->tx_buf;
    spi_dev->rx_buf = xfer->rx_buf;
    spi_dev->len = xfer->len;

    // Configure SPI mode
    if (spi->mode & SPI_CPOL)
        ctrl |= SPI_CTRL_CPOL;
    if (spi->mode & SPI_CPHA)
        ctrl |= SPI_CTRL_CPHA;

    // Set clock divider
    ctrl |= SPI_CTRL_DIV(clk_get_rate(spi_dev->clk) / xfer->speed_hz);

    // Set bits per word
    ctrl |= SPI_CTRL_BPW(xfer->bits_per_word);

    writel(ctrl, spi_dev->base + SPI_CTRL);
    writel(xfer->len, spi_dev->base + SPI_LEN);

    // Enable TX interrupt and start
    writel(SPI_INT_TX | SPI_INT_RX, spi_dev->base + SPI_INT_EN);
    writel(SPI_START, spi_dev->base + SPI_CMD);

    wait_for_completion(&spi_dev->done);

    return 0;
}

static void my_spi_set_cs(struct spi_device *spi, bool enable) {
    struct my_spi *spi_dev = spi_controller_get_devdata(spi->controller);

    if (enable)
        writel(BIT(spi->chip_select), spi_dev->base + SPI_CS);
    else
        writel(0, spi_dev->base + SPI_CS);
}

static irqreturn_t my_spi_isr(int irq, void *dev_id) {
    struct my_spi *spi_dev = dev_id;
    u32 status = readl(spi_dev->base + SPI_STATUS);

    if (status & SPI_STATUS_DONE) {
        // Read received data
        if (spi_dev->rx_buf) {
            for (int i = 0; i < spi_dev->len; i++)
                spi_dev->rx_buf[i] = readl(spi_dev->base + SPI_RX_FIFO);
        }

        writel(SPI_STATUS_DONE, spi_dev->base + SPI_STATUS);
        complete(&spi_dev->done);
    }

    return IRQ_HANDLED;
}

static int my_spi_probe(struct platform_device *pdev) {
    struct spi_controller *ctlr;
    struct my_spi *spi_dev;

    ctlr = devm_spi_alloc_master(&pdev->dev, sizeof(*spi_dev));
    spi_dev = spi_controller_get_devdata(ctlr);

    spi_dev->base = devm_platform_ioremap_resource(pdev, 0);
    spi_dev->clk = devm_clk_get(&pdev->dev, NULL);
    clk_prepare_enable(spi_dev->clk);

    init_completion(&spi_dev->done);

    ctlr->bus_num = pdev->id;
    ctlr->num_chipselect = 4;
    ctlr->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;
    ctlr->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);
    ctlr->transfer_one = my_spi_transfer_one;
    ctlr->set_cs = my_spi_set_cs;

    spi_dev->ctlr = ctlr;

    return devm_spi_register_controller(&pdev->dev, ctlr);
}
```

## SPI Device Driver

```c
#include <linux/spi/spi.h>

struct my_spi_device {
    struct spi_device *spi;
    struct mutex lock;
    u8 tx_buf[64];
    u8 rx_buf[64];
};

static int my_spi_read_reg(struct my_spi_device *dev, u8 reg, u8 *val) {
    struct spi_transfer xfer[2];
    struct spi_message msg;

    memset(xfer, 0, sizeof(xfer));
    spi_message_init(&msg);

    // Write register address
    dev->tx_buf[0] = reg | 0x80;  // Read bit
    xfer[0].tx_buf = dev->tx_buf;
    xfer[0].len = 1;
    spi_message_add_tail(&xfer[0], &msg);

    // Read value
    xfer[1].rx_buf = dev->rx_buf;
    xfer[1].len = 1;
    spi_message_add_tail(&xfer[1], &msg);

    if (spi_sync(dev->spi, &msg))
        return -EIO;

    *val = dev->rx_buf[0];
    return 0;
}

static int my_spi_write_reg(struct my_spi_device *dev, u8 reg, u8 val) {
    u8 buf[2] = { reg & 0x7F, val };  // Clear read bit

    return spi_write(dev->spi, buf, 2);
}

// Using spi_write_then_read for simple transactions
static int my_spi_simple_read(struct spi_device *spi, u8 reg, u8 *val) {
    u8 cmd = reg | 0x80;
    return spi_write_then_read(spi, &cmd, 1, val, 1);
}
```

## DMA SPI Transfer

```c
static int my_spi_dma_transfer(struct my_spi *spi_dev,
                                struct spi_transfer *xfer) {
    struct dma_async_tx_descriptor *tx_desc, *rx_desc;
    dma_addr_t tx_dma, rx_dma;

    // Map buffers for DMA
    tx_dma = dma_map_single(spi_dev->dev, (void *)xfer->tx_buf,
                            xfer->len, DMA_TO_DEVICE);
    rx_dma = dma_map_single(spi_dev->dev, xfer->rx_buf,
                            xfer->len, DMA_FROM_DEVICE);

    // Prepare DMA descriptors
    tx_desc = dmaengine_prep_slave_single(spi_dev->tx_chan,
                                          tx_dma, xfer->len,
                                          DMA_MEM_TO_DEV,
                                          DMA_PREP_INTERRUPT);
    rx_desc = dmaengine_prep_slave_single(spi_dev->rx_chan,
                                          rx_dma, xfer->len,
                                          DMA_DEV_TO_MEM,
                                          DMA_PREP_INTERRUPT);

    rx_desc->callback = my_spi_dma_callback;
    rx_desc->callback_param = spi_dev;

    // Submit and start
    dmaengine_submit(tx_desc);
    dmaengine_submit(rx_desc);
    dma_async_issue_pending(spi_dev->tx_chan);
    dma_async_issue_pending(spi_dev->rx_chan);

    return 0;
}
```
9:Tda1,
# Linux Device Driver Development

## Driver Types

### Character Drivers
```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>

static struct cdev my_cdev;
static dev_t dev_num;

static int my_open(struct inode *inode, struct file *file) {
    pr_info("Device opened\n");
    return 0;
}

static ssize_t my_read(struct file *file, char __user *buf,
                       size_t count, loff_t *ppos) {
    // Copy data to user space
    return copy_to_user(buf, kernel_buf, count) ? -EFAULT : count;
}

static const struct file_operations my_fops = {
    .owner = THIS_MODULE,
    .open = my_open,
    .read = my_read,
    .write = my_write,
    .release = my_release,
};
```

### Platform Drivers
```c
static int my_probe(struct platform_device *pdev) {
    struct resource *res;
    void __iomem *base;

    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    base = devm_ioremap_resource(&pdev->dev, res);
    if (IS_ERR(base))
        return PTR_ERR(base);

    return 0;
}

static const struct of_device_id my_of_match[] = {
    { .compatible = "vendor,my-device" },
    { }
};

static struct platform_driver my_driver = {
    .probe = my_probe,
    .remove = my_remove,
    .driver = {
        .name = "my-driver",
        .of_match_table = my_of_match,
    },
};
module_platform_driver(my_driver);
```

## Memory Management

### DMA Operations
```c
#include <linux/dma-mapping.h>

// Coherent DMA allocation
void *vaddr = dma_alloc_coherent(dev, size, &dma_handle, GFP_KERNEL);

// Streaming DMA mapping
dma_addr_t dma = dma_map_single(dev, buf, size, DMA_TO_DEVICE);
dma_sync_single_for_device(dev, dma, size, DMA_TO_DEVICE);
// After transfer
dma_unmap_single(dev, dma, size, DMA_TO_DEVICE);
```

### IOMMU/SMMU Integration
```c
// Enable IOMMU for device
struct iommu_domain *domain = iommu_domain_alloc(dev->bus);
iommu_attach_device(domain, dev);

// Map IOVA to physical address
iommu_map(domain, iova, phys, size, IOMMU_READ | IOMMU_WRITE);
```

## Interrupt Handling

### Threaded IRQs
```c
static irqreturn_t my_isr(int irq, void *dev_id) {
    // Quick hardware acknowledgment
    writel(IRQ_ACK, base + IRQ_STATUS);
    return IRQ_WAKE_THREAD;
}

static irqreturn_t my_thread_fn(int irq, void *dev_id) {
    // Heavy processing in thread context
    process_data();
    return IRQ_HANDLED;
}

devm_request_threaded_irq(dev, irq, my_isr, my_thread_fn,
                          IRQF_SHARED, "my-irq", priv);
```

## Power Management

### Runtime PM
```c
#include <linux/pm_runtime.h>

static int my_runtime_suspend(struct device *dev) {
    // Disable clocks, power down
    clk_disable_unprepare(priv->clk);
    return 0;
}

static int my_runtime_resume(struct device *dev) {
    // Enable clocks, power up
    return clk_prepare_enable(priv->clk);
}

static const struct dev_pm_ops my_pm_ops = {
    SET_RUNTIME_PM_OPS(my_runtime_suspend, my_runtime_resume, NULL)
    SET_SYSTEM_SLEEP_PM_OPS(my_suspend, my_resume)
};

// In probe
pm_runtime_enable(dev);
pm_runtime_get_sync(dev);
```

## Debug Techniques

### Dynamic Debug
```bash
# Enable debug messages
echo 'module my_driver +p' > /sys/kernel/debug/dynamic_debug/control

# Enable function tracing
echo 'func my_probe +p' > /sys/kernel/debug/dynamic_debug/control
```

### Ftrace
```bash
# Trace specific function
echo my_function > /sys/kernel/debug/tracing/set_ftrace_filter
echo function > /sys/kernel/debug/tracing/current_tracer
echo 1 > /sys/kernel/debug/tracing/tracing_on
```
a:T1296,
# Device Tree and ACPI

## Device Tree Basics

### DTS Structure
```dts
/ {
    compatible = "vendor,board-name";
    #address-cells = <2>;
    #size-cells = <2>;

    cpus {
        #address-cells = <1>;
        #size-cells = <0>;

        cpu@0 {
            compatible = "arm,cortex-a72";
            device_type = "cpu";
            reg = <0>;
            enable-method = "psci";
        };
    };

    soc {
        compatible = "simple-bus";
        #address-cells = <2>;
        #size-cells = <2>;
        ranges;

        ipu: ipu@ff000000 {
            compatible = "vendor,ipu-v2";
            reg = <0x0 0xff000000 0x0 0x100000>;
            interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
            clocks = <&cru CLK_IPU>;
            clock-names = "ipu_clk";
            power-domains = <&power IPU_PD>;
            iommus = <&iommu IPU_MMU>;
            status = "okay";
        };
    };
};
```

### Camera Sensor Binding
```dts
&i2c2 {
    status = "okay";

    imx219: sensor@10 {
        compatible = "sony,imx219";
        reg = <0x10>;
        clocks = <&cru CLK_CAM_MCLK>;
        clock-names = "xclk";
        clock-frequency = <24000000>;

        reset-gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_LOW>;
        powerdown-gpios = <&gpio1 RK_PA5 GPIO_ACTIVE_HIGH>;

        VANA-supply = <&cam_avdd_2v8>;
        VDIG-supply = <&cam_dvdd_1v2>;
        VDDL-supply = <&cam_dovdd_1v8>;

        port {
            imx219_out: endpoint {
                remote-endpoint = <&csi_in>;
                data-lanes = <1 2>;
                clock-noncontinuous;
                link-frequencies = /bits/ 64 <456000000>;
            };
        };
    };
};

&csi {
    status = "okay";

    ports {
        port@0 {
            csi_in: endpoint {
                remote-endpoint = <&imx219_out>;
                data-lanes = <1 2>;
            };
        };
    };
};
```

### Parsing in Driver
```c
static int my_probe(struct platform_device *pdev) {
    struct device *dev = &pdev->dev;
    struct device_node *np = dev->of_node;
    u32 val;
    const char *name;

    // Read property
    if (of_property_read_u32(np, "clock-frequency", &val))
        val = 24000000; // default

    // Read string
    of_property_read_string(np, "clock-names", &name);

    // Get GPIO
    priv->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);

    // Get regulator
    priv->vdd = devm_regulator_get(dev, "VDIG");

    // Get clock
    priv->clk = devm_clk_get(dev, "xclk");

    // Parse endpoint
    struct fwnode_handle *ep = fwnode_graph_get_next_endpoint(
        dev_fwnode(dev), NULL);

    return 0;
}
```

## ACPI Integration

### ACPI Device Matching
```c
#ifdef CONFIG_ACPI
static const struct acpi_device_id my_acpi_match[] = {
    { "INTC1234", 0 },
    { "INTC5678", 1 },
    { }
};
MODULE_DEVICE_TABLE(acpi, my_acpi_match);
#endif

static struct platform_driver my_driver = {
    .driver = {
        .name = "my-device",
        .of_match_table = my_of_match,
        .acpi_match_table = ACPI_PTR(my_acpi_match),
    },
};
```

### Reading ACPI Properties
```c
static int my_acpi_probe(struct platform_device *pdev) {
    struct acpi_device *adev = ACPI_COMPANION(&pdev->dev);
    u64 val;

    // Read _DSD property
    if (!acpi_dev_get_property(adev, "clock-frequency",
                               ACPI_TYPE_INTEGER, &val)) {
        priv->clk_freq = val;
    }

    // Read GPIO from _CRS
    struct gpio_desc *gpio = devm_gpiod_get(&pdev->dev, "reset",
                                            GPIOD_OUT_LOW);

    return 0;
}
```

### ACPI ASL Example
```asl
Device (IPU0)
{
    Name (_HID, "INTC1234")
    Name (_UID, 0)

    Name (_CRS, ResourceTemplate () {
        Memory32Fixed (ReadWrite, 0xFF000000, 0x100000)
        Interrupt (ResourceConsumer, Level, ActiveHigh, Exclusive) { 45 }
        GpioIo (Exclusive, PullDefault, 0, 0, IoRestrictionNone,
                "\\_SB.GPO1") { 4 }
    })

    Name (_DSD, Package () {
        ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"),
        Package () {
            Package () { "clock-frequency", 400000000 },
            Package () { "power-domains", Package () { "\\_SB.PD01" } },
        }
    })

    Method (_STA, 0, NotSerialized) {
        Return (0x0F)
    }
}
```

## Overlay Support

### Runtime Overlay
```dts
/dts-v1/;
/plugin/;

&i2c2 {
    #address-cells = <1>;
    #size-cells = <0>;

    ov5640: camera@3c {
        compatible = "ovti,ov5640";
        reg = <0x3c>;
        status = "okay";
    };
};
```

### Loading Overlay
```bash
# Compile overlay
dtc -I dts -O dtb -o overlay.dtbo overlay.dts

# Apply at runtime (if supported)
mkdir /sys/kernel/config/device-tree/overlays/cam
cat overlay.dtbo > /sys/kernel/config/device-tree/overlays/cam/dtbo
```
b:T1118,
# V4L2 Camera Subsystem

## V4L2 Architecture

```
+------------------+
|   User Space     |
|  (v4l2-ctl, GS)  |
+--------+---------+
         |
+--------v---------+
|   V4L2 Core      |
|  videobuf2       |
+--------+---------+
         |
+--------v---------+
|  Subdev Driver   |
|  (sensor, ISP)   |
+--------+---------+
         |
+--------v---------+
|  Hardware        |
|  (MIPI, IPU)     |
+------------------+
```

## Video Device Registration

```c
#include <media/v4l2-device.h>
#include <media/v4l2-ioctl.h>
#include <media/videobuf2-dma-contig.h>

struct my_camera {
    struct v4l2_device v4l2_dev;
    struct video_device vdev;
    struct vb2_queue queue;
    struct mutex lock;
};

static const struct v4l2_ioctl_ops my_ioctl_ops = {
    .vidioc_querycap = my_querycap,
    .vidioc_enum_fmt_vid_cap = my_enum_fmt,
    .vidioc_g_fmt_vid_cap = my_g_fmt,
    .vidioc_s_fmt_vid_cap = my_s_fmt,
    .vidioc_reqbufs = vb2_ioctl_reqbufs,
    .vidioc_querybuf = vb2_ioctl_querybuf,
    .vidioc_qbuf = vb2_ioctl_qbuf,
    .vidioc_dqbuf = vb2_ioctl_dqbuf,
    .vidioc_streamon = vb2_ioctl_streamon,
    .vidioc_streamoff = vb2_ioctl_streamoff,
};

static const struct v4l2_file_operations my_fops = {
    .owner = THIS_MODULE,
    .open = v4l2_fh_open,
    .release = vb2_fop_release,
    .poll = vb2_fop_poll,
    .mmap = vb2_fop_mmap,
    .unlocked_ioctl = video_ioctl2,
};
```

## Videobuf2 Queue Setup

```c
static const struct vb2_ops my_vb2_ops = {
    .queue_setup = my_queue_setup,
    .buf_prepare = my_buf_prepare,
    .buf_queue = my_buf_queue,
    .start_streaming = my_start_streaming,
    .stop_streaming = my_stop_streaming,
    .wait_prepare = vb2_ops_wait_prepare,
    .wait_finish = vb2_ops_wait_finish,
};

static int my_queue_setup(struct vb2_queue *q,
                          unsigned int *nbuffers,
                          unsigned int *nplanes,
                          unsigned int sizes[],
                          struct device *alloc_devs[]) {
    *nplanes = 1;
    sizes[0] = cam->format.sizeimage;
    return 0;
}

static void my_buf_queue(struct vb2_buffer *vb) {
    struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
    struct my_buffer *buf = container_of(vbuf, struct my_buffer, vb);

    spin_lock(&cam->lock);
    list_add_tail(&buf->list, &cam->pending);
    spin_unlock(&cam->lock);
}
```

## Subdevice Driver (Sensor)

```c
#include <media/v4l2-subdev.h>
#include <media/v4l2-ctrls.h>

static int sensor_s_stream(struct v4l2_subdev *sd, int enable) {
    struct sensor_dev *sensor = to_sensor(sd);

    if (enable) {
        // Configure sensor registers
        sensor_write(sensor, REG_MODE, MODE_STREAMING);
    } else {
        sensor_write(sensor, REG_MODE, MODE_STANDBY);
    }
    return 0;
}

static const struct v4l2_subdev_video_ops sensor_video_ops = {
    .s_stream = sensor_s_stream,
};

static const struct v4l2_subdev_pad_ops sensor_pad_ops = {
    .enum_mbus_code = sensor_enum_mbus_code,
    .get_fmt = sensor_get_fmt,
    .set_fmt = sensor_set_fmt,
};

static const struct v4l2_subdev_ops sensor_ops = {
    .video = &sensor_video_ops,
    .pad = &sensor_pad_ops,
};
```

## MIPI CSI-2 Receiver

```c
// MIPI CSI-2 data types
#define MIPI_CSI2_DT_RAW8       0x2A
#define MIPI_CSI2_DT_RAW10      0x2B
#define MIPI_CSI2_DT_RAW12      0x2C
#define MIPI_CSI2_DT_YUV422_8   0x1E

static int csi2_configure(struct csi2_dev *csi,
                          struct v4l2_mbus_config *cfg) {
    u32 lanes = cfg->bus.mipi_csi2.num_data_lanes;

    // Configure number of lanes
    writel(lanes, csi->base + CSI2_N_LANES);

    // Configure data type
    writel(MIPI_CSI2_DT_RAW10, csi->base + CSI2_DATA_TYPE);

    // Enable CSI-2 receiver
    writel(CSI2_ENABLE, csi->base + CSI2_CTRL);

    return 0;
}
```

## Media Controller

```c
#include <media/media-device.h>
#include <media/media-entity.h>

// Create media device
media_device_init(&cam->mdev);
cam->mdev.dev = &pdev->dev;
strscpy(cam->mdev.model, "My Camera", sizeof(cam->mdev.model));

// Register entities and create links
media_device_register_entity(&cam->mdev, &sensor->entity);
media_device_register_entity(&cam->mdev, &csi->entity);
media_device_register_entity(&cam->mdev, &isp->entity);

// Create pad links
media_create_pad_link(&sensor->entity, 0, &csi->entity, 0,
                      MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);
```
c:T2552,
# First Silicon Bring-up

## Bring-up Phases

```
┌─────────────────────────────────────────────────────────────────┐
│                    Silicon Bring-up Timeline                    │
│                                                                  │
│  Phase 0        Phase 1        Phase 2        Phase 3           │
│  ATE Test       Basic Boot     OS Boot        Full Validation   │
│     │              │              │              │               │
│     ▼              ▼              ▼              ▼               │
│ ┌───────┐     ┌───────┐     ┌───────┐     ┌───────┐           │
│ │ Scan  │────►│ Boot  │────►│ Linux │────►│ Apps  │           │
│ │ BIST  │     │ ROM   │     │ Boot  │     │ Tests │           │
│ │ PLL   │     │ JTAG  │     │ Driver│     │ Perf  │           │
│ └───────┘     └───────┘     └───────┘     └───────┘           │
│                                                                  │
│  Week 1        Week 1-2       Week 2-4       Week 4+            │
└─────────────────────────────────────────────────────────────────┘
```

## Phase 0: Initial Power-On

### Power Sequencing Check
```c
/* Voltage rail bring-up verification */
struct power_rail {
    const char *name;
    float nominal_v;
    float tolerance;
    int gpio_enable;
    int adc_channel;
};

static struct power_rail rails[] = {
    {"VDD_CORE",  0.8,  0.05, GPIO_CORE_EN,  ADC_CH0},
    {"VDD_IO",    1.8,  0.10, GPIO_IO_EN,    ADC_CH1},
    {"VDD_DDR",   1.1,  0.05, GPIO_DDR_EN,   ADC_CH2},
    {"VDD_PLL",   0.8,  0.05, GPIO_PLL_EN,   ADC_CH3},
};

int verify_power_rails(void) {
    float measured;

    for (int i = 0; i < ARRAY_SIZE(rails); i++) {
        /* Enable rail */
        gpio_set(rails[i].gpio_enable, 1);
        mdelay(10);

        /* Measure voltage */
        measured = adc_read_voltage(rails[i].adc_channel);

        /* Verify within tolerance */
        if (fabs(measured - rails[i].nominal_v) > rails[i].tolerance) {
            printf("FAIL: %s: expected %.2fV, measured %.2fV\n",
                   rails[i].name, rails[i].nominal_v, measured);
            return -1;
        }

        printf("PASS: %s: %.2fV\n", rails[i].name, measured);
    }

    return 0;
}
```

### PLL Lock Verification
```c
/* Verify all PLLs lock successfully */
struct pll_config {
    const char *name;
    void __iomem *base;
    u32 target_freq_mhz;
};

int verify_pll_lock(struct pll_config *pll) {
    u32 status;
    int timeout = 1000;

    /* Check lock bit */
    while (timeout--) {
        status = readl(pll->base + PLL_STATUS);
        if (status & PLL_LOCKED)
            break;
        udelay(10);
    }

    if (!(status & PLL_LOCKED)) {
        printf("FAIL: %s PLL failed to lock\n", pll->name);
        return -1;
    }

    /* Measure frequency via counter */
    u32 measured = measure_clock_freq(pll->base);
    u32 expected = pll->target_freq_mhz * 1000000;

    if (abs(measured - expected) > (expected / 100)) {
        printf("FAIL: %s freq mismatch: expected %u, got %u\n",
               pll->name, expected, measured);
        return -1;
    }

    printf("PASS: %s locked at %u MHz\n", pll->name, measured / 1000000);
    return 0;
}
```

## Phase 1: JTAG and Basic Access

### JTAG Chain Verification
```bash
# Verify JTAG connectivity
openocd -f interface/jlink.cfg -c "
    transport select jtag
    adapter speed 1000
    jtag newtap chip cpu -irlen 4 -expected-id 0x4BA00477
    init
    scan_chain
    exit
"
```

### First Memory Access
```c
/* SRAM read/write test */
int sram_test(void __iomem *base, size_t size) {
    u32 pattern[] = {0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};
    int errors = 0;

    printf("Testing SRAM at %p, size %zu\n", base, size);

    for (int p = 0; p < ARRAY_SIZE(pattern); p++) {
        /* Write pattern */
        for (size_t i = 0; i < size; i += 4) {
            writel(pattern[p], base + i);
        }

        /* Verify pattern */
        for (size_t i = 0; i < size; i += 4) {
            u32 val = readl(base + i);
            if (val != pattern[p]) {
                printf("FAIL at 0x%zx: wrote 0x%08x, read 0x%08x\n",
                       i, pattern[p], val);
                errors++;
            }
        }
    }

    /* Address uniqueness test */
    for (size_t i = 0; i < size; i += 4) {
        writel(i, base + i);
    }
    for (size_t i = 0; i < size; i += 4) {
        u32 val = readl(base + i);
        if (val != i) {
            printf("FAIL address test at 0x%zx\n", i);
            errors++;
        }
    }

    return errors;
}
```

### Boot ROM Execution
```c
/* Minimal boot ROM code */
.section .text.boot
.global _start

_start:
    /* Disable interrupts */
    msr daifset, #0xf

    /* Set up stack */
    ldr x0, =__stack_top
    mov sp, x0

    /* Clear BSS */
    ldr x0, =__bss_start
    ldr x1, =__bss_end
1:  cmp x0, x1
    b.ge 2f
    str xzr, [x0], #8
    b 1b
2:
    /* Initialize UART for debug */
    bl uart_init

    /* Print sign-of-life */
    ldr x0, =boot_msg
    bl uart_puts

    /* Continue to main */
    bl main

    /* Should not return */
    b .

boot_msg:
    .asciz "Boot ROM started\r\n"
```

## Phase 2: DDR Initialization

```c
/* DDR PHY training sequence */
struct ddr_training_result {
    int write_leveling_pass;
    int read_gate_pass;
    int read_dqs_pass;
    int write_dq_pass;
    u8 delays[4][8];  /* Per-byte delay values */
};

int ddr_training(void __iomem *phy_base, struct ddr_training_result *result) {
    u32 status;

    /* Step 1: Write Leveling */
    writel(PHY_WL_START, phy_base + PHY_TRAINING_CTRL);
    status = wait_for_training_done(phy_base);
    result->write_leveling_pass = (status & PHY_WL_PASS);

    if (!result->write_leveling_pass) {
        printf("Write leveling failed: 0x%08x\n", status);
        return -1;
    }

    /* Step 2: Read Gate Training */
    writel(PHY_RG_START, phy_base + PHY_TRAINING_CTRL);
    status = wait_for_training_done(phy_base);
    result->read_gate_pass = (status & PHY_RG_PASS);

    /* Step 3: Read DQS Training */
    writel(PHY_RD_START, phy_base + PHY_TRAINING_CTRL);
    status = wait_for_training_done(phy_base);
    result->read_dqs_pass = (status & PHY_RD_PASS);

    /* Step 4: Write DQ Training */
    writel(PHY_WD_START, phy_base + PHY_TRAINING_CTRL);
    status = wait_for_training_done(phy_base);
    result->write_dq_pass = (status & PHY_WD_PASS);

    /* Save delay values for debug */
    for (int byte = 0; byte < 4; byte++) {
        for (int bit = 0; bit < 8; bit++) {
            result->delays[byte][bit] =
                readl(phy_base + PHY_DQ_DELAY(byte, bit));
        }
    }

    printf("DDR training complete: WL=%d RG=%d RD=%d WD=%d\n",
           result->write_leveling_pass, result->read_gate_pass,
           result->read_dqs_pass, result->write_dq_pass);

    return 0;
}
```

## Phase 3: Peripheral Validation

### I2C PMIC Communication
```c
int validate_pmic(void) {
    u8 chip_id, revision;

    /* Read PMIC identification */
    i2c_read_reg(PMIC_ADDR, PMIC_ID_REG, &chip_id);
    i2c_read_reg(PMIC_ADDR, PMIC_REV_REG, &revision);

    printf("PMIC: ID=0x%02x Rev=0x%02x\n", chip_id, revision);

    if (chip_id != EXPECTED_PMIC_ID) {
        printf("FAIL: Wrong PMIC ID\n");
        return -1;
    }

    /* Configure voltage regulators */
    i2c_write_reg(PMIC_ADDR, BUCK1_VOUT, VCORE_850MV);
    i2c_write_reg(PMIC_ADDR, BUCK2_VOUT, VIO_1800MV);

    return 0;
}
```

### Clock Tree Verification
```c
void dump_clock_tree(void) {
    struct clk_node {
        const char *name;
        u32 reg;
        u32 parent_mask;
        u32 div_mask;
    };

    static struct clk_node clocks[] = {
        {"CPU_CLK",  0x100, 0x03, 0x1F},
        {"BUS_CLK",  0x104, 0x03, 0x0F},
        {"DDR_CLK",  0x108, 0x03, 0x07},
        {"GPU_CLK",  0x10C, 0x03, 0x0F},
        {"IPU_CLK",  0x110, 0x03, 0x0F},
    };

    printf("Clock Tree Status:\n");
    for (int i = 0; i < ARRAY_SIZE(clocks); i++) {
        u32 val = readl(clk_base + clocks[i].reg);
        u32 parent = val & clocks[i].parent_mask;
        u32 div = (val >> 8) & clocks[i].div_mask;

        printf("  %s: parent=%d div=%d\n",
               clocks[i].name, parent, div + 1);
    }
}
```

## Debug Checklist

```markdown
## First Power-On Checklist

- [ ] Verify power rail sequencing with scope
- [ ] Measure all voltage rails
- [ ] Check current consumption (should be minimal before clocks)
- [ ] Verify reset signals with scope
- [ ] Check crystal oscillator output

## JTAG Bring-up Checklist

- [ ] JTAG chain detected correctly
- [ ] Can halt CPU cores
- [ ] Can read CPU registers
- [ ] Can access memory-mapped registers
- [ ] Boot ROM code executes

## Clock Checklist

- [ ] All PLLs lock
- [ ] Clock frequencies within spec
- [ ] Clock gating works correctly
- [ ] Dynamic frequency scaling works

## Memory Checklist

- [ ] SRAM read/write passes
- [ ] DDR training completes
- [ ] DDR stress test passes
- [ ] ECC functional (if enabled)
```
d:T22ea,
# HAPS FPGA Prototyping

## HAPS System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    HAPS-80 System                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  HAPS-80 Motherboard                     │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │   │
│  │  │ FPGA 1  │  │ FPGA 2  │  │ FPGA 3  │  │ FPGA 4  │    │   │
│  │  │(Xilinx  │  │(Xilinx  │  │(Xilinx  │  │(Xilinx  │    │   │
│  │  │VU440)   │  │VU440)   │  │VU440)   │  │VU440)   │    │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │   │
│  │       └─────┬──────┴─────┬──────┴─────┬──────┘         │   │
│  │             │   HapsTrak Connectors   │                │   │
│  └─────────────┼─────────────────────────┼─────────────────┘   │
│                │                         │                      │
│  ┌─────────────▼─────────────────────────▼─────────────────┐   │
│  │              Daughter Cards / Interfaces                 │   │
│  │  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐            │   │
│  │  │ DDR4  │  │ MIPI  │  │ PCIe  │  │ USB   │            │   │
│  │  └───────┘  └───────┘  └───────┘  └───────┘            │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## ProtoCompiler Flow

```
RTL Design
    │
    ▼
┌────────────────┐
│ ProtoCompiler  │
│  ┌───────────┐ │
│  │ Partition │ │  ← Splits design across FPGAs
│  └─────┬─────┘ │
│        │       │
│  ┌─────▼─────┐ │
│  │  Optimize │ │  ← Multi-FPGA timing closure
│  └─────┬─────┘ │
│        │       │
│  ┌─────▼─────┐ │
│  │  Compile  │ │  ← Xilinx Vivado synthesis
│  └───────────┘ │
└────────┬───────┘
         │
         ▼
   Bitstreams
```

### ProtoCompiler Commands
```bash
# Create new project
protocompiler new_project mydesign

# Add RTL files
protocompiler add_files mydesign -verilog design.v
protocompiler add_files mydesign -sv pkg.sv top.sv
protocompiler add_files mydesign -vhdl wrapper.vhd

# Set top module
protocompiler set_top mydesign top_module

# Configure target
protocompiler set_device mydesign haps80_s104_4

# Run partitioning
protocompiler partition mydesign

# Compile
protocompiler compile mydesign -j 16
```

## UMR (Unified Memory Region)

```c
/* UMR provides memory-mapped access to FPGA design */
#include "umr_api.h"

int main() {
    umr_handle_t handle;
    uint32_t data;

    /* Open UMR connection */
    umr_open(&handle, "HAPS80_S104");

    /* Memory-mapped register access */
    umr_read32(handle, 0x00000000, &data);  /* Base address */
    printf("ID Register: 0x%08x\n", data);

    /* Write to register */
    umr_write32(handle, 0x00000004, 0x12345678);

    /* Burst read */
    uint32_t buffer[256];
    umr_read_burst(handle, 0x00001000, buffer, 256);

    /* Close connection */
    umr_close(handle);

    return 0;
}
```

## Clock Configuration

```
┌──────────────────────────────────────────────────────────────┐
│                  HAPS Clock Architecture                      │
│                                                               │
│  External Clock ──► PLL ──┬──► Design Clock (10-200 MHz)    │
│                           │                                   │
│                           ├──► DDR Clock                      │
│                           │                                   │
│                           └──► I/O Clock                      │
│                                                               │
│  Note: FPGA timing typically 10-20x slower than ASIC         │
└──────────────────────────────────────────────────────────────┘
```

### Clock Commands
```bash
# Set main clock frequency
haps clock set CLK_MAIN 25.0

# Set multiple clocks
haps clock set CLK_CPU 20.0 CLK_BUS 10.0 CLK_DDR 50.0

# Read current settings
haps clock get all

# Dynamic frequency scaling
haps clock scale CLK_MAIN 0.5  # Half speed
```

## Debug Techniques

### Signal Probing with ChipScope
```tcl
# Vivado ILA insertion (in constraints)
create_debug_core u_ila_0 ila
set_property C_DATA_DEPTH 8192 [get_debug_cores u_ila_0]
set_property C_TRIGIN_EN false [get_debug_cores u_ila_0]
set_property C_INPUT_PIPE_STAGES 2 [get_debug_cores u_ila_0]

# Connect signals to probe
connect_debug_port u_ila_0/probe0 [get_nets {cpu_data[*]}]
connect_debug_port u_ila_0/probe1 [get_nets {cpu_addr[*]}]
connect_debug_port u_ila_0/probe2 [get_nets cpu_valid]
```

### Embedded Logic Analyzer
```bash
# Start Vivado hardware manager
vivado -mode tcl

# Connect to JTAG
open_hw_manager
connect_hw_server
open_hw_target

# Configure ILA
set_property CONTROL.DATA_DEPTH 8192 [get_hw_ilas hw_ila_1]
set_property CONTROL.TRIGGER_POSITION 4096 [get_hw_ilas hw_ila_1]

# Set trigger
set_property COMPARE_VALUE eq1'b1 [get_hw_probes cpu_valid]
run_hw_ila [get_hw_ilas hw_ila_1]

# Export waveform
write_hw_ila_data -csv_file capture.csv [upload_hw_ila_data hw_ila_1]
```

## Multi-FPGA Considerations

### Time Domain Crossing
```verilog
// Signals crossing FPGA boundaries need special handling
// ProtoCompiler inserts TDM (Time Division Multiplexing) bridges

// Design requirement: avoid combinational paths across FPGAs
// All cross-FPGA signals should be registered

module cross_fpga_interface (
    input  wire        clk,
    input  wire        rst_n,
    // To/from other FPGA
    input  wire [31:0] data_in,
    output reg  [31:0] data_out,
    input  wire        valid_in,
    output reg         valid_out
);

    // Double-register for metastability
    reg [31:0] data_sync1, data_sync2;
    reg        valid_sync1, valid_sync2;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_sync1  <= 32'b0;
            data_sync2  <= 32'b0;
            valid_sync1 <= 1'b0;
            valid_sync2 <= 1'b0;
        end else begin
            data_sync1  <= data_in;
            data_sync2  <= data_sync1;
            valid_sync1 <= valid_in;
            valid_sync2 <= valid_sync1;
        end
    end

    // Use synchronized signals
    assign rx_data  = data_sync2;
    assign rx_valid = valid_sync2;

endmodule
```

## Software Bring-up on HAPS

```bash
# Load FPGA bitstream
haps program all mydesign.bit

# Reset the design
haps reset assert
sleep 1
haps reset deassert

# Load software
haps load_elf program.elf 0x80000000

# Start execution
haps cpu run

# Connect GDB
arm-none-eabi-gdb program.elf
(gdb) target remote :3333
```

## Performance Considerations

| Aspect | ASIC Target | HAPS FPGA |
|--------|-------------|-----------|
| Clock Frequency | 1 GHz | 25-50 MHz |
| DDR Speed | 4266 MT/s | 1600 MT/s |
| Real-time Ratio | 1x | 20-40x slower |

### Optimization Tips
- Use multi-FPGA partitioning wisely
- Minimize cross-FPGA signal count
- Use dedicated I/O daughter cards for high-speed interfaces
- Enable deep pipeline insertion for timing closure
e:T2e68,
# Palladium Emulation

## Emulation System Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    Palladium Z2 System                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Compute Cluster                        │   │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │   │
│  │  │Processor│  │Processor│  │Processor│  │Processor│    │   │
│  │  │ Domain  │  │ Domain  │  │ Domain  │  │ Domain  │    │   │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │   │
│  │       └─────┬──────┴─────┬──────┴─────┬──────┘         │   │
│  │             │      High-Speed Fabric  │                │   │
│  └─────────────┼─────────────────────────┼─────────────────┘   │
│                │                         │                      │
│  ┌─────────────▼─────────────────────────▼─────────────────┐   │
│  │                    I/O Infrastructure                    │   │
│  │  ┌───────┐  ┌───────┐  ┌───────┐  ┌───────┐            │   │
│  │  │SpeedBr│  │  DDR  │  │ PCIe  │  │ USB   │            │   │
│  │  │  idge │  │ Model │  │ Model │  │ Model │            │   │
│  │  └───────┘  └───────┘  └───────┘  └───────┘            │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                    ┌───────▼───────┐                           │
│                    │   Host Server │                           │
│                    │   (Software)  │                           │
│                    └───────────────┘                           │
└─────────────────────────────────────────────────────────────────┘
```

## Compilation Flow

```
         RTL + Testbench
              │
              ▼
    ┌────────────────────┐
    │     xeCompile      │ ← RTL elaboration
    └─────────┬──────────┘
              │
              ▼
    ┌────────────────────┐
    │     xeBuild        │ ← Database generation
    └─────────┬──────────┘
              │
              ▼
    ┌────────────────────┐
    │     xeLoad         │ ← Load to emulator
    └─────────┬──────────┘
              │
              ▼
    ┌────────────────────┐
    │     xeRun          │ ← Execute design
    └────────────────────┘
```

### Compilation Commands
```bash
# Analyze RTL
xeCompile -top top_module \
    -f rtl_files.f \
    -sv_lib uvm \
    -timescale 1ns/1ps

# Build database
xeBuild -design my_design \
    -target palladium_z2 \
    -partition_count 4

# Load to emulator
xeLoad -design my_design \
    -session my_session

# Run simulation
xeRun -cycles 1000000
```

## SpeedBridge Integration

### Host-Emulator Communication
```c
/* SpeedBridge provides high-speed co-emulation */
#include "speedbridge.h"

typedef struct {
    uint32_t addr;
    uint32_t data;
    uint8_t  wr_en;
} axi_txn_t;

/* Callback when emulator sends transaction */
void emulator_callback(void *context, sb_packet_t *pkt) {
    axi_txn_t *txn = (axi_txn_t *)pkt->data;

    if (txn->wr_en) {
        /* Handle write from emulator */
        memory_write(txn->addr, txn->data);
    } else {
        /* Handle read, send response */
        uint32_t rdata = memory_read(txn->addr);
        sb_packet_t resp;
        resp.data = &rdata;
        resp.size = sizeof(rdata);
        sb_send(context, &resp);
    }
}

int main() {
    sb_handle_t handle;

    /* Initialize SpeedBridge */
    sb_init(&handle, "my_session");
    sb_register_callback(handle, emulator_callback, NULL);

    /* Start emulation */
    sb_run(handle);

    /* Cleanup */
    sb_close(handle);
    return 0;
}
```

## Transactor-Based Verification

```verilog
// SystemVerilog transactor for AXI
module axi_transactor (
    input  wire        clk,
    input  wire        rst_n,
    // AXI interface to DUT
    output reg  [31:0] awaddr,
    output reg  [7:0]  awlen,
    output reg         awvalid,
    input  wire        awready,
    output reg  [31:0] wdata,
    output reg         wlast,
    output reg         wvalid,
    input  wire        wready,
    input  wire [1:0]  bresp,
    input  wire        bvalid,
    output reg         bready
);

    // Import DPI functions
    import "DPI-C" function int get_next_transaction(
        output int addr, output int data, output int len);
    import "DPI-C" function void report_completion(
        input int addr, input int resp);

    // State machine
    typedef enum {IDLE, ADDR, DATA, RESP} state_t;
    state_t state;

    int txn_addr, txn_data, txn_len;
    int beat_count;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            awvalid <= 0;
            wvalid <= 0;
            bready <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (get_next_transaction(txn_addr, txn_data, txn_len)) begin
                        awaddr <= txn_addr;
                        awlen <= txn_len - 1;
                        awvalid <= 1;
                        state <= ADDR;
                    end
                end
                ADDR: begin
                    if (awready) begin
                        awvalid <= 0;
                        wdata <= txn_data;
                        wvalid <= 1;
                        wlast <= (txn_len == 1);
                        beat_count <= 1;
                        state <= DATA;
                    end
                end
                DATA: begin
                    if (wready) begin
                        if (wlast) begin
                            wvalid <= 0;
                            bready <= 1;
                            state <= RESP;
                        end else begin
                            beat_count <= beat_count + 1;
                            wlast <= (beat_count + 1 == txn_len);
                        end
                    end
                end
                RESP: begin
                    if (bvalid) begin
                        report_completion(txn_addr, bresp);
                        bready <= 0;
                        state <= IDLE;
                    end
                end
            endcase
        end
    end
endmodule
```

## Debug Capabilities

### Waveform Capture
```bash
# Enable signal tracing
xeDebug -design my_design \
    -signals top.cpu.* top.bus.* \
    -depth 2 \
    -start_cycle 100000 \
    -stop_cycle 200000

# Generate waveform database
xeWave -output waveform.fsdb
```

### Runtime Debug
```bash
# Interactive debug mode
xeConsole -session my_session

# In console:
> force top.rst_n 0
> run 100
> force top.rst_n 1
> run 1000000
> print top.cpu.pc
> watch top.cpu.exception
```

## ICE (In-Circuit Emulation) Mode

```
┌─────────────────────────────────────────────────────────────────┐
│                    ICE Configuration                             │
│                                                                  │
│  ┌──────────────┐          ┌──────────────────────────────┐    │
│  │   Target     │   MIPI   │        Palladium             │    │
│  │   Board      │──────────│    (Running SoC Design)      │    │
│  │   (Sensor)   │   I2C    │                              │    │
│  └──────────────┘──────────│    ┌─────────────────────┐  │    │
│                            │    │ Emulated SoC:        │  │    │
│                            │    │  - CPU cores        │  │    │
│                            │    │  - IPU/ISP          │  │    │
│                            │    │  - Memory           │  │    │
│                            │    └─────────────────────┘  │    │
│                            └──────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### ICE Interface Setup
```bash
# Configure external connections
xeICE -config ice_config.yaml

# ice_config.yaml:
interfaces:
  mipi_csi:
    type: mipi
    lanes: 4
    speed: 1.5Gbps
    connection: connector_a

  i2c_ctrl:
    type: i2c
    speed: 400kHz
    connection: connector_b
    pull_ups: enabled
```

## Performance Optimization

### Clock Gating Reduction
```tcl
# Reduce emulator overhead from clock gating
set_compile_option -clock_gating_reduction high

# Disable non-critical clock domains during debug
xeRun -disable_domain peripheral_clk
```

### Memory Model Optimization
```bash
# Use abstract memory models for faster execution
xeBuild -memory_abstraction high \
    -ddr_model_level functional
```

## Test Automation

```python
#!/usr/bin/env python3
# run_regression.py

import subprocess
import json

tests = [
    {"name": "boot_test", "cycles": 1000000},
    {"name": "ddr_test", "cycles": 5000000},
    {"name": "camera_capture", "cycles": 10000000},
]

for test in tests:
    print(f"Running {test['name']}...")

    # Load test-specific configuration
    subprocess.run([
        "xeLoad", "-design", "soc_design",
        "-stimulus", f"tests/{test['name']}.stim"
    ])

    # Run emulation
    result = subprocess.run([
        "xeRun", "-cycles", str(test['cycles']),
        "-check", f"tests/{test['name']}.check"
    ], capture_output=True)

    # Check results
    if result.returncode == 0:
        print(f"  PASS: {test['name']}")
    else:
        print(f"  FAIL: {test['name']}")
        print(result.stderr.decode())
```
f:T1eb3,
# Validation Methodology

## V-Model Development

```
Requirements ─────────────────────────────────── System Test
     │                                                │
     ▼                                                ▲
Architecture ───────────────────────────── Integration Test
     │                                          │
     ▼                                          ▲
Design ─────────────────────────────── Unit Test
     │                                    │
     ▼                                    ▲
Implementation ──────► Code Review ──────┘
```

## Test Levels

### Unit Testing (IP Level)
```c
/* Example: UART transmit unit test */
void test_uart_tx_single_char(void) {
    uart_config_t cfg = {
        .baudrate = 115200,
        .databits = 8,
        .parity = PARITY_NONE,
        .stopbits = 1
    };

    /* Initialize */
    uart_init(UART0_BASE, &cfg);

    /* Transmit character */
    uart_putc(UART0_BASE, 'A');

    /* Verify TX complete */
    ASSERT(uart_tx_complete(UART0_BASE));

    /* Verify data on loopback */
    if (loopback_enabled) {
        ASSERT_EQ(uart_getc(UART0_BASE), 'A');
    }
}

void test_uart_tx_fifo_overflow(void) {
    /* Fill TX FIFO beyond capacity */
    for (int i = 0; i < 32; i++) {
        uart_putc_nonblock(UART0_BASE, 'X');
    }

    /* Next write should return busy/full */
    ASSERT_EQ(uart_putc_nonblock(UART0_BASE, 'Y'), -EBUSY);
}
```

### Integration Testing
```c
/* Example: Camera → IPU → Memory integration */
void test_camera_capture_pipeline(void) {
    struct buffer capture_buf;

    /* Allocate DMA buffer */
    capture_buf.size = 1920 * 1080 * 2;  /* YUV422 */
    capture_buf.vaddr = dma_alloc_coherent(capture_buf.size,
                                           &capture_buf.paddr);

    /* Configure CSI receiver */
    csi_configure(CSI_LANES_4, CSI_SPEED_1500MBPS);

    /* Configure IPU pipeline */
    ipu_set_input(IPU_INPUT_CSI0, 1920, 1080, FMT_RAW10);
    ipu_set_output(IPU_OUTPUT_MAIN, 1920, 1080, FMT_NV12);
    ipu_set_buffer(capture_buf.paddr);

    /* Start capture */
    csi_start();
    ipu_start();

    /* Wait for frame */
    ASSERT(wait_for_frame_done(1000) == 0);

    /* Validate captured data */
    validate_yuv_image(capture_buf.vaddr, 1920, 1080);

    /* Cleanup */
    csi_stop();
    ipu_stop();
    dma_free_coherent(capture_buf.vaddr);
}
```

### System Testing
```python
#!/usr/bin/env python3
# system_test_camera_streaming.py

import subprocess
import time

def test_4k_streaming_30fps():
    """Test sustained 4K video streaming at 30fps"""

    # Start camera streaming
    proc = subprocess.Popen([
        "gst-launch-1.0",
        "v4l2src", "device=/dev/video0",
        "!", "video/x-raw,width=3840,height=2160,framerate=30/1",
        "!", "fakesink"
    ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    # Run for 60 seconds
    time.sleep(60)
    proc.terminate()

    # Parse output for dropped frames
    stderr = proc.stderr.read().decode()

    # Check no frame drops
    assert "dropping" not in stderr.lower()
    assert proc.returncode == 0

def test_thermal_throttling():
    """Verify thermal throttling engages correctly"""

    # Start stress workload
    stress_proc = subprocess.Popen(["stress-ng", "--cpu", "4"])

    # Monitor temperature
    max_temp = 0
    throttled = False

    for _ in range(120):  # 2 minutes
        temp = read_thermal_zone(0)
        max_temp = max(max_temp, temp)

        if temp > 85:
            throttled = True
            # Verify frequency reduced
            freq = read_cpu_frequency()
            assert freq < MAX_FREQUENCY

        time.sleep(1)

    stress_proc.terminate()

    print(f"Max temperature: {max_temp}°C")
    assert max_temp < 105  # Below critical
```

## Test Coverage Metrics

### Code Coverage
```bash
# Compile with coverage
gcc -fprofile-arcs -ftest-coverage -o mytest mytest.c

# Run tests
./mytest

# Generate report
gcov mytest.c
lcov --capture --directory . --output-file coverage.info
genhtml coverage.info --output-directory coverage_html
```

### Register Coverage
```python
# Track register access during test
class RegisterCoverageTracker:
    def __init__(self, reg_map):
        self.reg_map = reg_map
        self.read_coverage = {r: False for r in reg_map}
        self.write_coverage = {r: False for r in reg_map}
        self.bit_coverage = {r: 0 for r in reg_map}

    def on_read(self, addr, value):
        if addr in self.reg_map:
            self.read_coverage[addr] = True
            self.bit_coverage[addr] |= value

    def on_write(self, addr, value):
        if addr in self.reg_map:
            self.write_coverage[addr] = True
            self.bit_coverage[addr] |= value

    def report(self):
        total_regs = len(self.reg_map)
        read_covered = sum(self.read_coverage.values())
        write_covered = sum(self.write_coverage.values())

        print(f"Read coverage: {read_covered}/{total_regs}")
        print(f"Write coverage: {write_covered}/{total_regs}")
```

## Regression Testing

### CI Pipeline
```yaml
# .gitlab-ci.yml for hardware validation
stages:
  - build
  - unit_test
  - hw_test
  - system_test

build_firmware:
  stage: build
  script:
    - cmake -B build -DCMAKE_TOOLCHAIN_FILE=aarch64.cmake
    - cmake --build build
  artifacts:
    paths:
      - build/firmware.bin

unit_tests:
  stage: unit_test
  script:
    - cmake -B build_test -DBUILD_TESTS=ON
    - cmake --build build_test
    - ctest --test-dir build_test --output-on-failure

hw_integration:
  stage: hw_test
  tags:
    - hw-lab  # Runner connected to hardware
  script:
    - ./scripts/flash_board.sh build/firmware.bin
    - ./scripts/run_hw_tests.sh
  timeout: 2h

system_validation:
  stage: system_test
  tags:
    - hw-lab
  script:
    - pytest tests/system/ -v --junitxml=results.xml
  artifacts:
    reports:
      junit: results.xml
```

## Bug Tracking and Triage

```markdown
## Bug Report Template

### Summary
[One-line description]

### Environment
- Silicon revision: A0/B0/C0
- Board: [EVT/DVT/PVT]
- Firmware version: [commit hash]
- Linux kernel: [version]

### Steps to Reproduce
1. Step one
2. Step two
3. ...

### Expected Behavior
[What should happen]

### Actual Behavior
[What actually happens]

### Debug Information
- Register dumps
- dmesg output
- Waveform captures

### Classification
- Severity: [Critical/Major/Minor/Trivial]
- Component: [CPU/IPU/DDR/PCIe/etc.]
- Root cause: [RTL/Firmware/Software/Unknown]
```

## Performance Validation

```c
/* Bandwidth measurement framework */
struct bandwidth_test {
    const char *name;
    void __iomem *src;
    void __iomem *dst;
    size_t size;
    int iterations;
};

void run_bandwidth_test(struct bandwidth_test *test) {
    u64 start, end;
    u64 total_cycles = 0;
    u64 min_cycles = UINT64_MAX;
    u64 max_cycles = 0;

    /* Warmup */
    memcpy_dma(test->dst, test->src, test->size);

    /* Timed runs */
    for (int i = 0; i < test->iterations; i++) {
        start = read_cycle_counter();
        memcpy_dma(test->dst, test->src, test->size);
        end = read_cycle_counter();

        u64 cycles = end - start;
        total_cycles += cycles;
        min_cycles = min(min_cycles, cycles);
        max_cycles = max(max_cycles, cycles);
    }

    u64 avg_cycles = total_cycles / test->iterations;
    u64 freq_mhz = get_cpu_freq() / 1000000;
    double bandwidth_mbps = (test->size * freq_mhz) / (avg_cycles);

    printf("%s: %.2f MB/s (avg=%llu min=%llu max=%llu cycles)\n",
           test->name, bandwidth_mbps, avg_cycles, min_cycles, max_cycles);
}
```
10:T175b,
# FreeRTOS Fundamentals

## Task Management

### Creating Tasks
```c
#include "FreeRTOS.h"
#include "task.h"

void vTaskFunction(void *pvParameters) {
    const char *pcTaskName = (const char *)pvParameters;

    for (;;) {
        // Task logic
        printf("Task: %s\n", pcTaskName);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

int main(void) {
    xTaskCreate(
        vTaskFunction,          // Function
        "Task1",                // Name
        configMINIMAL_STACK_SIZE * 2,  // Stack size
        (void *)"Task1",        // Parameters
        tskIDLE_PRIORITY + 1,   // Priority
        NULL                    // Handle
    );

    vTaskStartScheduler();

    // Should never reach here
    for (;;);
}
```

### Task States
```
                    ┌─────────────┐
    vTaskCreate()   │             │   vTaskDelete()
        ─────────►  │   Ready     │ ◄─────────
                    │             │
                    └──────┬──────┘
                           │ Scheduler selects
                           ▼
                    ┌─────────────┐
                    │             │
                    │  Running    │
                    │             │
                    └──────┬──────┘
                           │ Blocked on event
                           ▼
                    ┌─────────────┐
                    │             │
                    │  Blocked    │
                    │             │
                    └─────────────┘
```

## Synchronization Primitives

### Semaphores
```c
#include "semphr.h"

SemaphoreHandle_t xSemaphore;

void vProducerTask(void *pvParameters) {
    for (;;) {
        // Produce data
        produce_data();

        // Signal consumer
        xSemaphoreGive(xSemaphore);

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

void vConsumerTask(void *pvParameters) {
    for (;;) {
        // Wait for data
        if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdTRUE) {
            consume_data();
        }
    }
}

int main(void) {
    xSemaphore = xSemaphoreCreateBinary();
    // Create tasks...
}
```

### Mutex (with Priority Inheritance)
```c
SemaphoreHandle_t xMutex;

void vTask(void *pvParameters) {
    for (;;) {
        if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdTRUE) {
            // Critical section - access shared resource
            access_shared_resource();

            xSemaphoreGive(xMutex);
        }
        vTaskDelay(pdMS_TO_TICKS(10));
    }
}

int main(void) {
    xMutex = xSemaphoreCreateMutex();
    // Mutex supports priority inheritance to avoid priority inversion
}
```

### Message Queues
```c
#include "queue.h"

typedef struct {
    uint32_t sensor_id;
    int32_t value;
    TickType_t timestamp;
} SensorData_t;

QueueHandle_t xSensorQueue;

void vSensorTask(void *pvParameters) {
    SensorData_t data;

    for (;;) {
        data.sensor_id = 1;
        data.value = read_sensor();
        data.timestamp = xTaskGetTickCount();

        xQueueSend(xSensorQueue, &data, pdMS_TO_TICKS(10));

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

void vProcessorTask(void *pvParameters) {
    SensorData_t received;

    for (;;) {
        if (xQueueReceive(xSensorQueue, &received, portMAX_DELAY) == pdTRUE) {
            process_sensor_data(&received);
        }
    }
}

int main(void) {
    xSensorQueue = xQueueCreate(10, sizeof(SensorData_t));
}
```

## Interrupt Handling

### ISR-Safe API
```c
void vISRHandler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    // Clear interrupt
    CLEAR_INTERRUPT();

    // Signal task from ISR
    xSemaphoreGiveFromISR(xSemaphore, &xHigherPriorityTaskWoken);

    // Context switch if needed
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

### Deferred Interrupt Processing
```c
void vDeferredHandler(void *pvParameters) {
    for (;;) {
        // Wait for interrupt notification
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);

        // Process interrupt in task context
        process_interrupt_data();
    }
}

void vISR(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    CLEAR_INTERRUPT();

    vTaskNotifyGiveFromISR(xDeferredHandlerTask, &xHigherPriorityTaskWoken);

    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}
```

## Memory Management

### Heap Schemes
| Scheme | Description | Use Case |
|--------|-------------|----------|
| heap_1 | Simple, no free | Static allocation only |
| heap_2 | Best fit, fragments | Variable size, no coalesce |
| heap_4 | First fit, coalesces | General purpose |
| heap_5 | Multiple regions | Non-contiguous memory |

### Static Allocation
```c
// FreeRTOSConfig.h
#define configSUPPORT_STATIC_ALLOCATION 1

// Provide memory for idle task
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                    StackType_t **ppxIdleTaskStackBuffer,
                                    uint32_t *pulIdleTaskStackSize) {
    *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
    *ppxIdleTaskStackBuffer = xIdleStack;
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}
```

## Software Timers
```c
#include "timers.h"

void vTimerCallback(TimerHandle_t xTimer) {
    uint32_t ulTimerID = (uint32_t)pvTimerGetTimerID(xTimer);
    printf("Timer %lu expired\n", ulTimerID);
}

int main(void) {
    TimerHandle_t xTimer = xTimerCreate(
        "Timer1",                   // Name
        pdMS_TO_TICKS(1000),        // Period
        pdTRUE,                     // Auto-reload
        (void *)1,                  // Timer ID
        vTimerCallback              // Callback
    );

    xTimerStart(xTimer, 0);
    vTaskStartScheduler();
}
```
11:T1a28,
# QNX Neutrino RTOS

## Microkernel Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    User Space                            │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐    │
│  │ Driver  │  │  App    │  │ File    │  │ Network │    │
│  │ Process │  │ Process │  │ System  │  │ Stack   │    │
│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘    │
│       │            │            │            │          │
├───────┴────────────┴────────────┴────────────┴──────────┤
│                   Message Passing                        │
├─────────────────────────────────────────────────────────┤
│                   QNX Microkernel                        │
│         (Scheduling, IPC, Interrupt Handling)            │
├─────────────────────────────────────────────────────────┤
│                      Hardware                            │
└─────────────────────────────────────────────────────────┘
```

## Message Passing IPC

### Server Process
```c
#include <sys/neutrino.h>
#include <sys/dispatch.h>

#define MY_PULSE_CODE _PULSE_CODE_MINAVAIL

typedef struct {
    uint16_t type;
    uint16_t subtype;
    int data;
} my_msg_t;

typedef struct {
    uint16_t type;
    int result;
} my_reply_t;

int main(void) {
    name_attach_t *attach;
    my_msg_t msg;
    my_reply_t reply;
    int rcvid;

    // Create channel and register name
    attach = name_attach(NULL, "my_server", 0);
    if (attach == NULL) {
        perror("name_attach");
        return EXIT_FAILURE;
    }

    printf("Server running, waiting for messages...\n");

    for (;;) {
        rcvid = MsgReceive(attach->chid, &msg, sizeof(msg), NULL);

        if (rcvid == 0) {
            // Pulse received
            printf("Pulse received: code=%d, value=%d\n",
                   msg.type, msg.subtype);
        } else if (rcvid > 0) {
            // Message received
            printf("Message: type=%d, data=%d\n", msg.type, msg.data);

            reply.type = 0;
            reply.result = msg.data * 2;  // Process and reply

            MsgReply(rcvid, EOK, &reply, sizeof(reply));
        }
    }

    name_detach(attach, 0);
    return EXIT_SUCCESS;
}
```

### Client Process
```c
#include <sys/neutrino.h>

int main(void) {
    int fd, result;
    my_msg_t msg;
    my_reply_t reply;

    // Connect to server
    fd = name_open("my_server", 0);
    if (fd == -1) {
        perror("name_open");
        return EXIT_FAILURE;
    }

    // Send message
    msg.type = 1;
    msg.subtype = 0;
    msg.data = 42;

    result = MsgSend(fd, &msg, sizeof(msg), &reply, sizeof(reply));
    if (result == -1) {
        perror("MsgSend");
    } else {
        printf("Reply: result=%d\n", reply.result);
    }

    name_close(fd);
    return EXIT_SUCCESS;
}
```

## Resource Manager (Device Driver)

```c
#include <sys/iofunc.h>
#include <sys/dispatch.h>

static resmgr_connect_funcs_t connect_funcs;
static resmgr_io_funcs_t io_funcs;
static iofunc_attr_t attr;

int io_read(resmgr_context_t *ctp, io_read_t *msg,
            RESMGR_OCB_T *ocb) {
    int status;
    char *buf = "Hello from device!\n";
    int nbytes = strlen(buf);

    if (ocb->offset >= nbytes)
        return 0;

    nbytes -= ocb->offset;

    // Return data to client
    _IO_SET_READ_NBYTES(ctp, nbytes);
    SETIOV(&ctp->iov[0], buf + ocb->offset, nbytes);

    ocb->offset += nbytes;

    return _RESMGR_NPARTS(1);
}

int io_write(resmgr_context_t *ctp, io_write_t *msg,
             RESMGR_OCB_T *ocb) {
    char *buf;
    int nbytes = msg->i.nbytes;

    buf = malloc(nbytes + 1);
    resmgr_msgread(ctp, buf, nbytes, sizeof(msg->i));
    buf[nbytes] = '\0';

    printf("Received: %s\n", buf);
    free(buf);

    _IO_SET_WRITE_NBYTES(ctp, nbytes);
    return _RESMGR_NPARTS(0);
}

int main(void) {
    dispatch_t *dpp;
    resmgr_attr_t rattr;
    dispatch_context_t *ctp;
    int id;

    dpp = dispatch_create();

    memset(&rattr, 0, sizeof(rattr));
    rattr.nparts_max = 1;
    rattr.msg_max_size = 2048;

    iofunc_func_init(_RESMGR_CONNECT_NFUNCS, &connect_funcs,
                     _RESMGR_IO_NFUNCS, &io_funcs);
    io_funcs.read = io_read;
    io_funcs.write = io_write;

    iofunc_attr_init(&attr, S_IFCHR | 0666, NULL, NULL);

    id = resmgr_attach(dpp, &rattr, "/dev/mydevice",
                       _FTYPE_ANY, 0, &connect_funcs,
                       &io_funcs, &attr);

    ctp = dispatch_context_alloc(dpp);

    for (;;) {
        ctp = dispatch_block(ctp);
        dispatch_handler(ctp);
    }

    return EXIT_SUCCESS;
}
```

## Interrupt Handling

```c
#include <sys/neutrino.h>

const struct sigevent *isr_handler(void *arg, int id) {
    struct sigevent *event = (struct sigevent *)arg;

    // Clear interrupt at hardware level
    out32(INT_CLEAR_REG, INT_MASK);

    // Return event to wake up thread
    return event;
}

void interrupt_thread(void *arg) {
    struct sigevent event;
    int iid;

    // Get I/O privileges
    ThreadCtl(_NTO_TCTL_IO, 0);

    // Set up pulse event
    SIGEV_INTR_INIT(&event);

    // Attach interrupt
    iid = InterruptAttach(IRQ_NUM, isr_handler, &event,
                          sizeof(event), _NTO_INTR_FLAGS_TRK_MSK);

    for (;;) {
        InterruptWait(0, NULL);

        // Process interrupt in thread context
        process_hardware_data();

        InterruptUnmask(IRQ_NUM, iid);
    }
}
```

## Adaptive Partitioning

```c
// Create partition
sched_aps_create_parms parms;
memset(&parms, 0, sizeof(parms));
parms.budget_percent = 30;  // 30% CPU budget
strncpy(parms.name, "camera_partition", sizeof(parms.name));

int part_id = SchedCtl(SCHED_APS_CREATE_PARTITION, &parms, sizeof(parms));

// Join partition
sched_aps_join_parms join;
join.id = part_id;
join.pid = getpid();
join.tid = 0;

SchedCtl(SCHED_APS_JOIN_PARTITION, &join, sizeof(join));
```
12:T15cb,
# Zephyr RTOS Development

## Project Structure

```
my_app/
├── CMakeLists.txt
├── prj.conf
├── app.overlay
└── src/
    └── main.c
```

### CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.20.0)
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
project(my_app)

target_sources(app PRIVATE src/main.c)
```

### prj.conf
```ini
CONFIG_GPIO=y
CONFIG_I2C=y
CONFIG_SPI=y
CONFIG_SENSOR=y
CONFIG_LOG=y
CONFIG_SHELL=y
CONFIG_HEAP_MEM_POOL_SIZE=4096
```

## Thread and Synchronization

### Thread Creation
```c
#include <zephyr/kernel.h>

#define STACK_SIZE 1024
#define PRIORITY 5

K_THREAD_STACK_DEFINE(my_stack, STACK_SIZE);
struct k_thread my_thread_data;

void my_thread_entry(void *p1, void *p2, void *p3) {
    while (1) {
        printk("Thread running\n");
        k_sleep(K_MSEC(1000));
    }
}

void main(void) {
    k_thread_create(&my_thread_data, my_stack,
                    K_THREAD_STACK_SIZEOF(my_stack),
                    my_thread_entry,
                    NULL, NULL, NULL,
                    PRIORITY, 0, K_NO_WAIT);
}
```

### Semaphores and Mutexes
```c
K_SEM_DEFINE(my_sem, 0, 1);
K_MUTEX_DEFINE(my_mutex);

void producer_thread(void) {
    while (1) {
        // Produce data
        k_sem_give(&my_sem);
        k_sleep(K_MSEC(100));
    }
}

void consumer_thread(void) {
    while (1) {
        k_sem_take(&my_sem, K_FOREVER);

        k_mutex_lock(&my_mutex, K_FOREVER);
        // Access shared resource
        k_mutex_unlock(&my_mutex);
    }
}
```

### Message Queues
```c
struct sensor_msg {
    uint32_t timestamp;
    int32_t value;
};

K_MSGQ_DEFINE(sensor_msgq, sizeof(struct sensor_msg), 10, 4);

void sensor_thread(void) {
    struct sensor_msg msg;

    while (1) {
        msg.timestamp = k_uptime_get_32();
        msg.value = read_sensor();

        k_msgq_put(&sensor_msgq, &msg, K_NO_WAIT);
        k_sleep(K_MSEC(100));
    }
}

void processor_thread(void) {
    struct sensor_msg msg;

    while (1) {
        k_msgq_get(&sensor_msgq, &msg, K_FOREVER);
        process_sensor(&msg);
    }
}
```

## Device Driver Model

### Simple GPIO Driver
```c
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>

#define LED0_NODE DT_ALIAS(led0)
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

void main(void) {
    int ret;

    if (!gpio_is_ready_dt(&led)) {
        return;
    }

    ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) {
        return;
    }

    while (1) {
        gpio_pin_toggle_dt(&led);
        k_sleep(K_MSEC(500));
    }
}
```

### I2C Sensor Driver
```c
#include <zephyr/drivers/i2c.h>
#include <zephyr/drivers/sensor.h>

#define SENSOR_I2C_ADDR 0x48
#define TEMP_REG 0x00

struct my_sensor_data {
    int16_t temperature;
};

struct my_sensor_config {
    struct i2c_dt_spec i2c;
};

static int my_sensor_sample_fetch(const struct device *dev,
                                   enum sensor_channel chan) {
    struct my_sensor_data *data = dev->data;
    const struct my_sensor_config *cfg = dev->config;
    uint8_t buf[2];

    if (i2c_burst_read_dt(&cfg->i2c, TEMP_REG, buf, 2) < 0) {
        return -EIO;
    }

    data->temperature = (buf[0] << 8) | buf[1];
    return 0;
}

static int my_sensor_channel_get(const struct device *dev,
                                  enum sensor_channel chan,
                                  struct sensor_value *val) {
    struct my_sensor_data *data = dev->data;

    if (chan == SENSOR_CHAN_AMBIENT_TEMP) {
        val->val1 = data->temperature / 256;
        val->val2 = (data->temperature % 256) * 10000;
        return 0;
    }

    return -ENOTSUP;
}

static const struct sensor_driver_api my_sensor_api = {
    .sample_fetch = my_sensor_sample_fetch,
    .channel_get = my_sensor_channel_get,
};

#define MY_SENSOR_INIT(n)                                           \
    static struct my_sensor_data my_sensor_data_##n;                \
    static const struct my_sensor_config my_sensor_config_##n = {   \
        .i2c = I2C_DT_SPEC_INST_GET(n),                            \
    };                                                              \
    SENSOR_DEVICE_DT_INST_DEFINE(n, my_sensor_init, NULL,          \
                                  &my_sensor_data_##n,              \
                                  &my_sensor_config_##n,            \
                                  POST_KERNEL,                      \
                                  CONFIG_SENSOR_INIT_PRIORITY,      \
                                  &my_sensor_api);

DT_INST_FOREACH_STATUS_OKAY(MY_SENSOR_INIT)
```

## Device Tree Overlay

```dts
/* app.overlay */
/ {
    aliases {
        led0 = &myled;
    };

    leds {
        compatible = "gpio-leds";
        myled: led_0 {
            gpios = <&gpio0 13 GPIO_ACTIVE_LOW>;
            label = "User LED";
        };
    };
};

&i2c0 {
    status = "okay";

    my_sensor: my_sensor@48 {
        compatible = "vendor,my-sensor";
        reg = <0x48>;
        label = "MY_SENSOR";
    };
};
```

## Power Management

```c
#include <zephyr/pm/pm.h>
#include <zephyr/pm/device.h>

static int my_driver_pm_action(const struct device *dev,
                                enum pm_device_action action) {
    switch (action) {
    case PM_DEVICE_ACTION_SUSPEND:
        // Save state, disable hardware
        return 0;
    case PM_DEVICE_ACTION_RESUME:
        // Restore state, enable hardware
        return 0;
    default:
        return -ENOTSUP;
    }
}

PM_DEVICE_DT_DEFINE(DT_NODELABEL(my_device), my_driver_pm_action);
```
13:T29c6,
# IPU (Imaging Processing Unit)

## IPU Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                           IPU                                    │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                   Input Interface                         │  │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐     │  │
│  │  │ CSI-2   │  │ CSI-2   │  │ Parallel│  │  TPG    │     │  │
│  │  │  RX 0   │  │  RX 1   │  │Interface│  │(Test)   │     │  │
│  │  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘     │  │
│  └───────┼───────────┼───────────┼───────────┼──────────────┘  │
│          │           │           │           │                  │
│  ┌───────▼───────────▼───────────▼───────────▼──────────────┐  │
│  │                Input Stage (IS)                            │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐                │  │
│  │  │   BLC    │  │  LSC     │  │   DPC    │                │  │
│  │  │(Blk Lvl) │  │(Lens     │  │(Dead Pxl)│                │  │
│  │  │ Correct) │  │ Shading) │  │ Correct) │                │  │
│  │  └──────────┘  └──────────┘  └──────────┘                │  │
│  └─────────────────────────┬────────────────────────────────┘  │
│                            │                                    │
│  ┌─────────────────────────▼────────────────────────────────┐  │
│  │               Processing Stage (PS)                       │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │  │
│  │  │ Demosaic │  │  CCM     │  │  Gamma   │  │  CSC     │ │  │
│  │  │          │  │(Color    │  │ Correct  │  │(YUV/RGB) │ │  │
│  │  │          │  │ Matrix)  │  │          │  │          │ │  │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │  │
│  └─────────────────────────┬────────────────────────────────┘  │
│                            │                                    │
│  ┌─────────────────────────▼────────────────────────────────┐  │
│  │                Output Stage                               │  │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐               │  │
│  │  │ Scaler   │  │ Cropper  │  │   DMA    │               │  │
│  │  │          │  │          │  │  Output  │               │  │
│  │  └──────────┘  └──────────┘  └──────────┘               │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## ISP Pipeline Blocks

### Black Level Correction (BLC)
```c
struct blc_config {
    s16 offset_r;   /* Red channel offset */
    s16 offset_gr;  /* Green-Red channel offset */
    s16 offset_gb;  /* Green-Blue channel offset */
    s16 offset_b;   /* Blue channel offset */
};

static void ipu_set_blc(struct ipu_dev *ipu, struct blc_config *cfg) {
    writel((cfg->offset_r & 0xFFFF) | ((cfg->offset_gr & 0xFFFF) << 16),
           ipu->base + IPU_BLC_OFFSET_RG);
    writel((cfg->offset_b & 0xFFFF) | ((cfg->offset_gb & 0xFFFF) << 16),
           ipu->base + IPU_BLC_OFFSET_GB);
}
```

### Lens Shading Correction (LSC)
```c
struct lsc_table {
    u16 r_gain[17][17];    /* Red gain table */
    u16 gr_gain[17][17];   /* Green-Red gain table */
    u16 gb_gain[17][17];   /* Green-Blue gain table */
    u16 b_gain[17][17];    /* Blue gain table */
};

static void ipu_load_lsc_table(struct ipu_dev *ipu, struct lsc_table *lsc) {
    int i, j;
    u32 *table_addr = ipu->lsc_sram;

    for (i = 0; i < 17; i++) {
        for (j = 0; j < 17; j++) {
            *table_addr++ = (lsc->r_gain[i][j] & 0x1FFF) |
                           ((lsc->gr_gain[i][j] & 0x1FFF) << 16);
            *table_addr++ = (lsc->gb_gain[i][j] & 0x1FFF) |
                           ((lsc->b_gain[i][j] & 0x1FFF) << 16);
        }
    }

    writel(IPU_LSC_ENABLE, ipu->base + IPU_LSC_CTRL);
}
```

### Color Correction Matrix (CCM)
```c
/*
 * CCM: 3x3 matrix transforming sensor RGB to sRGB
 * [R']   [ccm00 ccm01 ccm02] [R]
 * [G'] = [ccm10 ccm11 ccm12] [G]
 * [B']   [ccm20 ccm21 ccm22] [B]
 */
struct ccm_config {
    s16 matrix[3][3];  /* Signed Q3.9 format */
    s16 offset[3];     /* RGB offsets */
};

static void ipu_set_ccm(struct ipu_dev *ipu, struct ccm_config *ccm) {
    int i, j;

    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            writel(ccm->matrix[i][j],
                   ipu->base + IPU_CCM_COEF(i, j));
        }
        writel(ccm->offset[i], ipu->base + IPU_CCM_OFFSET(i));
    }
}
```

### Demosaic (Bayer Interpolation)
```c
/*
 * Bayer Pattern:
 * R  Gr R  Gr R  Gr
 * Gb B  Gb B  Gb B
 * R  Gr R  Gr R  Gr
 * Gb B  Gb B  Gb B
 */
enum bayer_pattern {
    BAYER_RGGB = 0,
    BAYER_GRBG = 1,
    BAYER_GBRG = 2,
    BAYER_BGGR = 3,
};

static void ipu_set_demosaic(struct ipu_dev *ipu,
                              enum bayer_pattern pattern,
                              bool edge_adaptive) {
    u32 val = pattern & 0x3;

    if (edge_adaptive)
        val |= IPU_DEMOSAIC_EDGE_ADAPTIVE;
    else
        val |= IPU_DEMOSAIC_BILINEAR;

    writel(val, ipu->base + IPU_DEMOSAIC_CTRL);
}
```

## 3A Algorithms Interface

### Auto Exposure (AE)
```c
struct ae_stats {
    u32 luma_sum[16][16];  /* Zone luminance sums */
    u32 pixel_count[16][16];
    u32 histogram[256];
};

struct ae_result {
    u32 exposure_time;     /* in microseconds */
    u32 analog_gain;       /* Q4.8 format */
    u32 digital_gain;      /* Q4.8 format */
};

static int ipu_get_ae_stats(struct ipu_dev *ipu, struct ae_stats *stats) {
    void __iomem *stat_base = ipu->base + IPU_AE_STATS;
    int i;

    /* Read zone statistics */
    for (i = 0; i < 256; i++) {
        stats->luma_sum[i / 16][i % 16] = readl(stat_base + i * 8);
        stats->pixel_count[i / 16][i % 16] = readl(stat_base + i * 8 + 4);
    }

    /* Read histogram */
    for (i = 0; i < 256; i++) {
        stats->histogram[i] = readl(ipu->base + IPU_AE_HIST + i * 4);
    }

    return 0;
}
```

### Auto White Balance (AWB)
```c
struct awb_stats {
    u32 r_sum[32][32];
    u32 g_sum[32][32];
    u32 b_sum[32][32];
    u32 count[32][32];
};

struct awb_result {
    u16 r_gain;   /* Red gain, Q2.10 */
    u16 g_gain;   /* Green gain (usually 1.0) */
    u16 b_gain;   /* Blue gain, Q2.10 */
};

static void ipu_apply_awb(struct ipu_dev *ipu, struct awb_result *awb) {
    writel(awb->r_gain, ipu->base + IPU_AWB_R_GAIN);
    writel(awb->g_gain, ipu->base + IPU_AWB_G_GAIN);
    writel(awb->b_gain, ipu->base + IPU_AWB_B_GAIN);
}
```

### Auto Focus (AF)
```c
struct af_stats {
    u32 fv_h[9];   /* Horizontal frequency variance for 9 zones */
    u32 fv_v[9];   /* Vertical frequency variance */
    u32 contrast[9];
};

static void ipu_configure_af_zones(struct ipu_dev *ipu,
                                    struct rect *zones, int num) {
    int i;

    for (i = 0; i < num; i++) {
        writel((zones[i].left << 16) | zones[i].top,
               ipu->base + IPU_AF_ZONE_POS(i));
        writel((zones[i].width << 16) | zones[i].height,
               ipu->base + IPU_AF_ZONE_SIZE(i));
    }

    writel(num - 1, ipu->base + IPU_AF_ZONE_NUM);
}
```

## Buffer Management

```c
struct ipu_buffer {
    struct vb2_v4l2_buffer vb;
    struct list_head list;
    dma_addr_t dma_addr;
    u32 size;
};

static void ipu_queue_buffer(struct ipu_dev *ipu, struct ipu_buffer *buf) {
    /* Write buffer address to hardware */
    writeq(buf->dma_addr, ipu->base + IPU_OUT_ADDR);
    writel(buf->size, ipu->base + IPU_OUT_SIZE);

    /* Trigger buffer switch on next frame */
    writel(IPU_BUF_UPDATE, ipu->base + IPU_CTRL);
}

static irqreturn_t ipu_frame_done_isr(int irq, void *dev_id) {
    struct ipu_dev *ipu = dev_id;
    struct ipu_buffer *buf;

    /* Get completed buffer */
    spin_lock(&ipu->lock);
    buf = list_first_entry(&ipu->active_list, struct ipu_buffer, list);
    list_del(&buf->list);
    spin_unlock(&ipu->lock);

    /* Mark buffer done */
    buf->vb.vb2_buf.timestamp = ktime_get_ns();
    buf->vb.sequence = ipu->frame_count++;
    vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);

    /* Queue next buffer if available */
    spin_lock(&ipu->lock);
    if (!list_empty(&ipu->pending_list)) {
        buf = list_first_entry(&ipu->pending_list, struct ipu_buffer, list);
        list_move_tail(&buf->list, &ipu->active_list);
        ipu_queue_buffer(ipu, buf);
    }
    spin_unlock(&ipu->lock);

    return IRQ_HANDLED;
}
```
14:T2660,
# SoC Architecture Fundamentals

## Modern SoC Block Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                          SoC                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    CPU Cluster                           │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │
│  │  │ Cortex  │ │ Cortex  │ │ Cortex  │ │ Cortex  │       │   │
│  │  │  A78    │ │  A78    │ │  A55    │ │  A55    │       │   │
│  │  └────┬────┘ └────┬────┘ └────┬────┘ └────┬────┘       │   │
│  │       │           │           │           │             │   │
│  │       └─────┬─────┴─────┬─────┴─────┬─────┘             │   │
│  │             │    L3 Cache          │                    │   │
│  │             └──────────┬───────────┘                    │   │
│  └─────────────────────────┼───────────────────────────────┘   │
│                            │                                    │
│  ┌─────────────────────────┼───────────────────────────────┐   │
│  │                  NoC (Network on Chip)                   │   │
│  │              (CCI-500 / CMN-600 / NoC-400)              │   │
│  └───────┬─────────┬───────┴───────┬─────────┬─────────────┘   │
│          │         │               │         │                  │
│    ┌─────▼───┐ ┌───▼────┐   ┌─────▼───┐ ┌───▼────┐            │
│    │   GPU   │ │  NPU   │   │   IPU   │ │  VPU   │            │
│    │         │ │  (AI)  │   │ (Camera)│ │(Video) │            │
│    └─────────┘ └────────┘   └─────────┘ └────────┘            │
│                                                                 │
│    ┌─────────────────────────────────────────────────────┐    │
│    │                Memory Controller                      │    │
│    │              (LPDDR5/DDR5 Interface)                  │    │
│    └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

## ARM CPU Subsystem

### Exception Levels
```
EL3 - Secure Monitor (ATF/TF-A)
 │
 ├── EL2 - Hypervisor (KVM, Xen)
 │    │
 │    └── EL1 - OS Kernel (Linux, RTOS)
 │         │
 │         └── EL0 - User Applications
 │
 └── Secure World
      ├── S-EL1 - Secure OS (OP-TEE)
      └── S-EL0 - Trusted Applications
```

### CPU Core Configuration
```c
// Reading CPU features (CPUID)
static void read_cpu_features(void) {
    u64 midr, mpidr, revidr;

    // Main ID Register
    midr = read_sysreg(MIDR_EL1);
    pr_info("MIDR: Implementer=0x%x, Variant=%d, Part=0x%x, Rev=%d\n",
            (midr >> 24) & 0xFF,
            (midr >> 20) & 0xF,
            (midr >> 4) & 0xFFF,
            midr & 0xF);

    // Multiprocessor Affinity Register
    mpidr = read_sysreg(MPIDR_EL1);
    pr_info("MPIDR: Aff3=%d, Aff2=%d, Aff1=%d, Aff0=%d\n",
            (mpidr >> 32) & 0xFF,
            (mpidr >> 16) & 0xFF,
            (mpidr >> 8) & 0xFF,
            mpidr & 0xFF);
}
```

## NoC (Network on Chip)

### NoC Topology
```
         ┌─────────┐
         │  CPU    │
         └────┬────┘
              │
    ┌─────────┼─────────┐
    │         │         │
┌───▼───┐ ┌───▼───┐ ┌───▼───┐
│ Router│ │ Router│ │ Router│
└───┬───┘ └───┬───┘ └───┬───┘
    │         │         │
┌───▼───┐ ┌───▼───┐ ┌───▼───┐
│  GPU  │ │  IPU  │ │  DDR  │
└───────┘ └───────┘ └───────┘
```

### QoS (Quality of Service)
```c
// NoC QoS register configuration
struct noc_qos_regs {
    u32 priority;       // Transaction priority
    u32 mode;           // Fixed/Limiter/Regulator
    u32 bandwidth;      // Bandwidth limit
    u32 saturation;     // Saturation threshold
};

static void configure_noc_qos(void __iomem *base, int master_id,
                               struct noc_qos_regs *qos) {
    void __iomem *master_base = base + (master_id * 0x100);

    writel(qos->priority, master_base + NOC_QOS_PRIORITY);
    writel(qos->mode, master_base + NOC_QOS_MODE);
    writel(qos->bandwidth, master_base + NOC_QOS_BANDWIDTH);
    writel(qos->saturation, master_base + NOC_QOS_SATURATION);
}
```

## Power Domain Management

### Power Domain Hierarchy
```dts
power: power-controller@ff010000 {
    compatible = "vendor,power-controller";
    reg = <0x0 0xff010000 0x0 0x1000>;
    #power-domain-cells = <1>;

    pd_gpu: power-domain@0 {
        reg = <0>;
        #power-domain-cells = <0>;
    };

    pd_ipu: power-domain@1 {
        reg = <1>;
        #power-domain-cells = <0>;
        power-domains = <&pd_top>;  /* Parent dependency */
    };

    pd_vpu: power-domain@2 {
        reg = <2>;
        #power-domain-cells = <0>;
    };
};

gpu: gpu@ff100000 {
    power-domains = <&pd_gpu>;
};
```

### Power Domain Driver
```c
#include <linux/pm_domain.h>

struct my_pm_domain {
    struct generic_pm_domain genpd;
    void __iomem *base;
    u32 pwr_mask;
};

static int my_pd_power_on(struct generic_pm_domain *genpd) {
    struct my_pm_domain *pd = container_of(genpd, struct my_pm_domain, genpd);
    u32 val;
    int timeout = 1000;

    // Request power on
    val = readl(pd->base + PWR_CTRL);
    val |= pd->pwr_mask;
    writel(val, pd->base + PWR_CTRL);

    // Wait for power good
    while (--timeout) {
        val = readl(pd->base + PWR_STATUS);
        if (val & pd->pwr_mask)
            return 0;
        udelay(10);
    }

    return -ETIMEDOUT;
}

static int my_pd_power_off(struct generic_pm_domain *genpd) {
    struct my_pm_domain *pd = container_of(genpd, struct my_pm_domain, genpd);
    u32 val;

    val = readl(pd->base + PWR_CTRL);
    val &= ~pd->pwr_mask;
    writel(val, pd->base + PWR_CTRL);

    return 0;
}
```

## Clock Tree

```
                    ┌─────────────┐
                    │   PLL0      │
                    │  (24MHz →   │
                    │   1.2GHz)   │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼─────┐      ┌─────▼────┐      ┌─────▼────┐
   │ CPU DIV  │      │ GPU DIV  │      │ BUS DIV  │
   │  (/1)    │      │  (/2)    │      │  (/4)    │
   └────┬─────┘      └─────┬────┘      └─────┬────┘
        │                  │                  │
   ┌────▼─────┐      ┌─────▼────┐      ┌─────▼────┐
   │ CPU Gate │      │ GPU Gate │      │ BUS Gate │
   └────┬─────┘      └─────┬────┘      └─────┬────┘
        │                  │                  │
        ▼                  ▼                  ▼
     1.2GHz             600MHz             300MHz
```

### Clock Driver
```c
#include <linux/clk-provider.h>

static const struct clk_ops my_pll_ops = {
    .recalc_rate = my_pll_recalc_rate,
    .set_rate = my_pll_set_rate,
    .round_rate = my_pll_round_rate,
    .enable = my_pll_enable,
    .disable = my_pll_disable,
    .is_enabled = my_pll_is_enabled,
};

static unsigned long my_pll_recalc_rate(struct clk_hw *hw,
                                         unsigned long parent_rate) {
    struct my_pll *pll = to_my_pll(hw);
    u32 fbdiv, refdiv, postdiv;

    fbdiv = readl(pll->base + PLL_FBDIV) & 0xFFF;
    refdiv = readl(pll->base + PLL_REFDIV) & 0x3F;
    postdiv = readl(pll->base + PLL_POSTDIV) & 0x7;

    return (parent_rate * fbdiv) / (refdiv * postdiv);
}
```
15:T22da,
# ARM TrustZone and Secure Boot

## TrustZone Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        ARM Processor                             │
│  ┌──────────────────────┐    ┌──────────────────────┐          │
│  │     Normal World     │    │     Secure World     │          │
│  │  ┌────────────────┐  │    │  ┌────────────────┐  │          │
│  │  │ Rich OS (Linux)│  │    │  │  Secure OS     │  │          │
│  │  │     EL1       │  │    │  │  (OP-TEE) S-EL1│  │          │
│  │  └───────┬────────┘  │    │  └───────┬────────┘  │          │
│  │          │          │    │          │          │          │
│  │  ┌───────▼────────┐  │    │  ┌───────▼────────┐  │          │
│  │  │ User Apps EL0  │  │    │  │Trusted Apps    │  │          │
│  │  └────────────────┘  │◄──►│  │    S-EL0       │  │          │
│  └──────────────────────┘    │  └────────────────┘  │          │
│                              └──────────────────────┘          │
│                    ┌────────────────────┐                       │
│                    │  Secure Monitor    │                       │
│                    │      EL3 (ATF)     │                       │
│                    └────────────────────┘                       │
└─────────────────────────────────────────────────────────────────┘
```

## Secure Boot Chain

```
Boot ROM (Immutable)
    │
    ▼ Verify signature
BL1 (Primary Bootloader in ROM)
    │
    ▼ Verify signature
BL2 (Trusted Boot Firmware)
    │
    ├─► BL31 (EL3 Runtime - ATF)
    │
    ├─► BL32 (Secure OS - OP-TEE) [Optional]
    │
    └─► BL33 (Normal World - U-Boot)
            │
            ▼ Verify signature
        Linux Kernel + DTB
            │
            ▼ dm-verity
        Root Filesystem
```

## ARM Trusted Firmware (ATF)

### BL31 Services
```c
/* PSCI (Power State Coordination Interface) */
#include <lib/psci/psci.h>

static int my_pwr_domain_on(u_register_t mpidr) {
    unsigned int core = plat_core_pos_by_mpidr(mpidr);

    /* Configure core reset vector */
    mmio_write_32(RVBAR_ADDR(core), BL31_BASE);

    /* Release core from reset */
    mmio_setbits_32(PWR_CTRL_ADDR(core), CORE_PWRON);

    return PSCI_E_SUCCESS;
}

static void my_pwr_domain_off(const psci_power_state_t *state) {
    unsigned int core = plat_my_core_pos();

    /* Disable GIC CPU interface */
    gicv3_cpuif_disable(get_gic_data());

    /* Power down core */
    mmio_clrbits_32(PWR_CTRL_ADDR(core), CORE_PWRON);
}

static const plat_psci_ops_t my_psci_ops = {
    .pwr_domain_on = my_pwr_domain_on,
    .pwr_domain_off = my_pwr_domain_off,
    .pwr_domain_suspend = my_pwr_domain_suspend,
    .pwr_domain_on_finish = my_pwr_domain_on_finish,
    .system_reset = my_system_reset,
};
```

### SMC Handling
```c
/* Secure Monitor Call handler */
static uintptr_t my_sip_smc_handler(
    unsigned int smc_fid,
    u_register_t x1, u_register_t x2,
    u_register_t x3, u_register_t x4,
    void *cookie, void *handle, u_register_t flags)
{
    switch (smc_fid) {
    case MY_SIP_SVC_CALL_COUNT:
        SMC_RET1(handle, MY_SIP_CALL_COUNT);

    case MY_SIP_SVC_UID:
        SMC_UUID_RET(handle, my_sip_svc_uid);

    case MY_SIP_SVC_VERSION:
        SMC_RET2(handle, MY_SVC_VERSION_MAJOR, MY_SVC_VERSION_MINOR);

    case MY_SIP_DDR_FUNC:
        return my_ddr_smc_handler(x1, x2, x3, x4, handle);

    default:
        WARN("Unimplemented SIP call: 0x%x\n", smc_fid);
        SMC_RET1(handle, SMC_UNK);
    }
}

DECLARE_RT_SVC(
    my_sip_svc,
    OEN_SIP_START,
    OEN_SIP_END,
    SMC_TYPE_FAST,
    NULL,
    my_sip_smc_handler
);
```

## OP-TEE Integration

### Trusted Application
```c
/* ta/my_ta/my_ta.c */
#include <tee_internal_api.h>

#define TA_MY_CMD_ENCRYPT  0
#define TA_MY_CMD_DECRYPT  1

TEE_Result TA_CreateEntryPoint(void) {
    DMSG("TA created\n");
    return TEE_SUCCESS;
}

TEE_Result TA_InvokeCommandEntryPoint(
    void *sess_ctx, uint32_t cmd,
    uint32_t param_types,
    TEE_Param params[4])
{
    switch (cmd) {
    case TA_MY_CMD_ENCRYPT:
        return do_encrypt(param_types, params);
    case TA_MY_CMD_DECRYPT:
        return do_decrypt(param_types, params);
    default:
        return TEE_ERROR_NOT_SUPPORTED;
    }
}

static TEE_Result do_encrypt(uint32_t param_types, TEE_Param params[4]) {
    TEE_OperationHandle op;
    TEE_ObjectHandle key;

    /* Allocate crypto operation */
    TEE_AllocateOperation(&op, TEE_ALG_AES_CBC_NOPAD,
                          TEE_MODE_ENCRYPT, 256);

    /* Set key */
    TEE_SetOperationKey(op, key);

    /* Encrypt */
    TEE_CipherUpdate(op, params[0].memref.buffer,
                     params[0].memref.size,
                     params[1].memref.buffer,
                     &params[1].memref.size);

    TEE_FreeOperation(op);
    return TEE_SUCCESS;
}
```

### Linux OP-TEE Client
```c
#include <tee_client_api.h>

#define TA_UUID { 0x12345678, 0x1234, 0x1234, \
                  { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0 } }

int encrypt_data(void *input, size_t in_len, void *output, size_t *out_len) {
    TEEC_Context ctx;
    TEEC_Session sess;
    TEEC_Operation op;
    TEEC_UUID uuid = TA_UUID;
    TEEC_Result res;

    /* Initialize context */
    res = TEEC_InitializeContext(NULL, &ctx);
    if (res != TEEC_SUCCESS)
        return -1;

    /* Open session with TA */
    res = TEEC_OpenSession(&ctx, &sess, &uuid,
                           TEEC_LOGIN_PUBLIC, NULL, NULL, NULL);
    if (res != TEEC_SUCCESS)
        goto err_ctx;

    /* Prepare operation */
    memset(&op, 0, sizeof(op));
    op.paramTypes = TEEC_PARAM_TYPES(
        TEEC_MEMREF_TEMP_INPUT,
        TEEC_MEMREF_TEMP_OUTPUT,
        TEEC_NONE, TEEC_NONE);
    op.params[0].tmpref.buffer = input;
    op.params[0].tmpref.size = in_len;
    op.params[1].tmpref.buffer = output;
    op.params[1].tmpref.size = *out_len;

    /* Invoke command */
    res = TEEC_InvokeCommand(&sess, TA_MY_CMD_ENCRYPT, &op, NULL);
    if (res == TEEC_SUCCESS)
        *out_len = op.params[1].tmpref.size;

    TEEC_CloseSession(&sess);
err_ctx:
    TEEC_FinalizeContext(&ctx);
    return (res == TEEC_SUCCESS) ? 0 : -1;
}
```

## Secure Boot Key Management

### FIT Image Signing
```bash
# Generate key pair
openssl genpkey -algorithm RSA -out dev.key -pkeyopt rsa_keygen_bits:2048
openssl req -batch -new -x509 -key dev.key -out dev.crt

# Sign FIT image
mkimage -f kernel.its -k keys/ -K u-boot.dtb -r kernel.itb
```

### Device Tree Key Node
```dts
/ {
    signature {
        key-dev {
            required = "image";
            algo = "sha256,rsa2048";
            key-name-hint = "dev";
        };
    };
};
```

## Hardware Security Module

```c
/* HSM register access (example) */
struct hsm_regs {
    u32 ctrl;
    u32 status;
    u32 key_slot;
    u32 data_in[8];
    u32 data_out[8];
    u32 iv[4];
};

static int hsm_aes_encrypt(struct hsm_dev *hsm,
                           u8 *in, u8 *out, size_t len,
                           u8 *iv, int key_slot) {
    /* Select key slot */
    writel(key_slot, hsm->base + HSM_KEY_SLOT);

    /* Load IV */
    for (int i = 0; i < 4; i++)
        writel(((u32 *)iv)[i], hsm->base + HSM_IV + i * 4);

    /* Process data blocks */
    for (size_t offset = 0; offset < len; offset += 16) {
        /* Load input block */
        for (int i = 0; i < 4; i++)
            writel(((u32 *)(in + offset))[i],
                   hsm->base + HSM_DATA_IN + i * 4);

        /* Start operation */
        writel(HSM_OP_AES_CBC_ENC | HSM_START, hsm->base + HSM_CTRL);

        /* Wait for completion */
        while (!(readl(hsm->base + HSM_STATUS) & HSM_DONE))
            cpu_relax();

        /* Read output */
        for (int i = 0; i < 4; i++)
            ((u32 *)(out + offset))[i] =
                readl(hsm->base + HSM_DATA_OUT + i * 4);
    }

    return 0;
}
```
16:T17d5,
# CMake Build System

## Project Structure

```
my-project/
├── CMakeLists.txt              # Root CMake file
├── cmake/
│   ├── toolchain-aarch64.cmake # Cross-compile toolchain
│   └── FindMyLib.cmake         # Custom find module
├── src/
│   ├── CMakeLists.txt
│   ├── main.cpp
│   └── driver/
│       ├── CMakeLists.txt
│       └── my_driver.cpp
├── include/
│   └── myproject/
│       └── driver.h
├── tests/
│   ├── CMakeLists.txt
│   └── test_driver.cpp
└── third_party/
    └── googletest/
```

## Root CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.16)

project(MyProject
    VERSION 1.0.0
    DESCRIPTION "SoC driver framework"
    LANGUAGES C CXX
)

# C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Build type
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE "Release" CACHE STRING "Build type" FORCE)
endif()

# Options
option(BUILD_SHARED_LIBS "Build shared libraries" ON)
option(BUILD_TESTS "Build tests" ON)
option(ENABLE_SANITIZERS "Enable ASan/UBSan" OFF)

# Compiler flags
set(CMAKE_C_FLAGS_DEBUG "-g -O0 -DDEBUG")
set(CMAKE_C_FLAGS_RELEASE "-O2 -DNDEBUG")
set(CMAKE_CXX_FLAGS_DEBUG "-g -O0 -DDEBUG")
set(CMAKE_CXX_FLAGS_RELEASE "-O2 -DNDEBUG")

if(ENABLE_SANITIZERS)
    add_compile_options(-fsanitize=address,undefined)
    add_link_options(-fsanitize=address,undefined)
endif()

# Find packages
find_package(PkgConfig REQUIRED)
pkg_check_modules(LIBDRM REQUIRED libdrm)

# Include directories
include_directories(${CMAKE_SOURCE_DIR}/include)

# Add subdirectories
add_subdirectory(src)

if(BUILD_TESTS)
    enable_testing()
    add_subdirectory(third_party/googletest)
    add_subdirectory(tests)
endif()
```

## Cross-Compilation Toolchain

```cmake
# cmake/toolchain-aarch64.cmake

set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

# Specify cross-compiler
set(CMAKE_C_COMPILER aarch64-linux-gnu-gcc)
set(CMAKE_CXX_COMPILER aarch64-linux-gnu-g++)

# Sysroot (optional)
set(CMAKE_SYSROOT /opt/sysroot/aarch64)
set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})

# Search paths
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)

# Target-specific flags
set(CMAKE_C_FLAGS_INIT "-march=armv8.2-a -mtune=cortex-a78")
set(CMAKE_CXX_FLAGS_INIT "-march=armv8.2-a -mtune=cortex-a78")
```

## Library CMakeLists.txt

```cmake
# src/driver/CMakeLists.txt

add_library(mydriver
    my_driver.cpp
    register_access.cpp
    dma_engine.cpp
)

target_include_directories(mydriver
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}
)

target_link_libraries(mydriver
    PUBLIC
        ${LIBDRM_LIBRARIES}
    PRIVATE
        pthread
)

target_compile_definitions(mydriver
    PRIVATE
        DRIVER_VERSION="${PROJECT_VERSION}"
)

# Platform-specific
if(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64")
    target_compile_definitions(mydriver PRIVATE PLATFORM_ARM64)
elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64")
    target_compile_definitions(mydriver PRIVATE PLATFORM_X86_64)
endif()

# Install rules
install(TARGETS mydriver
    EXPORT mydriverTargets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)

install(DIRECTORY ${CMAKE_SOURCE_DIR}/include/myproject
    DESTINATION include
)
```

## Custom Find Module

```cmake
# cmake/FindMyLib.cmake

find_path(MYLIB_INCLUDE_DIR
    NAMES mylib/api.h
    PATHS
        /usr/include
        /usr/local/include
        ${MYLIB_ROOT}/include
)

find_library(MYLIB_LIBRARY
    NAMES mylib
    PATHS
        /usr/lib
        /usr/local/lib
        ${MYLIB_ROOT}/lib
)

include(FindPackageHandleStandardArgs)
find_package_handle_standard_args(MyLib
    REQUIRED_VARS MYLIB_LIBRARY MYLIB_INCLUDE_DIR
)

if(MYLIB_FOUND AND NOT TARGET MyLib::MyLib)
    add_library(MyLib::MyLib UNKNOWN IMPORTED)
    set_target_properties(MyLib::MyLib PROPERTIES
        IMPORTED_LOCATION "${MYLIB_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${MYLIB_INCLUDE_DIR}"
    )
endif()
```

## Test CMakeLists.txt

```cmake
# tests/CMakeLists.txt

find_package(GTest REQUIRED)

add_executable(test_driver
    test_driver.cpp
    test_dma.cpp
)

target_link_libraries(test_driver
    PRIVATE
        mydriver
        GTest::GTest
        GTest::Main
)

include(GoogleTest)
gtest_discover_tests(test_driver)
```

## Common Build Commands

```bash
# Configure (out-of-source build)
mkdir build && cd build
cmake ..

# Cross-compile
cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/toolchain-aarch64.cmake ..

# Build with parallel jobs
cmake --build . -j$(nproc)

# Build specific target
cmake --build . --target mydriver

# Install
cmake --install . --prefix /opt/myproject

# Run tests
ctest --output-on-failure

# Generate compile_commands.json (for IDE/LSP)
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..
```

## Advanced Features

### Generator Expressions
```cmake
target_compile_definitions(mylib
    PUBLIC
        $<$<CONFIG:Debug>:DEBUG_BUILD>
        $<$<BOOL:${ENABLE_FEATURE}>:FEATURE_ENABLED>
)

target_link_libraries(mylib
    PRIVATE
        $<$<PLATFORM_ID:Linux>:dl>
)
```

### Interface Library (Header-only)
```cmake
add_library(myheaders INTERFACE)
target_include_directories(myheaders
    INTERFACE
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
)
target_compile_features(myheaders INTERFACE cxx_std_17)
```

### Precompiled Headers
```cmake
target_precompile_headers(mydriver
    PRIVATE
        <vector>
        <memory>
        <cstdint>
        "driver.h"
)
```

### Fetching Dependencies
```cmake
include(FetchContent)

FetchContent_Declare(
    fmt
    GIT_REPOSITORY https://github.com/fmtlib/fmt.git
    GIT_TAG 9.1.0
)
FetchContent_MakeAvailable(fmt)

target_link_libraries(myapp PRIVATE fmt::fmt)
```
17:T15f1,
# Git Workflows for Embedded

## Kernel Development Workflow

```
                    ┌─────────────────────┐
                    │   linux-stable      │
                    │  (Linus's tree)     │
                    └──────────┬──────────┘
                               │
            ┌──────────────────┼──────────────────┐
            │                  │                  │
    ┌───────▼───────┐  ┌───────▼───────┐  ┌──────▼──────┐
    │  linux-next   │  │ vendor/kernel │  │ subsystem   │
    │  (integration)│  │   (v5.15-soc) │  │ maintainer  │
    └───────────────┘  └───────┬───────┘  └─────────────┘
                               │
                    ┌──────────▼──────────┐
                    │   feature/ipu-v2    │
                    │  (your dev branch)  │
                    └─────────────────────┘
```

## Branch Strategy

```bash
# Long-running branches
main           # Production-ready code
develop        # Integration branch
release/v1.x   # Release maintenance

# Short-lived branches
feature/xxx    # New features
bugfix/xxx     # Bug fixes
hotfix/xxx     # Critical production fixes

# Vendor tracking
vendor/kernel-5.15   # Vendor kernel baseline
vendor/atf-2.8       # ARM Trusted Firmware
```

## Common Workflows

### Rebasing Feature Branch
```bash
# Update local main
git checkout main
git fetch origin
git merge origin/main

# Rebase feature branch
git checkout feature/my-driver
git rebase main

# Resolve conflicts if any
git add <resolved-files>
git rebase --continue

# Force push (only for private branches)
git push --force-with-lease origin feature/my-driver
```

### Cherry-picking Fixes
```bash
# Find commit in upstream
git log --oneline linux-stable/linux-5.15.y -- drivers/media/

# Cherry-pick to vendor branch
git checkout vendor/kernel-5.15
git cherry-pick -x <commit-sha>

# Handle conflicts
git status
# Edit conflicted files
git add <files>
git cherry-pick --continue
```

### Creating Patch Series
```bash
# Generate patches from branch
git format-patch main..feature/my-driver -o patches/

# With cover letter
git format-patch main..feature/my-driver --cover-letter -o patches/

# Apply patches
git am patches/*.patch

# Apply with 3-way merge
git am -3 patches/*.patch
```

## Kernel Patch Submission

```bash
# Check patch
./scripts/checkpatch.pl --strict patches/0001-*.patch

# Get maintainers
./scripts/get_maintainer.pl patches/0001-*.patch

# Send patch (using git send-email)
git send-email \
    --to=maintainer@kernel.org \
    --cc=linux-media@vger.kernel.org \
    patches/0001-*.patch
```

### Proper Commit Message
```
subsystem: component: Brief description (50 chars)

Detailed explanation of what this commit does and why.
Wrap at 72 characters.

- Bullet points for clarity if needed
- Reference relevant specs or documentation

Fixes: abc1234def56 ("broken commit subject")
Signed-off-by: Your Name <your.email@example.com>
```

## Submodule Management

```bash
# Add submodule
git submodule add https://github.com/vendor/firmware.git external/firmware
git commit -m "Add firmware submodule"

# Clone with submodules
git clone --recurse-submodules <repo-url>

# Update submodules
git submodule update --init --recursive

# Update to latest
git submodule update --remote external/firmware
git commit -m "Update firmware to latest"
```

## Git Bisect for Bug Finding

```bash
# Start bisect
git bisect start

# Mark current as bad
git bisect bad HEAD

# Mark known good commit
git bisect good v5.15

# Test each commit, then mark
git bisect good  # or
git bisect bad

# Automated bisect with script
git bisect run ./test-script.sh

# When done
git bisect reset
```

## Worktree for Parallel Development

```bash
# Create worktree for different branch
git worktree add ../kernel-debug debug/my-issue

# List worktrees
git worktree list

# Remove worktree
git worktree remove ../kernel-debug
```

## Useful Git Configurations

```bash
# ~/.gitconfig
[user]
    name = Your Name
    email = your.email@example.com
    signingkey = ABCD1234

[commit]
    gpgsign = true

[alias]
    lg = log --oneline --graph --decorate
    st = status -sb
    co = checkout
    br = branch
    cp = cherry-pick
    fp = format-patch

[diff]
    algorithm = histogram
    colorMoved = default

[merge]
    conflictstyle = zdiff3

[rebase]
    autosquash = true
    autostash = true

[pull]
    rebase = true

[sendemail]
    smtpserver = smtp.example.com
    smtpserverport = 587
    smtpencryption = tls
    smtpuser = your.email@example.com
```

## Git Hooks for Quality

```bash
# .git/hooks/pre-commit (make executable)
#!/bin/bash

# Run checkpatch on staged changes
git diff --cached --name-only | grep -E '\.(c|h)$' | while read file; do
    ./scripts/checkpatch.pl --strict -f "$file"
    if [ $? -ne 0 ]; then
        echo "checkpatch failed for $file"
        exit 1
    fi
done
```

## Managing Large Binary Files

```bash
# Setup Git LFS
git lfs install

# Track binary files
git lfs track "*.bin"
git lfs track "*.elf"
git lfs track "firmware/*"

# Commit tracking file
git add .gitattributes
git commit -m "Track binary files with LFS"
```
18:T1eee,
# JTAG and Hardware Debugging

## JTAG Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         Target SoC                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   CPU 0     │  │   CPU 1     │  │   Cortex-M  │             │
│  │  (Cortex-A) │  │  (Cortex-A) │  │   (MCU)     │             │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │
│         │                │                │                      │
│  ┌──────▼────────────────▼────────────────▼──────┐             │
│  │              Debug Access Port (DAP)           │             │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐       │             │
│  │  │  APB-AP │  │  AXI-AP │  │  JTAG-AP│       │             │
│  │  └─────────┘  └─────────┘  └─────────┘       │             │
│  └──────────────────────┬────────────────────────┘             │
│                         │                                       │
│  ┌──────────────────────▼────────────────────────┐             │
│  │                   JTAG TAP                     │             │
│  │           TDI ─► TDO   TMS   TCK   TRST       │             │
│  └────────────┬─────┬─────┬─────┬─────┬──────────┘             │
└───────────────┼─────┼─────┼─────┼─────┼──────────────────────────┘
                │     │     │     │     │
         ┌──────▼─────▼─────▼─────▼─────▼──────┐
         │           JTAG Debugger              │
         │      (Lauterbach, Segger, etc.)     │
         └──────────────────────────────────────┘
```

## OpenOCD Configuration

### Target Configuration
```tcl
# myboard.cfg

# Interface
adapter driver ftdi
ftdi_vid_pid 0x0403 0x6010
ftdi_layout_init 0x0018 0x001b
ftdi_layout_signal nTRST -data 0x0010 -oe 0x0010
ftdi_layout_signal nSRST -data 0x0020 -oe 0x0020

adapter speed 1000

# SWD or JTAG
transport select jtag

# Target
set _CHIPNAME myboard
set _DAP_TAPID 0x4BA00477

# Create DAP
jtag newtap $_CHIPNAME cpu -expected-id $_DAP_TAPID \
    -irlen 4

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

# Create targets
set _TARGETNAME $_CHIPNAME.cpu
target create ${_TARGETNAME}0 cortex_a -dap $_CHIPNAME.dap \
    -coreid 0 -dbgbase 0x80010000
target create ${_TARGETNAME}1 cortex_a -dap $_CHIPNAME.dap \
    -coreid 1 -dbgbase 0x80012000

# SMP configuration
target smp ${_TARGETNAME}0 ${_TARGETNAME}1
```

### GDB Server Script
```tcl
# openocd-gdb.cfg

source [find myboard.cfg]

init
halt

# Load symbols
gdb_memory_map enable
gdb_flash_program disable
gdb_breakpoint_override hard

# Listen on port 3333
gdb_port 3333
```

## Lauterbach TRACE32 Scripts

### System Reset and Attach
```cmm
; reset_attach.cmm
SYStem.RESet
SYStem.CPU CortexA78
SYStem.CONFIG CoreNumber 4
SYStem.CONFIG COREDEBUG.Base DAP:0x80010000 DAP:0x80012000 \
                              DAP:0x80014000 DAP:0x80016000
SYStem.CONFIG CTI.Base DAP:0x80018000 DAP:0x8001A000 \
                       DAP:0x8001C000 DAP:0x8001E000
SYStem.JtagClock 20MHz
SYStem.Option TRST OFF
SYStem.Mode Attach

IF RUN()
    Break

; Load symbols
Data.LOAD.Elf vmlinux /NoCODE
```

### Memory Access
```cmm
; Memory read/write
Data.dump AD:0x80000000
Data.Set AD:0x80000000 %Long 0x12345678

; Register access
Register.Set PC 0xFFFF0000
Register.view

; Peripheral register dump
PER.view %%a 0xFF000000--0xFF000FFF
```

### Trace Configuration
```cmm
; ETM trace setup
ETM.RESet
ETM.ON
ETM.TraceID 1
ETM.Timestamps ON
ETM.Stall ON

; Configure trace buffer
Trace.METHOD CAnalyzer
Trace.SIZE 1G
Trace.INIT

; Start tracing
Go
WAIT !STATE.RUN()
Trace.List
```

## GDB Commands for Embedded

```bash
# Connect to OpenOCD
$ arm-none-eabi-gdb vmlinux
(gdb) target extended-remote localhost:3333

# Hardware breakpoints (limited number)
(gdb) hbreak my_function
(gdb) info breakpoints

# Memory examination
(gdb) x/10x 0x80000000     # 10 hex words
(gdb) x/s 0x80001000       # String
(gdb) x/10i $pc            # Instructions

# Register access
(gdb) info registers
(gdb) info registers cpsr
(gdb) set $x0 = 0x1234

# Memory-mapped register access
(gdb) set *0xFF000000 = 0x1
(gdb) print/x *0xFF000000

# Watchpoint (hardware)
(gdb) watch *(int *)0x80002000
(gdb) rwatch *(int *)0x80002000  # Read watch

# Load binary
(gdb) restore myapp.bin binary 0x80100000

# Core file debugging
(gdb) target core core.dump
```

## Linux Kernel Debugging

### Kernel Debug Symbols
```bash
# Configure kernel
CONFIG_DEBUG_INFO=y
CONFIG_DEBUG_INFO_DWARF5=y
CONFIG_GDB_SCRIPTS=y
CONFIG_FRAME_POINTER=y
CONFIG_KGDB=y
```

### KGDB Setup
```bash
# Kernel command line
kgdbwait kgdboc=ttyS0,115200

# Connect from host
$ gdb vmlinux
(gdb) set remotebaud 115200
(gdb) target remote /dev/ttyUSB0
```

### GDB Kernel Scripts
```bash
# Load kernel helper scripts
(gdb) add-auto-load-safe-path /path/to/linux/scripts/gdb

# Use kernel-specific commands
(gdb) lx-dmesg              # Show kernel log
(gdb) lx-symbols            # Load module symbols
(gdb) lx-lsmod              # List modules
(gdb) lx-ps                 # List processes
(gdb) lx-device-list-bus    # Show devices
```

## Debug Print / UART Logging

```c
/* Early printk for pre-console debug */
static void __init my_early_write(const char *s, unsigned n) {
    void __iomem *uart = (void __iomem *)UART_BASE;

    while (n--) {
        while (!(readl(uart + UART_LSR) & UART_LSR_THRE))
            cpu_relax();
        writel(*s++, uart + UART_THR);
    }
}

/* Setup earlycon */
EARLYCON_DECLARE(myuart, my_early_write);
```

### Dynamic Debug
```bash
# Enable all pr_debug in a file
echo "file my_driver.c +p" > /sys/kernel/debug/dynamic_debug/control

# Enable for specific function
echo "func my_probe +p" > /sys/kernel/debug/dynamic_debug/control

# Show all enabled debug points
cat /sys/kernel/debug/dynamic_debug/control | grep "=p"
```

## Logic Analyzer Integration

```c
/* GPIO-based debug traces */
#define DEBUG_GPIO_BASE    0xFF100000
#define DEBUG_TRACE(x)     writel((x), debug_gpio_base + 0x4)

void my_critical_function(void) {
    DEBUG_TRACE(0x01);  /* Function entry */

    /* ... processing ... */
    DEBUG_TRACE(0x02);  /* Checkpoint 1 */

    /* ... more processing ... */
    DEBUG_TRACE(0x03);  /* Function exit */
}
```

## Core Dump Analysis

```bash
# Generate crash dump (kdump configured)
echo c > /proc/sysrq-trigger

# Analyze with crash utility
$ crash vmlinux vmcore

# Common crash commands
crash> bt          # Backtrace
crash> log         # dmesg
crash> ps          # Process list
crash> vm          # Virtual memory info
crash> dev         # Device list
crash> struct task_struct <addr>
```
19:T1d02,
# Yocto Project & BitBake

## Build System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Yocto Build System                            │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    BitBake Engine                        │   │
│  └─────────────────────────┬───────────────────────────────┘   │
│                            │                                    │
│  ┌─────────────────────────▼───────────────────────────────┐   │
│  │                     Metadata                             │   │
│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐           │   │
│  │  │  Recipes  │  │  Classes  │  │   Conf    │           │   │
│  │  │  (.bb)    │  │  (.bbclass)│  │ (.conf)   │           │   │
│  │  └───────────┘  └───────────┘  └───────────┘           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────────┐  │
│  │poky (core)  │ │meta-openemb.│ │ meta-<vendor> (BSP)     │  │
│  └─────────────┘ └─────────────┘ └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

## Layer Structure

```bash
meta-mylayer/
├── conf/
│   ├── layer.conf           # Layer configuration
│   └── machine/
│       └── myboard.conf     # Machine configuration
├── recipes-bsp/
│   ├── u-boot/
│   │   └── u-boot_%.bbappend
│   └── linux/
│       └── linux-myboard_5.15.bb
├── recipes-core/
│   └── images/
│       └── my-image.bb
├── recipes-kernel/
│   └── kernel-modules/
│       └── my-driver_1.0.bb
└── classes/
    └── my-custom.bbclass
```

## Machine Configuration

```bash
# conf/machine/myboard.conf

#@TYPE: Machine
#@NAME: My Development Board
#@DESCRIPTION: Machine configuration for my board

DEFAULTTUNE ?= "cortexa78"
require conf/machine/include/arm/armv8-2a/tune-cortexa78.inc

SERIAL_CONSOLES = "115200;ttyS0"

KERNEL_IMAGETYPE = "Image"
KERNEL_DEVICETREE = "myvendor/myboard.dtb"

# Bootloader
PREFERRED_PROVIDER_virtual/bootloader = "u-boot"
UBOOT_MACHINE = "myboard_defconfig"
UBOOT_SUFFIX = "bin"

# Kernel
PREFERRED_PROVIDER_virtual/kernel = "linux-myboard"
PREFERRED_VERSION_linux-myboard = "5.15%"

# Graphics
MACHINE_FEATURES += "gpu"
PREFERRED_PROVIDER_virtual/egl = "mesa"
PREFERRED_PROVIDER_virtual/libgles2 = "mesa"

# Package architecture
PACKAGE_EXTRA_ARCHS:append = " myboard"
```

## Recipe Development

### Basic Recipe Structure
```bash
# recipes-kernel/kernel-modules/my-driver_1.0.bb

SUMMARY = "My custom kernel driver"
DESCRIPTION = "A driver for my hardware IP"
LICENSE = "GPL-2.0-only"
LIC_FILES_CHKSUM = "file://COPYING;md5=xxxxx"

inherit module

SRC_URI = "git://github.com/myorg/mydriver.git;branch=main;protocol=https"
SRCREV = "abc123def456..."

S = "${WORKDIR}/git"

# Module build arguments
EXTRA_OEMAKE:append = " KDIR=${STAGING_KERNEL_DIR}"

# Install destination
do_install:append() {
    install -d ${D}${sysconfdir}/modules-load.d
    echo "my-driver" > ${D}${sysconfdir}/modules-load.d/my-driver.conf
}

FILES:${PN} += "${sysconfdir}/modules-load.d"
```

### Recipe with CMake
```bash
# recipes-app/myapp/myapp_1.0.bb

SUMMARY = "My Application"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://LICENSE;md5=xxxxx"

inherit cmake pkgconfig

DEPENDS = "opencv libdrm"

SRC_URI = "file://src/"
S = "${WORKDIR}/src"

EXTRA_OECMAKE = " \
    -DCMAKE_BUILD_TYPE=Release \
    -DENABLE_TESTS=OFF \
"

do_install:append() {
    install -d ${D}${bindir}
    install -m 0755 ${B}/myapp ${D}${bindir}
}
```

## bbappend Files

```bash
# recipes-bsp/u-boot/u-boot_%.bbappend

FILESEXTRAPATHS:prepend := "${THISDIR}/files:"

SRC_URI += " \
    file://0001-myboard-add-board-support.patch \
    file://myboard_defconfig \
"

do_configure:prepend() {
    cp ${WORKDIR}/myboard_defconfig ${S}/configs/
}
```

## Image Recipe

```bash
# recipes-core/images/my-image.bb

SUMMARY = "My Custom Image"

inherit core-image

IMAGE_FEATURES += " \
    debug-tweaks \
    ssh-server-dropbear \
    package-management \
"

IMAGE_INSTALL += " \
    kernel-modules \
    my-driver \
    myapp \
    devmem2 \
    i2c-tools \
    spitools \
    pciutils \
    usbutils \
    v4l-utils \
    gstreamer1.0 \
    gstreamer1.0-plugins-base \
    gstreamer1.0-plugins-good \
"

# Rootfs size
IMAGE_ROOTFS_SIZE = "1048576"
IMAGE_OVERHEAD_FACTOR = "1.2"

# Enable systemd
DISTRO_FEATURES:append = " systemd"
VIRTUAL-RUNTIME_init_manager = "systemd"
```

## Custom Class

```bash
# classes/my-custom.bbclass

# Common settings for all my packages
INHIBIT_PACKAGE_STRIP = "1"
INHIBIT_SYSROOT_STRIP = "1"

# Add common dependencies
DEPENDS += "my-common-lib"

# Custom staging
my_custom_stage() {
    install -d ${STAGING_INCDIR}/myvendor
    install -m 644 ${S}/include/*.h ${STAGING_INCDIR}/myvendor/
}

do_install:append() {
    my_custom_stage
}
```

## DevTool Workflow

```bash
# Create workspace from existing recipe
devtool modify linux-myboard

# Make changes to source
cd workspace/sources/linux-myboard
git checkout -b my-feature
# ... edit code ...
git commit -a -m "Add my feature"

# Build with changes
devtool build linux-myboard

# Generate patches
devtool finish linux-myboard meta-mylayer
```

## Common Commands

```bash
# Build image
bitbake my-image

# Build specific package
bitbake myapp

# Clean and rebuild
bitbake -c cleanall myapp && bitbake myapp

# List tasks
bitbake -c listtasks myapp

# Show dependencies
bitbake -g myapp && cat pn-buildlist

# Enter devshell
bitbake -c devshell myapp

# Create SDK
bitbake my-image -c populate_sdk

# Debug
bitbake -e myapp | grep ^SRC_URI
```

## Working with SDK

```bash
# Install SDK
./poky-glibc-x86_64-my-image-cortexa78-myboard-toolchain-3.4.sh

# Setup environment
source /opt/poky/3.4/environment-setup-cortexa78-poky-linux

# Cross-compile
$CC -o mytest mytest.c

# CMake cross-compile
cmake -DCMAKE_TOOLCHAIN_FILE=$OECORE_NATIVE_SYSROOT/usr/share/cmake/toolchain.cmake
```
0:["eaUx9Dj2B8HiR4waRpBk4",[[["",{"children":["notes",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",{"children":["notes",{"children":["__PAGE__",{},["$L1",["$","main",null,{"className":"min-h-screen pt-16 bg-white dark:bg-gray-900","children":["$","$L2",null,{"categories":[{"name":"Hardware-ips","slug":"hardware-ips","notes":[{"slug":"i2c-protocol","title":"I2C Protocol and Drivers","date":"2024-01-18","category":"Hardware IPs","order":1,"filePath":"hardware-ips/i2c-protocol"},{"slug":"spi-protocol","title":"SPI Protocol and Drivers","date":"2024-01-22","category":"Hardware IPs","order":2,"filePath":"hardware-ips/spi-protocol"},{"slug":"mipi-csi2","title":"MIPI CSI-2 Camera Interface","date":"2024-02-01","category":"Hardware IPs","order":3,"filePath":"hardware-ips/mipi-csi2"},{"slug":"pcie-drivers","title":"PCIe Driver Development","date":"2024-02-08","category":"Hardware IPs","order":4,"filePath":"hardware-ips/pcie-drivers"},{"slug":"gic-controller","title":"GIC (Generic Interrupt Controller)","date":"2024-02-12","category":"Hardware IPs","order":5,"filePath":"hardware-ips/gic-controller"},{"slug":"mmu-smmu","title":"MMU and SMMU/IOMMU","date":"2024-02-18","category":"Hardware IPs","order":6,"filePath":"hardware-ips/mmu-smmu"}],"icon":"📝"},{"name":"Linux-kernel","slug":"linux-kernel","notes":[{"slug":"device-drivers","title":"Linux Device Driver Development","date":"2024-01-15","category":"Linux Kernel","order":1,"filePath":"linux-kernel/device-drivers"},{"slug":"v4l2-subsystem","title":"V4L2 Camera Subsystem","date":"2024-02-10","category":"Linux Kernel","order":2,"filePath":"linux-kernel/v4l2-subsystem"},{"slug":"device-tree","title":"Device Tree and ACPI","date":"2024-01-20","category":"Linux Kernel","order":3,"filePath":"linux-kernel/device-tree"}],"icon":"📝"},{"name":"Pre-silicon","slug":"pre-silicon","notes":[{"slug":"haps-prototyping","title":"HAPS FPGA Prototyping","date":"2024-01-20","category":"Pre-Silicon","order":1,"filePath":"pre-silicon/haps-prototyping"},{"slug":"palladium-emulation","title":"Palladium Emulation","date":"2024-01-22","category":"Pre-Silicon","order":2,"filePath":"pre-silicon/palladium-emulation"},{"slug":"first-silicon-bringup","title":"First Silicon Bring-up","date":"2024-02-05","category":"Pre-Silicon","order":3,"filePath":"pre-silicon/first-silicon-bringup"},{"slug":"validation-methodology","title":"Validation Methodology","date":"2024-02-15","category":"Pre-Silicon","order":4,"filePath":"pre-silicon/validation-methodology"}],"icon":"📝"},{"name":"Rtos","slug":"rtos","notes":[{"slug":"freertos-fundamentals","title":"FreeRTOS Fundamentals","date":"2024-01-25","category":"RTOS","order":1,"filePath":"rtos/freertos-fundamentals"},{"slug":"qnx-neutrino","title":"QNX Neutrino RTOS","date":"2024-02-05","category":"RTOS","order":2,"filePath":"rtos/qnx-neutrino"},{"slug":"zephyr-rtos","title":"Zephyr RTOS Development","date":"2024-02-15","category":"RTOS","order":3,"filePath":"rtos/zephyr-rtos"}],"icon":"📝"},{"name":"Soc-architecture","slug":"soc-architecture","notes":[{"slug":"soc-fundamentals","title":"SoC Architecture Fundamentals","date":"2024-01-12","category":"SoC Architecture","order":1,"filePath":"soc-architecture/soc-fundamentals"},{"slug":"ipu-architecture","title":"IPU (Imaging Processing Unit)","date":"2024-01-28","category":"SoC Architecture","order":2,"filePath":"soc-architecture/ipu-architecture"},{"slug":"trustzone-security","title":"ARM TrustZone and Secure Boot","date":"2024-02-20","category":"SoC Architecture","order":3,"filePath":"soc-architecture/trustzone-security"}],"icon":"📝"},{"name":"Tools","slug":"tools","notes":[{"slug":"yocto-bitbake","title":"Yocto Project & BitBake","date":"2024-01-08","category":"Tools","order":1,"filePath":"tools/yocto-bitbake"},{"slug":"jtag-debugging","title":"JTAG and Hardware Debugging","date":"2024-01-15","category":"Tools","order":2,"filePath":"tools/jtag-debugging"},{"slug":"cmake-build","title":"CMake Build System","date":"2024-02-01","category":"Tools","order":3,"filePath":"tools/cmake-build"},{"slug":"git-workflows","title":"Git Workflows for Embedded","date":"2024-02-10","category":"Tools","order":4,"filePath":"tools/git-workflows"}],"icon":"📝"}],"allNotesContent":{"hardware-ips/gic-controller":{"slug":"gic-controller","title":"GIC (Generic Interrupt Controller)","date":"2024-02-12","category":"Hardware IPs","order":5,"filePath":"hardware-ips/gic-controller","content":"$3"},"hardware-ips/i2c-protocol":{"slug":"i2c-protocol","title":"I2C Protocol and Drivers","date":"2024-01-18","category":"Hardware IPs","order":1,"filePath":"hardware-ips/i2c-protocol","content":"$4"},"hardware-ips/mipi-csi2":{"slug":"mipi-csi2","title":"MIPI CSI-2 Camera Interface","date":"2024-02-01","category":"Hardware IPs","order":3,"filePath":"hardware-ips/mipi-csi2","content":"$5"},"hardware-ips/mmu-smmu":{"slug":"mmu-smmu","title":"MMU and SMMU/IOMMU","date":"2024-02-18","category":"Hardware IPs","order":6,"filePath":"hardware-ips/mmu-smmu","content":"$6"},"hardware-ips/pcie-drivers":{"slug":"pcie-drivers","title":"PCIe Driver Development","date":"2024-02-08","category":"Hardware IPs","order":4,"filePath":"hardware-ips/pcie-drivers","content":"$7"},"hardware-ips/spi-protocol":{"slug":"spi-protocol","title":"SPI Protocol and Drivers","date":"2024-01-22","category":"Hardware IPs","order":2,"filePath":"hardware-ips/spi-protocol","content":"$8"},"linux-kernel/device-drivers":{"slug":"device-drivers","title":"Linux Device Driver Development","date":"2024-01-15","category":"Linux Kernel","order":1,"filePath":"linux-kernel/device-drivers","content":"$9"},"linux-kernel/device-tree":{"slug":"device-tree","title":"Device Tree and ACPI","date":"2024-01-20","category":"Linux Kernel","order":3,"filePath":"linux-kernel/device-tree","content":"$a"},"linux-kernel/v4l2-subsystem":{"slug":"v4l2-subsystem","title":"V4L2 Camera Subsystem","date":"2024-02-10","category":"Linux Kernel","order":2,"filePath":"linux-kernel/v4l2-subsystem","content":"$b"},"pre-silicon/first-silicon-bringup":{"slug":"first-silicon-bringup","title":"First Silicon Bring-up","date":"2024-02-05","category":"Pre-Silicon","order":3,"filePath":"pre-silicon/first-silicon-bringup","content":"$c"},"pre-silicon/haps-prototyping":{"slug":"haps-prototyping","title":"HAPS FPGA Prototyping","date":"2024-01-20","category":"Pre-Silicon","order":1,"filePath":"pre-silicon/haps-prototyping","content":"$d"},"pre-silicon/palladium-emulation":{"slug":"palladium-emulation","title":"Palladium Emulation","date":"2024-01-22","category":"Pre-Silicon","order":2,"filePath":"pre-silicon/palladium-emulation","content":"$e"},"pre-silicon/validation-methodology":{"slug":"validation-methodology","title":"Validation Methodology","date":"2024-02-15","category":"Pre-Silicon","order":4,"filePath":"pre-silicon/validation-methodology","content":"$f"},"rtos/freertos-fundamentals":{"slug":"freertos-fundamentals","title":"FreeRTOS Fundamentals","date":"2024-01-25","category":"RTOS","order":1,"filePath":"rtos/freertos-fundamentals","content":"$10"},"rtos/qnx-neutrino":{"slug":"qnx-neutrino","title":"QNX Neutrino RTOS","date":"2024-02-05","category":"RTOS","order":2,"filePath":"rtos/qnx-neutrino","content":"$11"},"rtos/zephyr-rtos":{"slug":"zephyr-rtos","title":"Zephyr RTOS Development","date":"2024-02-15","category":"RTOS","order":3,"filePath":"rtos/zephyr-rtos","content":"$12"},"soc-architecture/ipu-architecture":{"slug":"ipu-architecture","title":"IPU (Imaging Processing Unit)","date":"2024-01-28","category":"SoC Architecture","order":2,"filePath":"soc-architecture/ipu-architecture","content":"$13"},"soc-architecture/soc-fundamentals":{"slug":"soc-fundamentals","title":"SoC Architecture Fundamentals","date":"2024-01-12","category":"SoC Architecture","order":1,"filePath":"soc-architecture/soc-fundamentals","content":"$14"},"soc-architecture/trustzone-security":{"slug":"trustzone-security","title":"ARM TrustZone and Secure Boot","date":"2024-02-20","category":"SoC Architecture","order":3,"filePath":"soc-architecture/trustzone-security","content":"$15"},"tools/cmake-build":{"slug":"cmake-build","title":"CMake Build System","date":"2024-02-01","category":"Tools","order":3,"filePath":"tools/cmake-build","content":"$16"},"tools/git-workflows":{"slug":"git-workflows","title":"Git Workflows for Embedded","date":"2024-02-10","category":"Tools","order":4,"filePath":"tools/git-workflows","content":"$17"},"tools/jtag-debugging":{"slug":"jtag-debugging","title":"JTAG and Hardware Debugging","date":"2024-01-15","category":"Tools","order":2,"filePath":"tools/jtag-debugging","content":"$18"},"tools/yocto-bitbake":{"slug":"yocto-bitbake","title":"Yocto Project & BitBake","date":"2024-01-08","category":"Tools","order":1,"filePath":"tools/yocto-bitbake","content":"$19"}},"initialNotePath":"hardware-ips/i2c-protocol"}]}],null]]},["$","$L1a",null,{"parallelRouterKey":"children","segmentPath":["children","notes","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L1b",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":[["$","head",null,{"children":["$","script",null,{"type":"application/ld+json","dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"Person\",\"name\":\"Ding Yunliang\",\"url\":\"https://dingyunliang.github.io\",\"jobTitle\":\"Full-Stack Developer\",\"description\":\"Full-Stack Developer specializing in React, Next.js, TypeScript, and Node.js\",\"sameAs\":[\"https://github.com/dingyunliang\",\"https://www.linkedin.com/in/yunliang-ding\",\"https://twitter.com/dingyunliang\"],\"knowsAbout\":[\"Web Development\",\"React\",\"Next.js\",\"TypeScript\",\"Node.js\",\"JavaScript\",\"Tailwind CSS\"]}"}}]}],["$","body",null,{"className":"bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300","children":["$","$L1c",null,{"children":[["$","$L1d",null,{}],["$","main",null,{"role":"main","children":["$","$L1a",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L1b",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}],["$","footer",null,{"className":"bg-gray-900 dark:bg-gray-950 text-white transition-colors duration-300","children":["$","div",null,{"className":"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8","children":[["$","div",null,{"className":"py-12 grid grid-cols-1 md:grid-cols-3 gap-8","children":[["$","div",null,{"className":"space-y-4","children":[["$","$L1e",null,{"href":"/","className":"flex items-center space-x-2","children":[["$","div",null,{"className":"w-10 h-10 bg-gradient-to-br from-primary-400 to-primary-600 rounded-lg flex items-center justify-center","children":["$","span",null,{"className":"text-white font-bold text-xl","children":"SD"}]}],["$","span",null,{"className":"font-bold text-xl","children":"Ding Yunliang"}]]}],["$","p",null,{"className":"text-gray-400 max-w-xs","children":"Building digital experiences that make a difference. Let's create something amazing together."}]]}],["$","div",null,{"children":[["$","h3",null,{"className":"font-semibold text-lg mb-4","children":"Quick Links"}],["$","ul",null,{"className":"space-y-2","children":[["$","li","Home",{"children":["$","$L1e",null,{"href":"#home","className":"text-gray-400 hover:text-white transition-colors","children":"Home"}]}],["$","li","About",{"children":["$","$L1e",null,{"href":"#about","className":"text-gray-400 hover:text-white transition-colors","children":"About"}]}],["$","li","Projects",{"children":["$","$L1e",null,{"href":"#projects","className":"text-gray-400 hover:text-white transition-colors","children":"Projects"}]}],["$","li","Contact",{"children":["$","$L1e",null,{"href":"#contact","className":"text-gray-400 hover:text-white transition-colors","children":"Contact"}]}]]}]]}],["$","div",null,{"children":[["$","h3",null,{"className":"font-semibold text-lg mb-4","children":"Get in Touch"}],["$","p",null,{"className":"text-gray-400 mb-4","children":"Feel free to reach out for collaborations or just a friendly hello!"}],["$","div",null,{"className":"flex space-x-4","children":[["$","$L1e","GitHub",{"href":"https://github.com","className":"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200","aria-label":"GitHub","target":"_blank","rel":"noopener noreferrer","children":["$","svg",null,{"className":"w-5 h-5","fill":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"d":"M12 0C5.374 0 0 5.373 0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"}]}]}],["$","$L1e","LinkedIn",{"href":"https://www.linkedin.com/in/yunliang-ding","className":"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200","aria-label":"LinkedIn","target":"_blank","rel":"noopener noreferrer","children":["$","svg",null,{"className":"w-5 h-5","fill":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"d":"M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"}]}]}],["$","$L1e","Twitter",{"href":"https://twitter.com","className":"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200","aria-label":"Twitter","target":"_blank","rel":"noopener noreferrer","children":["$","svg",null,{"className":"w-5 h-5","fill":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"d":"M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"}]}]}],["$","$L1e","Email",{"href":"mailto:yunliang.ding@gmail.com","className":"w-10 h-10 bg-gray-800 dark:bg-gray-800 rounded-lg flex items-center justify-center text-gray-400 hover:bg-primary-600 hover:text-white transition-all duration-200","aria-label":"Email","target":"_blank","rel":"noopener noreferrer","children":["$","svg",null,{"className":"w-5 h-5","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"}]}]}]]}]]}]]}],["$","div",null,{"className":"border-t border-gray-800 dark:border-gray-700 py-6 flex flex-col sm:flex-row justify-between items-center gap-4","children":[["$","p",null,{"className":"text-gray-400 text-sm","children":["© ",2026," Ding Yunliang. All rights reserved."]}],["$","p",null,{"className":"text-gray-500 text-sm","children":["Built with"," ",["$","span",null,{"className":"text-red-500","children":"❤"}]," using Next.js & Tailwind CSS"]}]]}]]}]}]]}]}]]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/970e8a637e5cd1c2.css","precedence":"next","crossOrigin":""}]],"$L1f"]]]]
1f:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"name":"theme-color","media":"(prefers-color-scheme: light)","content":"#ffffff"}],["$","meta","2",{"name":"theme-color","media":"(prefers-color-scheme: dark)","content":"#111827"}],["$","meta","3",{"charSet":"utf-8"}],["$","title","4",{"children":"Learning Notes | Ding Yunliang"}],["$","meta","5",{"name":"description","content":"Personal learning notes on JavaScript, CSS, React, Cloudflare, and other web development topics."}],["$","link","6",{"rel":"author","href":"https://dingyunliang.github.io"}],["$","meta","7",{"name":"author","content":"Ding Yunliang"}],["$","link","8",{"rel":"manifest","href":"/site.webmanifest"}],["$","meta","9",{"name":"keywords","content":"Full-Stack Developer,Web Developer,React Developer,Next.js,TypeScript,Node.js,Portfolio,Ding Yunliang"}],["$","meta","10",{"name":"creator","content":"Ding Yunliang"}],["$","meta","11",{"name":"publisher","content":"Ding Yunliang"}],["$","meta","12",{"name":"robots","content":"index, follow"}],["$","meta","13",{"name":"googlebot","content":"index, follow, max-video-preview:-1, max-image-preview:large, max-snippet:-1"}],["$","meta","14",{"name":"category","content":"technology"}],["$","link","15",{"rel":"canonical","href":"https://dingyunliang.github.io"}],["$","meta","16",{"property":"og:title","content":"Ding Yunliang | Full-Stack Developer & Creative Problem Solver"}],["$","meta","17",{"property":"og:description","content":"Explore the portfolio of Ding Yunliang - a Full-Stack Developer crafting beautiful, performant web applications with React, Next.js, and modern technologies."}],["$","meta","18",{"property":"og:url","content":"https://dingyunliang.github.io"}],["$","meta","19",{"property":"og:site_name","content":"Ding Yunliang Portfolio"}],["$","meta","20",{"property":"og:locale","content":"en_US"}],["$","meta","21",{"property":"og:image","content":"http://localhost:3000/og-image.jpg"}],["$","meta","22",{"property":"og:image:width","content":"1200"}],["$","meta","23",{"property":"og:image:height","content":"630"}],["$","meta","24",{"property":"og:image:alt","content":"Ding Yunliang - Full-Stack Developer Portfolio"}],["$","meta","25",{"property":"og:type","content":"website"}],["$","meta","26",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","27",{"name":"twitter:creator","content":"@dingyunliang"}],["$","meta","28",{"name":"twitter:title","content":"Ding Yunliang | Full-Stack Developer"}],["$","meta","29",{"name":"twitter:description","content":"Full-Stack Developer specializing in React, Next.js, and Node.js. View my portfolio and let's build something amazing together."}],["$","meta","30",{"name":"twitter:image","content":"http://localhost:3000/og-image.jpg"}],["$","link","31",{"rel":"shortcut icon","href":"/favicon-16x16.png"}],["$","link","32",{"rel":"icon","href":"/favicon.ico"}],["$","link","33",{"rel":"apple-touch-icon","href":"/apple-touch-icon.png"}]]
1:null
